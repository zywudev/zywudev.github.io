

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="贾小昆">
  <meta name="keywords" content="">
  <title>OkHttp 源码分析（三）：连接机制 - 贾小昆</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>贾小昆</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-03-27 19:50" pubdate>
      2019年3月27日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      31
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">OkHttp 源码分析（三）：连接机制</h1>
            
            <div class="markdown-body" id="post-body">
              <p>前面两篇文章分别介绍了 OkHttp 的请求流程和缓存机制，最后这篇文章介绍 OkHttp 的连接机制，作为 OkHttp 源码分析的收尾。</p>
<p>建议将 OkHttp 的源码下载下来，使用 IDEA 编辑器可以直接打开阅读。我这边也将最新版的源码下载下来，进行了注释说明，有需要的可以直接从 <a target="_blank" rel="noopener" href="https://github.com/zywudev/android-open-framework-analysis">Android open framework analysis</a> 查看。</p>
<h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><p>OkHttp 连接的创建是通过 StreamAllocation 对象统筹完成。</p>
<p>它主要用来管理两个角色：</p>
<ul>
<li>RealConnection：真正建立连接的对象，利用 Socket 建立连接。</li>
<li>ConnectionPool：连接池，用来管理和复用连接。</li>
</ul>
<p>StreamAllocation 是在 RetryAndFollowUpInterceptor 中被创建，此时并未发起连接。</p>
<pre><code class="hljs java"><span class="hljs-comment">// RetryAndFollowUpInterceptor .intercept()</span>

StreamAllocation streamAllocation = <span class="hljs-keyword">new</span> StreamAllocation(client.connectionPool(),
        createAddress(request.url()), call, eventListener, callStackTrace);</code></pre>

<p>真正的连接是在处理完 Header 和缓存之后，调用 ConnectInterceptor 进行的。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ConnectInterceptor.intercept()</span>
    
StreamAllocation streamAllocation = realChain.streamAllocation();

<span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span>
<span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">&quot;GET&quot;</span>);
HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
RealConnection connection = streamAllocation.connection();</code></pre>

<p>这里创建了两个对象：</p>
<ul>
<li>HttpCodec：用来编码 http request 和解码 http response</li>
<li>RealConnection：上文介绍了。</li>
</ul>
<p>调用 streamAllocation 的 <code>newStream</code> 方法经过一系列判断最终会走到 <code>findConnection</code> 方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">boolean</span> foundPooledConnection = <span class="hljs-keyword">false</span>;
    RealConnection result = <span class="hljs-keyword">null</span>;
    Route selectedRoute = <span class="hljs-keyword">null</span>;
    Connection releasedConnection;
    Socket toClose;
    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      <span class="hljs-keyword">if</span> (released) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;released&quot;</span>);
      <span class="hljs-keyword">if</span> (codec != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;codec != null&quot;</span>);
      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Canceled&quot;</span>);


      <span class="hljs-comment">// 1、尝试使用已分配的连接</span>
      releasedConnection = <span class="hljs-keyword">this</span>.connection;
      toClose = releaseIfNoNewStreams();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 当前连接可用.</span>
        result = <span class="hljs-keyword">this</span>.connection;
        releasedConnection = <span class="hljs-keyword">null</span>;
      &#125;
      <span class="hljs-keyword">if</span> (!reportedAcquired) &#123;
        <span class="hljs-comment">// If the connection was never reported acquired, don&#x27;t report it as released!</span>
        releasedConnection = <span class="hljs-keyword">null</span>;
      &#125;

      <span class="hljs-comment">// 2、尝试从连接池中获取一个连接</span>
      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// Attempt to get a connection from the pool.</span>
        Internal.instance.acquire(connectionPool, address, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
          foundPooledConnection = <span class="hljs-keyword">true</span>;
          result = connection;
        &#125; <span class="hljs-keyword">else</span> &#123;
          selectedRoute = route;
        &#125;
      &#125;
    &#125;
    closeQuietly(toClose);

    <span class="hljs-keyword">if</span> (releasedConnection != <span class="hljs-keyword">null</span>) &#123;
      eventListener.connectionReleased(call, releasedConnection);
    &#125;
    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;
      eventListener.connectionAcquired(call, result);
    &#125;
    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// 如果从连接池中获取到了一个连接，就将其返回.</span>
      <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-comment">// If we need a route selection, make one. This is a blocking operation.</span>
    <span class="hljs-keyword">boolean</span> newRouteSelection = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span> &amp;&amp; (routeSelection == <span class="hljs-keyword">null</span> || !routeSelection.hasNext())) &#123;
      newRouteSelection = <span class="hljs-keyword">true</span>;
      routeSelection = routeSelector.next();
    &#125;


    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Canceled&quot;</span>);

      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;
        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span>
        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span>
        <span class="hljs-comment">// 根据一系列的 IP地址从连接池中获取一个链接</span>
        List&lt;Route&gt; routes = routeSelection.getAll();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = routes.size(); i &lt; size; i++) &#123;
          Route route = routes.get(i);
          <span class="hljs-comment">// 从连接池中获取一个连接</span>
          Internal.instance.acquire(connectionPool, address, <span class="hljs-keyword">this</span>, route);
          <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
            foundPooledConnection = <span class="hljs-keyword">true</span>;
            result = connection;
            <span class="hljs-keyword">this</span>.route = route;
            <span class="hljs-keyword">break</span>;
          &#125;
        &#125;
      &#125;

      <span class="hljs-comment">// 3、如果连接池中没有可用连接，则创建一个</span>
      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;
        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;
          selectedRoute = routeSelection.next();
        &#125;

        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span>
        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span>
        route = selectedRoute;
        refusedStreamCount = <span class="hljs-number">0</span>;
        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);
        acquire(result, <span class="hljs-keyword">false</span>);
      &#125;
    &#125;

    <span class="hljs-comment">// If we found a pooled connection on the 2nd time around, we&#x27;re done.</span>
    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;
      eventListener.connectionAcquired(call, result);
      <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-comment">//4、 开始TCP以及TLS握手操作</span>
    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
        connectionRetryEnabled, call, eventListener);
    routeDatabase().connected(result.route());

    Socket socket = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      reportedAcquired = <span class="hljs-keyword">true</span>;

      <span class="hljs-comment">// 5、将新创建的连接，放在连接池中.</span>
      Internal.instance.put(connectionPool, result);

      <span class="hljs-comment">// If another multiplexed connection to the same address was created concurrently, then</span>
      <span class="hljs-comment">// release this connection and acquire that one.</span>
      <span class="hljs-keyword">if</span> (result.isMultiplexed()) &#123;
        socket = Internal.instance.deduplicate(connectionPool, address, <span class="hljs-keyword">this</span>);
        result = connection;
      &#125;
    &#125;
    closeQuietly(socket);

    eventListener.connectionAcquired(call, result);
    <span class="hljs-keyword">return</span> result;
  &#125;</code></pre>

<p>整个流程是：</p>
<ul>
<li>1、判断当前的连接是否可以使用：输入输出流没有关闭，Socket 未关闭等</li>
<li>2、如果当前连接不可用，尝试从连接池中获取一个可用连接</li>
<li>3、如果连接池中没有可用连接，则创建一个连接</li>
<li>4、开始 TCP 连接以及 TLS 握手操作</li>
<li>5、将新创建的连接加入到连接池中</li>
</ul>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>网络请求时频繁地进行 Socket 连接和断开 Socket 非常消耗网络资源和浪费时间，连接复用可以提升网络访问的效率。这里就引入了连接池的概念。</p>
<p>OKHttp 的连接池由 ConnectionPool 实现。</p>
<p>ConnetionPool 内部维护了一个线程池，负责清理无效的连接。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,
      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="hljs-string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="hljs-keyword">true</span>));
    
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(RealConnection connection)</span> </span>&#123;
    <span class="hljs-keyword">assert</span> (Thread.holdsLock(<span class="hljs-keyword">this</span>));

    <span class="hljs-keyword">if</span> (!cleanupRunning) &#123;
      cleanupRunning = <span class="hljs-keyword">true</span>;
      <span class="hljs-comment">// 使用线程池执行清理任务</span>
      executor.execute(cleanupRunnable);
    &#125;
    <span class="hljs-comment">// 将新建的连接插入到双端队列中</span>
    connections.add(connection);
   &#125;
    
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
      <span class="hljs-comment">// 清理操作，返回下次需要清理的时间</span>
      <span class="hljs-keyword">long</span> waitNanos = cleanup(System.nanoTime());
      <span class="hljs-keyword">if</span> (waitNanos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span> (waitNanos &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">long</span> waitMillis = waitNanos / <span class="hljs-number">1000000L</span>;
        waitNanos -= (waitMillis * <span class="hljs-number">1000000L</span>);
        <span class="hljs-keyword">synchronized</span> (ConnectionPool.<span class="hljs-keyword">this</span>) &#123;
          <span class="hljs-keyword">try</span> &#123;
            ConnectionPool.<span class="hljs-keyword">this</span>.wait(waitMillis, (<span class="hljs-keyword">int</span>) waitNanos);
          &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;;
&#125;</code></pre>

<p>ConnectionPool 维护一个线程池用于清理无效的连接，清理任务由 <code>cleanup</code>方法完成，首先执行清理，返回下次需要清理的间隔时间，然后调用 <code>wait</code> 方法释放锁。等到了时间，再次进行清理操作，返回下一次清理的时间，循环往复下去。</p>
<p>具体看一下 <code>cleanup</code> 方法：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">cleanup</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;
    <span class="hljs-keyword">int</span> inUseConnectionCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> idleConnectionCount = <span class="hljs-number">0</span>;
    RealConnection longestIdleConnection = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;

    <span class="hljs-comment">// Find either a connection to evict, or the time that the next eviction is due.</span>
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
        <span class="hljs-comment">// 遍历所有的连接</span>
        <span class="hljs-keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;
            RealConnection connection = i.next();

            <span class="hljs-comment">// 1、连接正在使用，即StreanAllocation的引用数量大于0</span>
            <span class="hljs-keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="hljs-number">0</span>) &#123;
                inUseConnectionCount++;
                <span class="hljs-keyword">continue</span>;
            &#125;

            idleConnectionCount++;

            <span class="hljs-comment">// If the connection is ready to be evicted, we&#x27;re done.</span>
            <span class="hljs-comment">// 2、如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放</span>
            <span class="hljs-keyword">long</span> idleDurationNs = now - connection.idleAtNanos;
            <span class="hljs-keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;
                longestIdleDurationNs = idleDurationNs;
                longestIdleConnection = connection;
            &#125;
        &#125;

        <span class="hljs-comment">// maxIdleConnections 表示最大允许的闲置的连接的数量,keepAliveDurationNs表示连接允许存活的最长的时间。</span>
        <span class="hljs-comment">// 默认空闲连接最大数目为5个，keepalive 时间最长为5分钟</span>
        <span class="hljs-comment">// 3、如果空闲连接超过5个或者keepalive时间大于5分钟，则将该连接清理</span>
        <span class="hljs-keyword">if</span> (longestIdleDurationNs &gt;= <span class="hljs-keyword">this</span>.keepAliveDurationNs
            || idleConnectionCount &gt; <span class="hljs-keyword">this</span>.maxIdleConnections) &#123;
            connections.remove(longestIdleConnection);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idleConnectionCount &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 4、闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候）</span>
            <span class="hljs-keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inUseConnectionCount &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span>
            <span class="hljs-comment">///5、所有的连接都在使用中，5分钟后再清理</span>
            <span class="hljs-keyword">return</span> keepAliveDurationNs;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// No connections, idle or in use.</span>
            <span class="hljs-comment">//6、没有连接</span>
            cleanupRunning = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        &#125;
    &#125;

    closeQuietly(longestIdleConnection.socket());

    <span class="hljs-comment">// Cleanup again immediately.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>整体流程如下：</p>
<ul>
<li>1、遍历所有连接，查询每个连接的内部的 StreamAllocation 的引用数量，如果大于 0，表示连接正在使用，无需清理，执行下一次循环。</li>
<li>2、如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放。</li>
<li>3、如果空闲连接超过 5 个或者 keepalive 时间大于 5 分钟，则将该连接清理。</li>
<li>4、闲置的连接的数量大于 0，返回该连接的到期时间（等会儿会将其清理掉，现在还不是时候）。</li>
<li>5、全部都是活跃连接，5 分钟后再进行清理。</li>
<li>6、没有任何连接，跳出循环。</li>
</ul>
<p>RealConnection 内有一个 SteamAllocation 虚引用列表，每次创建的 StreamAllocation，都会被添加到这个列表中，如果流关闭后就将 SteamAllocation 对象从该列表中移出去，也正是利用这种计数方式判定一个连接是否为空闲连接。</p>
<p>查询引用计数是在 <code>pruneAndGetAllocationCount</code> 方法中实现。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pruneAndGetAllocationCount</span><span class="hljs-params">(RealConnection connection, <span class="hljs-keyword">long</span> now)</span> </span>&#123;
    <span class="hljs-comment">// 虚引用列表</span>
    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;
    <span class="hljs-comment">// 遍历虚引用列表</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; references.size(); ) &#123;
        Reference&lt;StreamAllocation&gt; reference = references.get(i);
        <span class="hljs-comment">//如果虚引用StreamAllocation正在被使用，则跳过进行下一次循环</span>
        <span class="hljs-keyword">if</span> (reference.get() != <span class="hljs-keyword">null</span>) &#123;
            i++;
            <span class="hljs-keyword">continue</span>;
        &#125;

        <span class="hljs-comment">// We&#x27;ve discovered a leaked allocation. This is an application bug.</span>
        StreamAllocation.StreamAllocationReference streamAllocRef =
            (StreamAllocation.StreamAllocationReference) reference;
        String message = <span class="hljs-string">&quot;A connection to &quot;</span> + connection.route().address().url()
            + <span class="hljs-string">&quot; was leaked. Did you forget to close a response body?&quot;</span>;
        Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);

        <span class="hljs-comment">// 移除引用</span>
        references.remove(i);
        connection.noNewStreams = <span class="hljs-keyword">true</span>;

        <span class="hljs-comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span>
        <span class="hljs-keyword">if</span> (references.isEmpty()) &#123;
            connection.idleAtNanos = now - keepAliveDurationNs;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> references.size();
&#125;</code></pre>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a704ed05188255a8817f4c9">https://juejin.im/post/5a704ed05188255a8817f4c9</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/">https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Android/">Android</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/05/07/Android-PhotoViewEx/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android 图片预览库封装</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/03/11/ok-analysis-2/">
                        <span class="hidden-mobile">OkHttp 源码分析（二）：缓存机制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "OkHttp 源码分析（三）：连接机制&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
