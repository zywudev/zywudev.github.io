<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SparseArray 源码分析</title>
      <link href="2020/10/16/SparseArray/"/>
      <url>2020/10/16/SparseArray/</url>
      
        <content type="html"><![CDATA[<p>SparseArray（稀疏数组），是 Android 内部特有的 api，主要用来替代 HashMap&lt;Integer,E&gt; 这种形式，使用 SparseArray更加节省内存空间的使用，SparseArray 也是以key和value对数据进行保存的.使用的时候只需要指定value的类型即可.并且key不需要封装成对象类型.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitbook 简易教程</title>
      <link href="2020/10/14/gitbook-tutorial/"/>
      <url>2020/10/14/gitbook-tutorial/</url>
      
        <content type="html"><![CDATA[<p>最近开始整理自己这几年的 Android 学习笔记，用到了 gitbook 这个工具，记录一下使用方式。</p>        <h2 id="安装">          <a href="#安装" class="heading-link"><i class="fas fa-link"></i></a>安装</h2>      <p>gitbook 是一个基于 Node.js 的命令行工具，所以要先安装 Node.js。</p><p>下载地址：<span class="exturl"><a class="exturl__link" href="https://nodejs.org/en/download/%EF%BC%8C%E5%AE%89%E8%A3%85%E4%B9%9F%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%82">https://nodejs.org/en/download/，安装也很简单。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>然后使用 npm 命令安装 gitbook：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></div></figure><p>查看下版本号：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook -V</span><br></pre></td></tr></table></div></figure><p>安装成功会出现版本号：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLI version: 2.3.2</span><br><span class="line">GitBook version: 3.2.3</span><br></pre></td></tr></table></div></figure>        <h2 id="使用">          <a href="#使用" class="heading-link"><i class="fas fa-link"></i></a>使用</h2>      <p>在文件夹下，使用命令</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></div></figure><p>生成 <code>README.md</code>  和 <code>SUMMARY.md</code> 两个文件。</p><p><code>README</code> 是对书籍的简单介绍； <code>SUMMARY</code> 是书籍的目录结构。</p><p><img src="/2020/10/14/gitbook-tutorial/image-20201015144811568.png" alt="image-20201015144811568"></p><p>使用命令</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></div></figure><p>编译，在浏览器打开 <span class="exturl"><a class="exturl__link" href="http://localhost:4000/">http://localhost:4000</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 显示效果。</p>        <h2 id="发布">          <a href="#发布" class="heading-link"><i class="fas fa-link"></i></a>发布</h2>      <p>我所有的笔记文件会放在 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidGuide">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 上，这里说一下如何同步 GitHub 仓库到 gitbook，这样每次更新只需要推送到 GitHub 就行了。</p><p>在 <span class="exturl"><a class="exturl__link" href="https://www.gitbook.com/">gitbook 官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>  使用 Github 账号注册登陆，创建一个新的 space：</p><p><img src="/2020/10/14/gitbook-tutorial/image-20201014172149874.png" alt="image-20201014172149874"></p><p>点击左边的 <code>Intergrations</code> 按钮，选择 GitHub 同步：</p><p><img src="/2020/10/14/gitbook-tutorial/image-20201015110009890.png" alt="image-20201015110009890"></p><p>然后会展示出你的所有 GitHub 仓库，选择需要同步的仓库。</p><p><img src="/2020/10/14/gitbook-tutorial/image-20201015110617954.png" alt="image-20201015110617954"></p><p>这里选择从 GitHub 同步到 GitBook。</p><p><img src="/2020/10/14/gitbook-tutorial/image-20201015110748123.png" alt="image-20201015110748123"></p><p>稍等片刻，就可以了。</p><p><img src="/2020/10/14/gitbook-tutorial/image-20201015111100449.png" alt="image-20201015111100449"></p><p>预览地址：<span class="exturl"><a class="exturl__link" href="https://jaqen.gitbook.io/androidguide/%E3%80%82">https://jaqen.gitbook.io/androidguide/。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 版 IDEA 2020.2 最新破解教程</title>
      <link href="2020/09/17/mac-idea-activate/"/>
      <url>2020/09/17/mac-idea-activate/</url>
      
        <content type="html"><![CDATA[<p>近来换了 MacBook Pro，安装了 IDEA 2020.2 版本，网上大部分激活教程都不适用 2020.2 这个版本了。搜寻了一大圈，总算找到了激活方式。</p><p>有效期到 2089 年。</p><p><img src="/2020/09/17/mac-idea-activate/idea-3.png" alt="idea-3"></p><p>激活方式也很简单。</p><p>1、随便创建一个项目，把下载好的激活文件（jetbrains-agent-latest.zip），拖拽到 IDEA 项目界面上，然后会出现下面的弹框。</p><p>提示 jetbrains-agent 插件已经安装，重启 IDEA 生效。</p><p><img src="/2020/09/17/mac-idea-activate/idea-1.png" alt="idea-1"></p><p>2、重启后配置助手会提示您，需要使用哪种激活方式，这里我们选择默认的 Activation Code，通过注册码来激活，点击为 IDEA 安装：</p><p><img src="/2020/09/17/mac-idea-activate/idea-2.png" alt="idea-2"></p><p>这样就激活成功了，很简单。</p><p>需要的朋友后台回复「IDEA」获取激活工具。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 基础：内联函数</title>
      <link href="2020/09/17/kotlin-inline/"/>
      <url>2020/09/17/kotlin-inline/</url>
      
        <content type="html"><![CDATA[<p>Kotlin里使用关键字 <code>inline</code> 来表示内联函数，那么到底什么是内联函数，内联函数有什么用呢？</p><p>在 Java 中，每个方法被执行的时候都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧入栈、出栈的过程。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AspectJ 学习笔记</title>
      <link href="2020/06/03/aspectj/"/>
      <url>2020/06/03/aspectj/</url>
      
        <content type="html"><![CDATA[        <h2 id="AOP">          <a href="#AOP" class="heading-link"><i class="fas fa-link"></i></a>AOP</h2>      <blockquote><p>AOP : Aspect Oriented Programming 的缩写，意为：面向切面编程</p></blockquote><p>优点：针对同一问题的统一处理；无侵入添加代码</p><p>Android 平台，常用的是 hujiang 的一个<span class="exturl"><a class="exturl__link" href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">aspectjx插件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，它的工作原理是：通过Gradle Transform，在class文件生成后至dex文件生成前，遍历并匹配所有符合AspectJ文件中声明的切点，然后将事先声明好的代码在切点前后织入。</p><p>整个过程发生在编译期，是一种静态织入方式，所以会增加一定的编译时长，但几乎不会影响程序的运行时效率。</p>        <h2 id="AspectJ-能做什么">          <a href="#AspectJ-能做什么" class="heading-link"><i class="fas fa-link"></i></a>AspectJ 能做什么</h2>      <p>针对同一问题的统一处理，实际场景比如：</p><ul><li>统计埋点</li><li>日志打印/打点</li><li>数据校验</li><li>行为拦截</li><li>性能监控</li><li>动态权限控制</li></ul>        <h2 id="AspectJ-几个术语">          <a href="#AspectJ-几个术语" class="heading-link"><i class="fas fa-link"></i></a>AspectJ 几个术语</h2>      <ul><li>JPoint：代码可注入的点，比如一个方法的调用处或者方法内部、“读、写”变量等。</li><li>Pointcut：一个程序有很多JPoint，Pointcut的目的就是提供一种方法使得开发者能够选择自己感兴趣的JPoint。</li><li>Advice：指定注入的代码在 Pointcut 何处注入。常见的有 Before、After、Around 等，表示代码执行前、执行后、替换目标代码。</li><li>Aspect：用它声明一个类，表示一个需要执行的切面。</li></ul>        <h2 id="AspectJ-配置">          <a href="#AspectJ-配置" class="heading-link"><i class="fas fa-link"></i></a>AspectJ 配置</h2>      <p>项目根目录的build.gradle添加</p><figure class="highlight groovy"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath <span class="string">&#x27;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>app项目的build.gradle新建的module的build.gradle里添加</p><figure class="highlight groovy"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;android-aspectjx&#x27;</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    api <span class="string">&#x27;org.aspectj:aspectjrt:1.9.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>常用实例：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AspectJDemo">https://github.com/zywudev/AspectJDemo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="Aspect-语法">          <a href="#Aspect-语法" class="heading-link"><i class="fas fa-link"></i></a>Aspect 语法</h2>      <p>由于语法内容较多，实际使用过程中我们可以参考<span class="exturl"><a class="exturl__link" href="https://github.com/hiphonezhu/Android-Demos/blob/master/AspectJDemo/AspectJ.pdf">语法手册</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p><img src="/2020/06/03/aspectj/aspectj-1.png"><br><img src="/2020/06/03/aspectj/aspectj-2.png"><br><img src="/2020/06/03/aspectj/aspectj-3.png"><br><img src="/2020/06/03/aspectj/aspectj-4.png"><br><img src="/2020/06/03/aspectj/aspectj-5.png"></p>        <h2 id="参考文章">          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a>参考文章</h2>      <p><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5d7a049af265da03d1557f42">Android AspectJ详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/f90e04bcb326">AOP 之 AspectJ 全面剖析 in Android</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AspectJ </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频学习：使用 MediaCodec API 完成音频 AAC 硬编、硬解</title>
      <link href="2020/05/21/android-mediacodec/"/>
      <url>2020/05/21/android-mediacodec/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要来学习下使用 MediaCodec API 进行音频的编解码。</p>        <h2 id="什么是编码、解码？">          <a href="#什么是编码、解码？" class="heading-link"><i class="fas fa-link"></i></a>什么是编码、解码？</h2>      <p>音视频领域，我们常说的 <strong>编码</strong> 就是压缩，<strong>解码</strong> 就是解压缩。</p><p>编码的目的是减小数据的体积，减少存储空间和传输已存储文件所需的带宽。</p><p>编码后的数据是不能直接使用的，必须先解码成原来的样子。就像 zip 压缩文件里面有张图片，我们用图片查看器是无法打开的，必须先解压文件，恢复图片原来的数据，这样才能查看。音视频编解码也是同样的道理。</p>        <h2 id="MediaCodec">          <a href="#MediaCodec" class="heading-link"><i class="fas fa-link"></i></a>MediaCodec</h2>      <p>我们了解一下 Android 官方提供的音频编解码的 API，即 MediaCodec 类，该 API 是在 Andorid 4.1 （API 16） 版本引入的，因此只能工作于 Android 4.1 以上的手机上。</p><p>MediaCodec 采用了基于环形缓冲区的「生产者-消费者」模型，异步处理数据。在 input 端，Client 是这个环形缓冲区「生产者」，MediaCodec 是「消费者」。在 output 端，MediaCodec 是这个环形缓冲区「生产者」，而 Client 则变成了「消费者」。</p><p>工作流程是这样的：</p><p>（1）Client 从 input 缓冲区队列申请 empty buffer [dequeueInputBuffer]</p><p>（2）Client 把需要编解码的数据拷贝到 empty buffer，然后放入 input 缓冲区队列 [queueInputBuffer]</p><p>（3）MediaCodec 从 input 缓冲区队列取一帧数据进行编解码处理</p><p>（4）处理结束后，MediaCodec 将原始数据 buffer 置为 empty 后放回 input 缓冲区队列，将编解码后的数据放入到 output 缓冲区队列</p><p>（5）Client 从 output 缓冲区队列申请编解码后的 buffer [dequeueOutputBuffer]</p><p>（6）Client 对编解码后的 buffer 进行渲染/播放</p><p>（7）渲染/播放完成后，Client 再将该 buffer 放回 output 缓冲区队列 [releaseOutputBuffer]</p><p><img src="/2020/05/21/android-mediacodec/mediacodec.png" alt="mediacodec"></p><p>MediaCodec 使用的基本流程是：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- createEncoderByType/createDecoderByType</span><br><span class="line">- configure</span><br><span class="line">- start</span><br><span class="line">- <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    - dequeueInputBuffer</span><br><span class="line">    - queueInputBuffer</span><br><span class="line">    - dequeueOutputBuffer</span><br><span class="line">    - releaseOutputBuffer</span><br><span class="line">&#125;</span><br><span class="line">- stop</span><br><span class="line">- release</span><br></pre></td></tr></table></div></figure><p>MediaCodec 的生命周期有三种状态：<strong>停止态-Stopped、执行态-Executing、释放态-Released</strong>。</p><p>停止状态（Stopped）包括了三种子状态：未初始化（Uninitialized）、配置（Configured）、错误（Error）。</p><p>执行状态（Executing）会经历三种子状态：刷新（Flushed）、运行（Running）、流结束（End-of-Stream）</p><p><img src="/2020/05/21/android-mediacodec/mediacodec_lifecycle.png" alt="mediacodec_lifecycle"></p><p>（1）当创建编解码器的时候处于未初始化状态。首先你需要调用 configure(…) 方法让它处于 Configured 状态，然后调用 start() 方法让其处于 Executing 状态。在 Executing 状态下，你就可以使用上面提到的缓冲区来处理数据。</p><p>（2）Executing 的状态下也分为三种子状态：Flushed, Running、End-of-Stream。在 start() 调用后，编解码器处于 Flushed 状态，这个状态下它保存着所有的缓冲区。一旦第一个输入 buffer 出现了，编解码器就会自动运行到 Running 的状态。当带有 end-of-stream 标志的 buffer 进去后，编解码器会进入 End-of-Stream 状态，这种状态下编解码器不在接受输入 buffer，但是仍然在产生输出的 buffer。此时你可以调用 flush() 方法，将编解码器重置于 Flushed 状态。</p><p>（3）调用 stop() 将编解码器返回到未初始化状态，然后可以重新配置。 完成使用编解码器后，您必须通过调用 release() 来释放它。</p><p>（4）在极少数情况下，编解码器可能会遇到错误并转到错误状态。 这是使用来自排队操作的无效返回值或有时通过异常来传达的。 调用 reset() 使编解码器再次可用。 您可以从任何状态调用它来将编解码器移回未初始化状态。 否则，调用 release() 动到终端释放状态。</p>        <h2 id="AAC-编解码">          <a href="#AAC-编解码" class="heading-link"><i class="fas fa-link"></i></a>AAC 编解码</h2>      <p>对音频进行编码的目的用更少的空间来存储和传输，有有损编码和无损编码，其中我们常见的 Mp3 和 ACC 格式就是有损编码。</p><p>ACC 音频有 ADIF 和 ADTS 两种格式，第一种适用于磁盘，优点是需要空间小，但是不能边下载边播放；第二种则适用于流的传输，它是一种帧序列，可以逐帧播放。我们这里用 ADTS 这种来进行编码。</p><p><strong>ADTS 帧结构：</strong></p><p>head :: body</p><p><strong>ADTS 帧首部结构：</strong></p><div class="table-container"><table><thead><tr><th><strong>序号</strong></th><th><strong>域</strong></th><th><strong>长度（bits）</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1</td><td>Syncword</td><td>12</td><td>all bits <strong>must</strong> be 1</td></tr><tr><td>2</td><td>MPEG version</td><td>1</td><td>0 for MPEG-4, 1 for MPEG-2</td></tr><tr><td>3</td><td>Layer</td><td>2</td><td>always 0</td></tr><tr><td>4</td><td>Protection Absent</td><td>1</td><td>et to 1 if there is no CRC and 0 if there is CRC</td></tr><tr><td>5</td><td>Profile</td><td>2</td><td>the <span class="exturl"><a class="exturl__link" href="http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Object_Types">MPEG-4 Audio Object Type</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> minus 1</td></tr><tr><td>6</td><td>MPEG-4 Sampling Frequency Index</td><td>4</td><td><span class="exturl"><a class="exturl__link" href="http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Sampling_Frequencies">MPEG-4 Sampling Frequency Index</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (15 is forbidden)</td></tr><tr><td>7</td><td>Private Stream</td><td>1</td><td>set to 0 when encoding, ignore when decoding</td></tr><tr><td>8</td><td>MPEG-4 Channel Configuration</td><td>3</td><td><span class="exturl"><a class="exturl__link" href="http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Channel_Configurations">MPEG-4 Channel Configuration</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (in the case of 0, the channel configuration is sent via an inband PCE)</td></tr><tr><td>9</td><td>Originality</td><td>1</td><td>set to 0 when encoding, ignore when decoding</td></tr><tr><td>10</td><td>Home</td><td>1</td><td>set to 0 when encoding, ignore when decoding</td></tr><tr><td>11</td><td>Copyrighted Stream</td><td>1</td><td>set to 0 when encoding, ignore when decoding</td></tr><tr><td>12</td><td>Copyrighted Start</td><td>1</td><td>set to 0 when encoding, ignore when decoding</td></tr><tr><td>13</td><td>Frame Length</td><td>13</td><td>this value must include 7 or 9 bytes of header length: FrameLength = (ProtectionAbsent == 1 ? 7 : 9) + size(AACFrame)</td></tr><tr><td>14</td><td>Buffer Fullness</td><td>11</td><td>buffer fullness</td></tr><tr><td>15</td><td>Number of AAC Frames</td><td>2</td><td>number of AAC frames (RDBs) in ADTS frame <strong>minus 1</strong>, for maximum compatibility always use 1 AAC frame per ADTS frame</td></tr><tr><td>16</td><td>CRC</td><td>16</td><td>CRC if <em>protection absent</em> is 0</td></tr></tbody></table></div><p>编解码代码：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AAC 编解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AacPcmCoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;AacPcmCoder&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String AUDIO_MIME = <span class="string">&quot;audio/mp4a-latm&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> AUDIO_BYTES_PER_SAMPLE = <span class="number">44100</span> * <span class="number">1</span> * <span class="number">16</span> / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PCM 编码为 AAC 格式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inPcmFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outAacFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encodePcmToAac</span><span class="params">(File inPcmFile, File outAacFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fisRawAudio = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fosAccAudio = <span class="keyword">null</span>;</span><br><span class="line">        MediaCodec audioEncoder = createAudioEncoder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fisRawAudio = <span class="keyword">new</span> FileInputStream(inPcmFile);</span><br><span class="line">            fosAccAudio = <span class="keyword">new</span> FileOutputStream(outAacFile);</span><br><span class="line">            <span class="comment">// 开始编码</span></span><br><span class="line">            audioEncoder.start();</span><br><span class="line">            ByteBuffer[] audioInputBuffers = audioEncoder.getInputBuffers();</span><br><span class="line">            ByteBuffer[] audioOutputBuffers = audioEncoder.getOutputBuffers();</span><br><span class="line">            <span class="keyword">boolean</span> sawInputEOS = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> sawOutputEOS = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">long</span> audioTimeUs = <span class="number">0</span>;</span><br><span class="line">            MediaCodec.BufferInfo outBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">            <span class="keyword">boolean</span> readRawAudioEOS = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] rawInputBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">            <span class="keyword">int</span> readRawAudioCount;</span><br><span class="line">            <span class="keyword">int</span> rawAudioSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> lastAudioPresentationTimeUs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> inputBufIndex, outputBufIndex;</span><br><span class="line">            <span class="keyword">while</span> (!sawOutputEOS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sawInputEOS) &#123;</span><br><span class="line">                    inputBufIndex = audioEncoder.dequeueInputBuffer(<span class="number">10_000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (inputBufIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        ByteBuffer inputBuffer = audioInputBuffers[inputBufIndex];</span><br><span class="line">                        inputBuffer.clear();</span><br><span class="line">                        <span class="keyword">int</span> bufferSize = inputBuffer.remaining();</span><br><span class="line">                        <span class="keyword">if</span> (bufferSize != rawInputBytes.length) &#123;</span><br><span class="line">                            rawInputBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        readRawAudioCount = fisRawAudio.read(rawInputBytes);</span><br><span class="line">                        <span class="keyword">if</span> (readRawAudioCount == -<span class="number">1</span>) &#123;</span><br><span class="line">                            readRawAudioEOS = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (readRawAudioEOS) &#123;</span><br><span class="line">                            audioEncoder.queueInputBuffer(inputBufIndex, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, MediaCodec.BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">                            sawInputEOS = <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            inputBuffer.put(rawInputBytes, <span class="number">0</span>, readRawAudioCount);</span><br><span class="line">                            rawAudioSize += readRawAudioCount;</span><br><span class="line">                            audioEncoder.queueInputBuffer(inputBufIndex, <span class="number">0</span>, readRawAudioCount, audioTimeUs, <span class="number">0</span>);</span><br><span class="line">                            audioTimeUs = (<span class="keyword">long</span>) (<span class="number">1_000_000</span> * ((<span class="keyword">float</span>) rawAudioSize / AUDIO_BYTES_PER_SAMPLE));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                outputBufIndex = audioEncoder.dequeueOutputBuffer(outBufferInfo, <span class="number">10_000</span>);</span><br><span class="line">                <span class="keyword">if</span> (outputBufIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Simply ignore codec config buffers.</span></span><br><span class="line">                    <span class="keyword">if</span> ((outBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != <span class="number">0</span>) &#123;</span><br><span class="line">                        Log.i(TAG, <span class="string">&quot;audio encoder: codec config buffer&quot;</span>);</span><br><span class="line">                        audioEncoder.releaseOutputBuffer(outputBufIndex, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (outBufferInfo.size != <span class="number">0</span>) &#123;</span><br><span class="line">                        ByteBuffer outBuffer = audioOutputBuffers[outputBufIndex];</span><br><span class="line">                        outBuffer.position(outBufferInfo.offset);</span><br><span class="line">                        outBuffer.limit(outBufferInfo.offset + outBufferInfo.size);</span><br><span class="line">                        <span class="keyword">if</span> (lastAudioPresentationTimeUs &lt;= outBufferInfo.presentationTimeUs) &#123;</span><br><span class="line">                            lastAudioPresentationTimeUs = outBufferInfo.presentationTimeUs;</span><br><span class="line">                            <span class="keyword">int</span> outBufSize = outBufferInfo.size;</span><br><span class="line">                            <span class="keyword">int</span> outPacketSize = outBufSize + <span class="number">7</span>;</span><br><span class="line">                            outBuffer.position(outBufferInfo.offset);</span><br><span class="line">                            outBuffer.limit(outBufferInfo.offset + outBufSize);</span><br><span class="line">                            <span class="keyword">byte</span>[] outData = <span class="keyword">new</span> <span class="keyword">byte</span>[outPacketSize];</span><br><span class="line">                            addADTStoPacket(outData, outPacketSize);</span><br><span class="line">                            outBuffer.get(outData, <span class="number">7</span>, outBufSize);</span><br><span class="line">                            fosAccAudio.write(outData, <span class="number">0</span>, outData.length);</span><br><span class="line">                            <span class="comment">//Log.v(TAG, outData.length + &quot; bytes written.&quot;);</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Log.e(TAG, <span class="string">&quot;error sample! its presentationTimeUs should not lower than before.&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    audioEncoder.releaseOutputBuffer(outputBufIndex, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> ((outBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>) &#123;</span><br><span class="line">                        sawOutputEOS = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (outputBufIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">                    audioOutputBuffers = audioEncoder.getOutputBuffers();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (outputBufIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    MediaFormat audioFormat = audioEncoder.getOutputFormat();</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;format change : &quot;</span> + audioFormat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;encodePcmToAac: finish&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (fisRawAudio != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fisRawAudio.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fosAccAudio != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fosAccAudio.close();</span><br><span class="line">            &#125;</span><br><span class="line">            audioEncoder.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AAC 解码至 PCM 格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aacFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pcmFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decodeAacTomPcm</span><span class="params">(File aacFile, File pcmFile)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        MediaExtractor extractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line">        extractor.setDataSource(aacFile.getAbsolutePath());</span><br><span class="line">        MediaFormat mediaFormat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; extractor.getTrackCount(); i++) &#123;</span><br><span class="line">            MediaFormat format = extractor.getTrackFormat(i);</span><br><span class="line">            String mime = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">            <span class="keyword">if</span> (mime.startsWith(<span class="string">&quot;audio/&quot;</span>)) &#123;</span><br><span class="line">                extractor.selectTrack(i);</span><br><span class="line">                mediaFormat = format;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mediaFormat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Invalid file with audio track.&quot;</span>);</span><br><span class="line">            extractor.release();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fosDecoder = <span class="keyword">new</span> FileOutputStream(pcmFile);</span><br><span class="line">        String mediaMime = mediaFormat.getString(MediaFormat.KEY_MIME);</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;decodeAacToPcm: mimeType: &quot;</span> + mediaMime);</span><br><span class="line">        MediaCodec codec = MediaCodec.createDecoderByType(mediaMime);</span><br><span class="line">        codec.configure(mediaFormat, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        codec.start();</span><br><span class="line">        ByteBuffer[] codecInputBuffers = codec.getInputBuffers();</span><br><span class="line">        ByteBuffer[] codecOutputBuffers = codec.getOutputBuffers();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> kTimeOutUs = <span class="number">10_000</span>;</span><br><span class="line">        MediaCodec.BufferInfo info = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        <span class="keyword">boolean</span> sawInputEOS = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sawOutputEOS = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!sawOutputEOS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sawInputEOS) &#123;</span><br><span class="line">                    <span class="keyword">int</span> inputBufIndex = codec.dequeueInputBuffer(kTimeOutUs);</span><br><span class="line">                    <span class="keyword">if</span> (inputBufIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        ByteBuffer dstBuf = codecInputBuffers[inputBufIndex];</span><br><span class="line">                        <span class="keyword">int</span> sampleSize = extractor.readSampleData(dstBuf, <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (sampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;saw input EOS.&quot;</span>);</span><br><span class="line">                            sawInputEOS = <span class="keyword">true</span>;</span><br><span class="line">                            codec.queueInputBuffer(inputBufIndex, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, MediaCodec.BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            codec.queueInputBuffer(inputBufIndex, <span class="number">0</span>, sampleSize, extractor.getSampleTime(), <span class="number">0</span>);</span><br><span class="line">                            extractor.advance();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> outputBufferIndex = codec.dequeueOutputBuffer(info, kTimeOutUs);</span><br><span class="line">                <span class="keyword">if</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Simply ignore codec config buffers.</span></span><br><span class="line">                    <span class="keyword">if</span> ((info.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != <span class="number">0</span>) &#123;</span><br><span class="line">                        Log.i(TAG, <span class="string">&quot;audio encoder: codec config buffer&quot;</span>);</span><br><span class="line">                        codec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (info.size != <span class="number">0</span>) &#123;</span><br><span class="line">                        ByteBuffer outBuf = codecOutputBuffers[outputBufferIndex];</span><br><span class="line">                        outBuf.position(info.offset);</span><br><span class="line">                        outBuf.limit(info.offset + info.size);</span><br><span class="line">                        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[info.size];</span><br><span class="line">                        outBuf.get(data);</span><br><span class="line">                        fosDecoder.write(data);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    codec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> ((info.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>) &#123;</span><br><span class="line">                        Log.i(TAG, <span class="string">&quot;saw output EOS.&quot;</span>);</span><br><span class="line">                        sawOutputEOS = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">                    codecOutputBuffers = codec.getOutputBuffers();</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;output buffers have changed.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    MediaFormat oformat = codec.getOutputFormat();</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;output format has changed to &quot;</span> + oformat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;decodeAacToPcm finish&quot;</span>);</span><br><span class="line">            codec.stop();</span><br><span class="line">            codec.release();</span><br><span class="line">            extractor.release();</span><br><span class="line">            fosDecoder.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建编码器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MediaCodec <span class="title">createAudioEncoder</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        MediaCodec codec = MediaCodec.createEncoderByType(AUDIO_MIME);</span><br><span class="line">        MediaFormat format = <span class="keyword">new</span> MediaFormat();</span><br><span class="line">        format.setString(MediaFormat.KEY_MIME, AUDIO_MIME);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">64000</span>);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, <span class="number">1</span>);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_SAMPLE_RATE, <span class="number">44100</span>);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC);</span><br><span class="line">        codec.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">        <span class="keyword">return</span> codec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addADTStoPacket</span><span class="params">(<span class="keyword">byte</span>[] packet, <span class="keyword">int</span> packetLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">2</span>;  <span class="comment">//AAC LC</span></span><br><span class="line">        <span class="comment">//39=MediaCodecInfo.CodecProfileLevel.AACObjectELD;</span></span><br><span class="line">        <span class="keyword">int</span> freqIdx = <span class="number">4</span>;  <span class="comment">//44.1KHz</span></span><br><span class="line">        <span class="keyword">int</span> chanCfg = <span class="number">1</span>;  <span class="comment">//CPE</span></span><br><span class="line">        <span class="comment">// fill in ADTS data</span></span><br><span class="line">        packet[<span class="number">0</span>] = (<span class="keyword">byte</span>) <span class="number">0xFF</span>;</span><br><span class="line">        packet[<span class="number">1</span>] = (<span class="keyword">byte</span>) <span class="number">0xF9</span>;</span><br><span class="line">        packet[<span class="number">2</span>] = (<span class="keyword">byte</span>) (((profile - <span class="number">1</span>) &lt;&lt; <span class="number">6</span>) + (freqIdx &lt;&lt; <span class="number">2</span>) + (chanCfg &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        packet[<span class="number">3</span>] = (<span class="keyword">byte</span>) (((chanCfg &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span>) + (packetLen &gt;&gt; <span class="number">11</span>));</span><br><span class="line">        packet[<span class="number">4</span>] = (<span class="keyword">byte</span>) ((packetLen &amp; <span class="number">0x7FF</span>) &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        packet[<span class="number">5</span>] = (<span class="keyword">byte</span>) (((packetLen &amp; <span class="number">7</span>) &lt;&lt; <span class="number">5</span>) + <span class="number">0x1F</span>);</span><br><span class="line">        packet[<span class="number">6</span>] = (<span class="keyword">byte</span>) <span class="number">0xFC</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>具体源码详见 GitHub ：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidMultiMediaLearning">AndroidMultiMediaLearning</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="引用">          <a href="#引用" class="heading-link"><i class="fas fa-link"></i></a>引用</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://blog.51cto.com/ticktick/1760191">Android 音频开发（5）：音频数据的编解码 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>2、<span class="exturl"><a class="exturl__link" href="https://developer.android.com/reference/android/media/MediaCodec">Android 官方文档 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>3、<span class="exturl"><a class="exturl__link" href="https://juejin.im/entry/5aa234f751882555712bf210">安卓解码器 MediaCodec 解析 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频学习：使用 MediaExtractor 和 MediaMuxer 解析和封装 mp4 文件</title>
      <link href="2020/05/21/android-mediamuxer-and-mediaextractor/"/>
      <url>2020/05/21/android-mediamuxer-and-mediaextractor/</url>
      
        <content type="html"><![CDATA[<p>这篇文章的目的主要是学习 Android 平台的 MediaExtractor 和 MediaMuxer API，知道如何解析和封装 mp4 文件。</p><p>一个音视频文件是包含音频和视频，Android 中可以通过 MediaExtractor  API 把音频或视频给单独抽取出来，通过 MediaMuxer 合成新的视频。</p>        <h2 id="MediaExtractor">          <a href="#MediaExtractor" class="heading-link"><i class="fas fa-link"></i></a>MediaExtractor</h2>      <p>MediaExtractor 的作用就是将音频和视频分离。</p><p>主要是以下几个步骤：</p><p>1、创建实例</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaExtractor mediaExtractor = <span class="keyword">new</span> MediaExtractor();</span><br></pre></td></tr></table></div></figure><p>2、设置数据源</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaExtractor.setDataSource(path);</span><br></pre></td></tr></table></div></figure><p>3、获取数据源的轨道数，切换到想要的轨道</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轨道索引</span></span><br><span class="line"><span class="keyword">int</span> videoIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 视频轨道格式信息</span></span><br><span class="line">MediaFormat mediaFormat = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 数据源的轨道数</span></span><br><span class="line"><span class="keyword">int</span> trackCount = mediaExtractor.getTrackCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trackCount; i++) &#123;</span><br><span class="line">    MediaFormat format = mediaExtractor.getTrackFormat(i);</span><br><span class="line">    String mimeType = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">    <span class="keyword">if</span> (mimeType.startsWith(<span class="string">&quot;video/&quot;</span>)) &#123;</span><br><span class="line">        videoIndex = i;</span><br><span class="line">        mediaFormat = format;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切换到想要的轨道</span></span><br><span class="line">mediaExtractor.selectTrack(videoIndex);</span><br></pre></td></tr></table></div></figure><p>4、对所需轨道数据循环读取读取每帧，进行处理</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 将样本数据存储到字节缓存区</span></span><br><span class="line">    <span class="keyword">int</span> readSampleSize = mediaExtractor.readSampleData(byteBuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果没有可获取的样本，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (readSampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mediaExtractor.unselectTrack(videoIndex);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 读取下一帧数据</span></span><br><span class="line">    mediaExtractor.advance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>5、完成后释放资源</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaExtractor.release();</span><br></pre></td></tr></table></div></figure>        <h2 id="MediaMuxer">          <a href="#MediaMuxer" class="heading-link"><i class="fas fa-link"></i></a>MediaMuxer</h2>      <p>MediaMuxer 的作用是生成音频或视频文件；还可以把音频与视频混合成一个音视频文件。</p><p>主要是以下几个步骤：</p><p>1、创建实例</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaMuxermediaMuxer = <span class="keyword">new</span> MediaMuxer(path, format);</span><br></pre></td></tr></table></div></figure><p>path: 输出文件的名称；format: 输出文件的格式，当前只支持 MP4 格式。</p><p>2、将音频轨或视频轨添加到 MediaMuxer，返回新的轨道</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> trackIndex = mediaMuxer.addTrack(videoFormat);</span><br></pre></td></tr></table></div></figure><p>3、开始合成</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaMuxer.start();</span><br></pre></td></tr></table></div></figure><p>4、循环将音频轨或视频轨的数据写到文件</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 将样本数据存储到字节缓存区</span></span><br><span class="line">    <span class="keyword">int</span> readSampleSize = mediaExtractor.readSampleData(byteBuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果没有可获取的样本，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (readSampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mediaExtractor.unselectTrack(videoIndex);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bufferInfo.size = readSampleSize;</span><br><span class="line">    bufferInfo.flags = mediaExtractor.getSampleFlags();</span><br><span class="line">    bufferInfo.offset = <span class="number">0</span>;</span><br><span class="line">    bufferInfo.presentationTimeUs = mediaExtractor.getSampleTime();</span><br><span class="line">    mediaMuxer.writeSampleData(trackIndex, byteBuffer, bufferInfo);</span><br><span class="line">    <span class="comment">// 读取下一帧数据</span></span><br><span class="line">    mediaExtractor.advance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>5、完成后释放资源</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mediaMuxer.stop();</span><br><span class="line">mediaMuxer.release();</span><br></pre></td></tr></table></div></figure>        <h2 id="实例">          <a href="#实例" class="heading-link"><i class="fas fa-link"></i></a>实例</h2>      <p>从 MP4 文件中分离出视频生成无声视频文件。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分离视频的视频轨，输入视频 input.mp4，输出 output_video.mp4</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extractVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MediaExtractor mediaExtractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line">    MediaMuxer mediaMuxer = <span class="keyword">null</span>;</span><br><span class="line">    File fileDir = FileUtil.getExternalAssetsDir(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置视频源</span></span><br><span class="line">        mediaExtractor.setDataSource(<span class="keyword">new</span> File(fileDir, VIDEO_SOURCE).getAbsolutePath());</span><br><span class="line">        <span class="comment">// 轨道索引</span></span><br><span class="line">        <span class="keyword">int</span> videoIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 视频轨道格式信息</span></span><br><span class="line">        MediaFormat mediaFormat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 数据源的轨道数</span></span><br><span class="line">        <span class="keyword">int</span> trackCount = mediaExtractor.getTrackCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trackCount; i++) &#123;</span><br><span class="line">            MediaFormat format = mediaExtractor.getTrackFormat(i);</span><br><span class="line">            String mimeType = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">            <span class="keyword">if</span> (mimeType.startsWith(<span class="string">&quot;video/&quot;</span>)) &#123;</span><br><span class="line">                videoIndex = i;</span><br><span class="line">                mediaFormat = format;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切换到想要的轨道</span></span><br><span class="line">        mediaExtractor.selectTrack(videoIndex);</span><br><span class="line">        File outFile = <span class="keyword">new</span> File(FileUtil.getMuxerAndExtractorDir(<span class="keyword">this</span>), OUTPUT_VIDEO);</span><br><span class="line">        <span class="keyword">if</span> (outFile.exists()) &#123;</span><br><span class="line">            outFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        mediaMuxer = <span class="keyword">new</span> MediaMuxer(outFile.getAbsolutePath(), MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line">        <span class="comment">// 将视频轨添加到 MediaMuxer，返回新的轨道</span></span><br><span class="line">        <span class="keyword">int</span> trackIndex = mediaMuxer.addTrack(mediaFormat);</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(mediaFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE));</span><br><span class="line">        MediaCodec.BufferInfo bufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        mediaMuxer.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 将样本数据存储到字节缓存区</span></span><br><span class="line">            <span class="keyword">int</span> readSampleSize = mediaExtractor.readSampleData(byteBuffer, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果没有可获取的样本，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (readSampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mediaExtractor.unselectTrack(videoIndex);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bufferInfo.size = readSampleSize;</span><br><span class="line">            bufferInfo.flags = mediaExtractor.getSampleFlags();</span><br><span class="line">            bufferInfo.offset = <span class="number">0</span>;</span><br><span class="line">            bufferInfo.presentationTimeUs = mediaExtractor.getSampleTime();</span><br><span class="line">            mediaMuxer.writeSampleData(trackIndex, byteBuffer, bufferInfo);</span><br><span class="line">            <span class="comment">// 读取下一帧数据</span></span><br><span class="line">            mediaExtractor.advance();</span><br><span class="line">        &#125;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;分离视频完成&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaMuxer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mediaMuxer.stop();</span><br><span class="line">            mediaMuxer.release();</span><br><span class="line">        &#125;</span><br><span class="line">        mediaExtractor.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>分离音频、合成音视频的代码类似，详见 GitHub ：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidMultiMediaLearning">AndroidMultiMediaLearning</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/zhi184816/article/details/52514138">Android 视频分离和合成(MediaMuxer和MediaExtractor)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>2、<span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/renhui/p/7474096.html">Android 音视频开发(五)：使用 MediaExtractor 和 MediaMuxer API 解析和封装 mp4 文件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 8 期</title>
      <link href="2020/05/18/weekly-issue-8/"/>
      <url>2020/05/18/weekly-issue-8/</url>
      
        <content type="html"><![CDATA[<p>这里记录过去一周，我看到的值得分享的内容。</p><p>本周刊开源（GitHub: <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/weekly">weekly</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>），欢迎投稿，分享文章、资源、工具等。</p>        <h2 id="文章">          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://xie.infoq.cn/article/2f6a0bf7ba908d75219be726c">想退休，可能没机会了</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>别再想着三十五岁或四十五岁退休了。好好工作，好好生活，不辜负这样的时代。</p><p>2、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/E7NQW5OU15kwkUWUW0fAyw">您可坐稳了，海苔…其实是紫菜做出来的!</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>涨知识，有意思的公众号，推荐订阅。</p>        <h2 id="资源">          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://learngitbranching.js.org/">Learn Git Branching</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一个 Git 命令可视化学习项目。能够生动形象的帮助开发人员理解、学习 Git 命令，通过一系列刺激的关卡挑战，逐步深入的学习 Git 的强大功能。</p><p><img src="/2020/05/18/weekly-issue-8/learn_git.png" alt="learn_git"></p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/labuladong/fucking-algorithm">fucking-algorithm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>解 LeetCode 题目集合。号称“手撕 LeetCode 题目”，该项目旨在传递算法思维。</p>        <h2 id="工具">          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="http://www.wxmarkdown.com/">WXMarkdown</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>微信辅助工具，一个帮助你在微信公众号文章中插入不同社区、平台的小工具。</p><p><img src="/2020/05/18/weekly-issue-8/WXMarkdown.png" alt="WXMarkdown"></p><p>2、<span class="exturl"><a class="exturl__link" href="https://arcopypaste.app/">AR Copy Paste</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>可以将周围环境的元素剪下，然后粘贴到 Photoshop 中。</p><p>3、<span class="exturl"><a class="exturl__link" href="https://graph.readhub.cn/">泥石流海报</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>根据网址快速创建一张带二维码的海报图。</p><p><img src="/2020/05/18/weekly-issue-8/nishiliu.png" alt="nishiliu"></p>        <h2 id="图片">          <a href="#图片" class="heading-link"><i class="fas fa-link"></i></a>图片</h2>      <p>1、</p><p><img src="/2020/05/18/weekly-issue-8/wisdom.jpg" alt="wisdom"></p>        <h2 id="言论">          <a href="#言论" class="heading-link"><i class="fas fa-link"></i></a>言论</h2>      <p>1、</p><p>一旦你意识到精力有限，以下这些事情你就再也不会做了：为消费排队、拐弯抹角说话、单恋倒贴死缠难打、分析人际关系和对己看法、在网上跟陌生人吵架……年轻人才有资格挥霍精力，你是成年人了，你的精力要用来挣钱。</p><p>—- 反裤衩阵地</p>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 7 期</title>
      <link href="2020/05/08/weekly-issue-7/"/>
      <url>2020/05/08/weekly-issue-7/</url>
      
        <content type="html"><![CDATA[<p>这里记录过去一周，我看到的值得分享的内容。</p><p>本周刊开源（GitHub: <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/weekly">zywudev/weekly</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>），欢迎投稿，或者推荐好玩的东西。</p>        <h2 id="文章">          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/c_NOv87v6J9reByD6EQbrw">这一年团队的磨合与成长</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>作者讲述了自己在字节跳动组建团队过程中的一些故事和感悟。</p><p>“如果你喜欢一只蝴蝶，千万不要去追，因为你追不上她。你应该去种花、种草，等到春暖花开的时候，等到草长莺飞的时候，蝴蝶自然会飞回来。如果你喜欢的那只蝴蝶没有飞回来，怎么办呢? 你有了花，有了草，有了阳光，有了雨露，有了独特的魅力，那只蝴蝶没有飞回来，其他的蝴蝶会飞回来，比她更好的会飞回来，这就叫做花开蝶自来，爱情如此，生活如此，事业也如此。”</p><p>2、<span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5e93e305f265da48076dfce3">那些消失的安卓技术博主们</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>任何技术都有消失的时候，相聚离开总有时候，没有什么会永垂不朽。唯有经验与思维永存。</p><p>3、<span class="exturl"><a class="exturl__link" href="https://xie.infoq.cn/article/9d3aa424d319535f867c90dea">终端Terminal:程序员是如何查询天气预报的?</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>作者介绍了如何用终端命令查询天气，很酷。</p><p><img src="/2020/05/08/weekly-issue-7/weather.png" alt="weather"></p>        <h2 id="资源">          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>      <p>1、 <span class="exturl"><a class="exturl__link" href="https://leetcode.wang/">leetcode 前 300 题详细通俗的题解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>前 300 题每道都进行了详细通俗的分析，并且提供多种思路解法。</p><p>2、<span class="exturl"><a class="exturl__link" href="https://caicaishmily.gitbooks.io/pragmatic_programmer/">Pragmatic Programmer中译</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>译者历时两个月将 《Pragmatic Programmer》翻译成中文。</p>        <h2 id="工具">          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://www.npmjs.com/package/fy">Fanyi</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>命令行词典，无需打开词典应用。<img src="/2020/05/08/weekly-issue-7/fanyi.png" alt="fanyi"></p><p>2、<span class="exturl"><a class="exturl__link" href="https://www.deepl.com/home">DeepL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一款来自德国的“高质量”人工智能多国语言翻译工具 ，支持中文、英语、德语、法语、日语、西班牙语、意大利语、荷兰语及波兰语之间的全文翻译。</p><p><img src="/2020/05/08/weekly-issue-7/deepl.png" alt="deepl"></p><p>3、<span class="exturl"><a class="exturl__link" href="https://draw.io/">Draw.io</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>在线图表绘制应用，界面异常简洁高效。</p><p>流程图、结构图、网络拓扑图等各种类型的图表都能用它来画。</p><p><img src="/2020/05/08/weekly-issue-7/drawio.jpg" alt="drawio"></p>        <h2 id="图片">          <a href="#图片" class="heading-link"><i class="fas fa-link"></i></a>图片</h2>      <p>1、台上是生活，台下是希望</p><p> <img src="/2020/05/08/weekly-issue-7/life-hope.jpg" alt="life-hope"></p><p>2、陈皓发的<span class="exturl"><a class="exturl__link" href="https://twitter.com/haoel/status/1254974994964086785">推文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，从程序员职业发展的角度评论编程语言，有生命力、有市场需求的语言值得投入。</p><p><img src="/2020/05/08/weekly-issue-7/haochen1.png" alt="haochen1"></p><p><img src="/2020/05/08/weekly-issue-7/haochen2.png" alt="haochen2"></p>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频学习：使用 Camera API 采集视频数据</title>
      <link href="2020/04/30/Android-Camera/"/>
      <url>2020/04/30/Android-Camera/</url>
      
        <content type="html"><![CDATA[<p>这篇文章的主要学习内容是：使用 Camera API 采集视频数据并保存到文件，分别使用 SurfaceView、TextureView 来预览 Camera 数据，取到 NV21 的数据回调。</p><p>Android 中预览相机画面主要用 SurfaceView 和 TextureView。</p><p>SurfaceView：SurfaceView 是一个有自己 Surface 的 View。界面渲染可以放在单独线程而不是主线程中。它更像是一个 Window，自身不能做变形和动画。</p><p>TextureView：TextureView 同样也有自己的 Surface。但是它只能在拥有硬件加速层的 Window 中绘制，它更像是一个普通 View，可以做变形和动画。</p><p>更多关于 SurfaceView 和 TextureView 的知识可以看这篇文章 <span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/jinzhuojun/article/details/44062175">Android 5.0(Lollipop)中的SurfaceTexture，TextureView, SurfaceView和GLSurfaceView</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p>Android 5.0 之前系统提供了 Camera API ，5.0 之后提供了 Camera2 API。</p><p>不同手机厂商对 Camera2 的支持程度各不相同，即便是 Android 5.0 以上的手机，也存在对 Camera2 支持非常差的情况，这个时候就要降级使用 Camera。</p><p>官方的开源库 <span class="exturl"><a class="exturl__link" href="https://github.com/google/cameraview">cameraview </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>给出的方案：</p><div class="table-container"><table><thead><tr><th>API Level</th><th>Camera API</th><th>Preview View</th></tr></thead><tbody><tr><td>9-13</td><td>Camera1</td><td>SurfaceView</td></tr><tr><td>14-20</td><td>Camera1</td><td>TextureView</td></tr><tr><td>21-23</td><td>Camera2</td><td>TextureView</td></tr><tr><td>24</td><td>Camera2</td><td>SurfaceView</td></tr></tbody></table></div><p>接下来，我们使用 SurfaceView 和 TextureView 实现相机预览的功能。</p>        <h2 id="Camera">          <a href="#Camera" class="heading-link"><i class="fas fa-link"></i></a>Camera</h2>              <h3 id="使用-SurfaceView">          <a href="#使用-SurfaceView" class="heading-link"><i class="fas fa-link"></i></a>使用 SurfaceView</h3>      <p>SurfaceView 用于展示相机画面，SurfaceView 持有 SurfaceHolder，我们通过 SurfaceHolder 中的回调可以知道 Surface 的状态（创建、变化、销毁）。</p><p>继承 SurfaceView，实现 SurfaceHolder.CallBack 接口。在 <code>surfaceCreated</code> 方法中打开相机预览，在 <code>surfaceDestroyed</code> 方法中关闭相机预览就可以了。Camera 的 <code>open</code> 方法有些耗时，为了避免阻塞 UI 线程，可以创建子线程打开相机。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraSurfaceView</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraSurfaceView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraSurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraSurfaceView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        getHolder().addCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(<span class="keyword">final</span> SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadHelper.getInstance().runOnHandlerThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                openCamera();</span><br><span class="line">                startPreview(holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        ThreadHelper.getInstance().runOnHandlerThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                releaseCamera();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开相机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = Camera.getNumberOfCameras();</span><br><span class="line">        Camera.CameraInfo cameraInfo = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">            Camera.getCameraInfo(i, cameraInfo);</span><br><span class="line">            <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">                <span class="comment">// 打开后置摄像头</span></span><br><span class="line">                mCamera = Camera.open(i);</span><br><span class="line">                mCamera.setDisplayOrientation(<span class="number">90</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始预览</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> holder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCamera.setPreviewCallback(<span class="keyword">new</span> Camera.PreviewCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 取得 NV21 数据，进一步处理</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCamera.setPreviewDisplay(holder);</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭相机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCamera.stopPreview();</span><br><span class="line">                mCamera.setPreviewDisplay(<span class="keyword">null</span>);</span><br><span class="line">                mCamera.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mCamera = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="使用-TextureView">          <a href="#使用-TextureView" class="heading-link"><i class="fas fa-link"></i></a>使用 TextureView</h3>      <p>继承 TextureView，实现<code>TextureView.SurfaceTextureListener </code>。在 <code>onSurfaceTextureAvailable</code> 方法中打开相机预览，在<code>onSurfaceTextureDestroyed</code> 中关闭预览。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraTextureView</span> <span class="keyword">extends</span> <span class="title">TextureView</span> <span class="keyword">implements</span> <span class="title">TextureView</span>.<span class="title">SurfaceTextureListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraTextureView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraTextureView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraTextureView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setSurfaceTextureListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(<span class="keyword">final</span> SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        ThreadHelper.getInstance().runOnHandlerThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                openCamera();</span><br><span class="line">                startPreview(surface);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">        ThreadHelper.getInstance().runOnHandlerThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                releaseCamera();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开相机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = Camera.getNumberOfCameras();</span><br><span class="line">        Camera.CameraInfo cameraInfo = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">            Camera.getCameraInfo(i, cameraInfo);</span><br><span class="line">            <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">                <span class="comment">// 打开后置摄像头</span></span><br><span class="line">                mCamera = Camera.open(i);</span><br><span class="line">                mCamera.setDisplayOrientation(<span class="number">90</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始预览</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> texture</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">(SurfaceTexture texture)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCamera.setPreviewCallback(<span class="keyword">new</span> Camera.PreviewCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 取得 NV21 数据，进一步处理</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCamera.setPreviewTexture(texture);</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭相机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCamera.stopPreview();</span><br><span class="line">                mCamera.setPreviewDisplay(<span class="keyword">null</span>);</span><br><span class="line">                mCamera.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mCamera = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Camera2">          <a href="#Camera2" class="heading-link"><i class="fas fa-link"></i></a>Camera2</h2>              <h3 id="使用-SurfaceView-1">          <a href="#使用-SurfaceView-1" class="heading-link"><i class="fas fa-link"></i></a>使用 SurfaceView</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Camera2SurfaceView</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder mSurfaceHolder;</span><br><span class="line">    <span class="keyword">private</span> Handler mWorkHandler;</span><br><span class="line">    <span class="keyword">private</span> String mCameraId;</span><br><span class="line">    <span class="keyword">private</span> CameraDevice mCameraDevice;</span><br><span class="line">    <span class="keyword">private</span> ImageReader mImageReader;</span><br><span class="line">    <span class="keyword">private</span> CameraCaptureSession mCameraCaptureSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Camera2SurfaceView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Camera2SurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Camera2SurfaceView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        mSurfaceHolder = getHolder();</span><br><span class="line">        mSurfaceHolder.addCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;camera2&quot;</span>);</span><br><span class="line">        handlerThread.start();</span><br><span class="line">        mWorkHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</span><br><span class="line">        checkCamera();</span><br><span class="line">        openCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测相机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CameraManager cameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] cameraIdList = cameraManager.getCameraIdList();</span><br><span class="line">            <span class="keyword">for</span> (String s : cameraIdList) &#123;</span><br><span class="line">                CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(s);</span><br><span class="line">                Integer lensFacing = characteristics.get(CameraCharacteristics.LENS_FACING);</span><br><span class="line">                Integer sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">                Integer supportedHardwareLevel = characteristics.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);</span><br><span class="line">                <span class="keyword">if</span> (lensFacing != <span class="keyword">null</span> &amp;&amp; lensFacing == CameraCharacteristics.LENS_FACING_BACK) &#123;</span><br><span class="line">                    mCameraId = s;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开相机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCameraId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CameraManager cameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cameraManager.openCamera(mCameraId, <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(CameraDevice camera)</span> </span>&#123;</span><br><span class="line">                    mCameraDevice = camera;</span><br><span class="line">                    mImageReader = ImageReader.newInstance(getWidth(), getHeight(), ImageFormat.YUV_420_888, <span class="number">8</span>);</span><br><span class="line">                    mImageReader.setOnImageAvailableListener(<span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">                            Image image = reader.acquireLatestImage();</span><br><span class="line">                            <span class="comment">//我们可以将这帧数据转成字节数组，类似于Camera1的PreviewCallback回调的预览帧数据</span></span><br><span class="line">                            <span class="comment">//ByteBuffer buffer = image.getPlanes()[0].getBuffer();</span></span><br><span class="line">                            <span class="comment">//byte[] data = new byte[buffer.remaining()];</span></span><br><span class="line">                            <span class="comment">//buffer.get(data);</span></span><br><span class="line">                            image.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, mWorkHandler);</span><br><span class="line"></span><br><span class="line">                    createCameraPreview();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(CameraDevice camera)</span> </span>&#123;</span><br><span class="line">                    camera.close();</span><br><span class="line">                    mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(CameraDevice camera)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.onClosed(camera);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(CameraDevice camera, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">                    camera.close();</span><br><span class="line">                    mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, mWorkHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相机预览</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createCameraPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> CaptureRequest.Builder captureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">            Surface surface = mSurfaceHolder.getSurface();</span><br><span class="line">            captureRequestBuilder.addTarget(surface);</span><br><span class="line">            Surface imageReaderSurface = mImageReader.getSurface();</span><br><span class="line">            captureRequestBuilder.addTarget(imageReaderSurface);</span><br><span class="line">            captureRequestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);</span><br><span class="line">            mCameraDevice.createCaptureSession(Arrays.asList(surface, imageReaderSurface), <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                    mCameraCaptureSession = session;</span><br><span class="line">                    CaptureRequest captureRequest = captureRequestBuilder.build();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        session.setRepeatingRequest(captureRequest, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, mWorkHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        closeCameraPreview();</span><br><span class="line">        <span class="keyword">if</span> (mCameraDevice != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCameraDevice.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mImageReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mImageReader.close();</span><br><span class="line">        &#125;</span><br><span class="line">        mWorkHandler.getLooper().quitSafely();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeCameraPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCameraCaptureSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCameraCaptureSession.stopRepeating();</span><br><span class="line">                mCameraCaptureSession.abortCaptures();</span><br><span class="line">                mCameraCaptureSession.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            mCameraCaptureSession = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="使用-TextureView-1">          <a href="#使用-TextureView-1" class="heading-link"><i class="fas fa-link"></i></a>使用 TextureView</h3>      <p>TextureView 与 SurfaceView 类似，这里就不贴代码了。</p><p>具体源码放在 GitHub 上：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidMultiMediaLearning">AndroidMultiMediaLearning</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>以上只是 Camera 和 Camera2 的简单使用，更多细节可以查看官方 API。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5a33a5106fb9a04525782db5">Android平台Camera开发实践指南</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频学习：使用 AudioRecord 和 AudioTrack API 完成音频 PCM 数据的采集和播放，并实现 PCM 保存为 WAV 文件</title>
      <link href="2020/04/28/android-audiorecord-and-audiotrack/"/>
      <url>2020/04/28/android-audiorecord-and-audiotrack/</url>
      
        <content type="html"><![CDATA[<p>在具体使用 AudioRecord 采集音频之前，简单了解下 PCM。</p>        <h2 id="什么是-PCM">          <a href="#什么是-PCM" class="heading-link"><i class="fas fa-link"></i></a>什么是 PCM?</h2>      <p>我们知道，声音本身是模拟信号，而计算机只能处理离散的数字信号，要在计算机中处理声音，就需要将声音数字化，这个过程叫模数转换（A/D 变换） 。模数转换直接生成的二进制序列称为 PCM（pulse code modulation， 脉冲编码调制）数据。它是数字音频在计算机、光盘、数字电话和其他数字音频应用中的标准形式。</p><p>要将模拟信号转为 PCM 时，需要将声音量化，我们一般从如下几个维度描述一段声音：</p><p><strong>采样频率</strong>：每秒钟采集声音样本的次数，它用赫兹（Hz）来表示。</p><p>采样频率越高，声音的质量也就越好，声音的还原也就越真实，但同时它占的资源比较多。由于人耳的分辨率很有限，太高的频率并不能分辨出来。在 16 位声卡中有 22KHz、44KHz 等几级，,其中，22KHz 相当于普通 FM 广播的音质，44KHz 已相当于 CD 音质了，目前的常用采样频率都不超过 48KHz。</p><p><strong>采样位数</strong>：表示每次采样的精度，也可以说是声卡的分辨率。位数越多，能记录的范围就越大。</p><p><strong>声道数</strong>：很好理解，有单声道和立体声之分，单声道的声音只能使用一个喇叭发声（有的也处理成两个喇叭输出同一个声道的声音），立体声的 PCM 可以使两个喇叭都发声（一般左右声道有分工） ，更能感受到空间效果。 </p><p><strong>时长</strong>：采样的时长</p><p><img src="/2020/04/28/android-audiorecord-and-audiotrack/Pcm.svg"></p>        <h2 id="使用-AudioRecord-采集音频">          <a href="#使用-AudioRecord-采集音频" class="heading-link"><i class="fas fa-link"></i></a>使用 AudioRecord 采集音频</h2>      <p>AudioRecord 类是 Android 系统提供的用于实现录音的功能类。</p><p>开始录音的时候，AudioRecord 需要初始化一个相关联的声音 buffer, 这个 buffer 主要是用来保存新的声音数据。这个 buffer 的大小，我们可以在对象构造期间去指定。它表明一个 AudioRecord 对象还没有被读取（同步）声音数据前能录多长的音(即一次可以录制的声音容量)。声音数据从音频硬件中被读出，数据大小不超过整个录音数据的大小（可以分多次读出），即每次读取初始化 buffer 容量的数据。</p><p>使用 AudioRecord 采集音频的一般步骤：</p><ul><li><p>初始化一个音频缓存大小，该缓存大于等于 AudioRecord 对象用于写声音数据的缓存大小，最小录音缓存可以通过<code>AudioRecord#getMinBufferSize()</code> 方法得到。</p></li><li><p>构造一个 AudioRecord 对象，需要传入缓冲区大小，如果缓存容量过小，将导致对象构造的失败。</p></li><li><p>开始录音</p></li><li><p>创建一个数据流，一边从 AudioRecord 中读取声音数据到初始化的缓存，一边将缓存中数据导入数据流。</p></li><li><p>关闭数据流</p></li><li><p>停止录音</p></li></ul>        <h3 id="初始化缓存大小">          <a href="#初始化缓存大小" class="heading-link"><i class="fas fa-link"></i></a>初始化缓存大小</h3>      <p>可以通过 <code>AudioRecord#getMinBufferSize()</code> 方法得到最小录音缓存大小，传入的参数依次是采样频率、声道数和采样位数。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mBufferSizeInBytes;</span><br><span class="line">mBufferSizeInBytes = AudioRecord.getMinBufferSize(sampleRateInHz, channelConfig, audioFormat);</span><br></pre></td></tr></table></div></figure>        <h3 id="构造-AudioRecord-对象">          <a href="#构造-AudioRecord-对象" class="heading-link"><i class="fas fa-link"></i></a>构造 AudioRecord 对象</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AudioRecord mAudioRecord;</span><br><span class="line">mAudioRecord = <span class="keyword">new</span> AudioRecord(audioSource, sampleRateInHz, channelConfig, audioFormat, mBufferSizeInBytes);</span><br></pre></td></tr></table></div></figure>        <h3 id="初始化一个-buffer-数组">          <a href="#初始化一个-buffer-数组" class="heading-link"><i class="fas fa-link"></i></a>初始化一个 buffer 数组</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] audioData = <span class="keyword">new</span> <span class="keyword">byte</span>[mBufferSizeInBytes];</span><br></pre></td></tr></table></div></figure>        <h3 id="开始录音">          <a href="#开始录音" class="heading-link"><i class="fas fa-link"></i></a>开始录音</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAudioRecord.startRecording();</span><br></pre></td></tr></table></div></figure>        <h3 id="数据流读写">          <a href="#数据流读写" class="heading-link"><i class="fas fa-link"></i></a>数据流读写</h3>      <p>创建一个数据流，一边从 AudioRecord 中读取声音数据到初始化的 buffer，一边将 buffer 中数据导入数据流。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将音频信息写入文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeAudioDataToFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String pcmFilePath = FileUtil.getPcmFilePath(mContext, mPcmFileName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(pcmFilePath);</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    OutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        <span class="keyword">byte</span>[] audioData = <span class="keyword">new</span> <span class="keyword">byte</span>[mBufferSizeInBytes];</span><br><span class="line">        <span class="keyword">while</span> (mStatus == Status.STATUS_START) &#123;</span><br><span class="line">            <span class="keyword">int</span> readSize = mAudioRecord.read(audioData, <span class="number">0</span>, mBufferSizeInBytes);</span><br><span class="line">            <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.write(audioData, <span class="number">0</span>, readSize);</span><br><span class="line">                    <span class="keyword">if</span> (mRecordStreamListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mRecordStreamListener.onRecording(audioData, <span class="number">0</span>, readSize);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">&quot;writeAudioDataToFile&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;writeAudioDataToFile readSize: &quot;</span> + readSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bos.flush();</span><br><span class="line">        <span class="keyword">if</span> (mRecordStreamListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRecordStreamListener.finishRecord();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bos.close();<span class="comment">// 关闭写入流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="停止录音">          <a href="#停止录音" class="heading-link"><i class="fas fa-link"></i></a>停止录音</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != mAudioRecord) &#123;</span><br><span class="line">    mAudioRecord.stop();</span><br><span class="line">    mAudioRecord.release();</span><br><span class="line">    mAudioRecord = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="AudioRecord-和-MediaRecorder-的对比">          <a href="#AudioRecord-和-MediaRecorder-的对比" class="heading-link"><i class="fas fa-link"></i></a>AudioRecord 和 MediaRecorder 的对比</h2>      <p>Android SDK 提供了两套音频采集的 API，分别是：MediaRecorder 和 AudioRecord，前者是一个更加上层一点的API，它可以直接把手机麦克风录入的音频数据进行编码压缩（如 AMR、MP3 等）并存成文件，而后者则更接近底层，能够更加自由灵活地控制，可以得到原始的一帧帧 PCM 音频数据。</p><p>如果想简单地做一个录音机，录制成音频文件，则推荐使用 MediaRecorder，而如果需要对音频做进一步的算法处理、或者采用第三方的编码库进行压缩、以及网络传输等应用，则建议使用 AudioRecord，其实 MediaRecorder 底层也是调用了 AudioRecord 与 Android Framework 层的 AudioFlinger 进行交互的。直播中实时采集音频自然是要用 AudioRecord 了。</p>        <h2 id="使用-AudioTrack-播放-PCM-音频">          <a href="#使用-AudioTrack-播放-PCM-音频" class="heading-link"><i class="fas fa-link"></i></a>使用 AudioTrack 播放 PCM 音频</h2>      <p>AudioTrack 类可以完成 Android 平台 PCM 数据流的播放工作。AudioTrack 有两种数据加载模式：MODE_STREAM 和 MODE_STATIC， 对应着两种完全不同的使用场景。</p><p><strong>MODE_STREAM</strong>：在这种模式下，通过 write 一次次把音频数据写到 AudioTrack 中。这和平时通过 write 调用往文件中写数据类似，但这种方式每次都需要把数据从用户提供的 Buffer 中拷贝到 AudioTrack 内部的 Buffer 中，在一定程度上会引起延时。为解决这一问题，AudioTrack 就引入了第二种模式。</p><p><strong>MODE_STATIC</strong>：在这种模式下，只需要在 play 之前通过一次 write 调用，把所有数据传递到 AudioTrack 中的内部缓冲区，后续就不必再传递数据了。这种模式适用于像铃声这种内存占用较小、延时要求较高的文件。但它也有一个缺点，就是一次 write 的数据不能太多，否则系统无法分配足够的内存来存储全部数据。</p>        <h3 id="创建-AudioTrack-播放对象">          <a href="#创建-AudioTrack-播放对象" class="heading-link"><i class="fas fa-link"></i></a>创建 AudioTrack 播放对象</h3>      <p>参数与创建 AudioRecord 有相似之处。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> channelConfig = AudioFormat.CHANNEL_OUT_MONO;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> minBufferSize = AudioTrack.getMinBufferSize(AUDIO_SAMPLE_RATE_INHZ, channelConfig, AUDIO_ENCODING);</span><br><span class="line">mAudioTrack = <span class="keyword">new</span> AudioTrack(</span><br><span class="line">    <span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">    .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span><br><span class="line">    .build(),</span><br><span class="line">    <span class="keyword">new</span> AudioFormat.Builder()</span><br><span class="line">    .setSampleRate(AUDIO_SAMPLE_RATE_INHZ)</span><br><span class="line">    .setEncoding(AUDIO_ENCODING)</span><br><span class="line">    .setChannelMask(channelConfig)</span><br><span class="line">    .build(),</span><br><span class="line">    minBufferSize,</span><br><span class="line">    AudioTrack.MODE_STREAM,</span><br><span class="line">    AudioManager.AUDIO_SESSION_ID_GENERATE);</span><br></pre></td></tr></table></div></figure>        <h3 id="开始播放">          <a href="#开始播放" class="heading-link"><i class="fas fa-link"></i></a>开始播放</h3>              <h4 id="MODE-STREAM-模式">          <a href="#MODE-STREAM-模式" class="heading-link"><i class="fas fa-link"></i></a>MODE_STREAM 模式</h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">playAudioData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream dis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ThreadHelper.getInstance().runOnUiThread(() -&gt; &#123;</span><br><span class="line">            Toast.makeText(mContext, <span class="string">&quot;播放开始&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;);</span><br><span class="line">        dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(mFilePath)));</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[mBufferSizeInBytes];</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        mAudioTrack.play();</span><br><span class="line">        <span class="comment">// write 是阻塞的方法</span></span><br><span class="line">        <span class="keyword">while</span> ((length = dis.read(bytes)) != -<span class="number">1</span> &amp;&amp; mStatus == Status.STATUS_START) &#123;</span><br><span class="line">            mAudioTrack.write(bytes, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadHelper.getInstance().runOnUiThread(() -&gt; &#123;</span><br><span class="line">            Toast.makeText(mContext, <span class="string">&quot;播放结束&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="MODE-STATIC-模式">          <a href="#MODE-STATIC-模式" class="heading-link"><i class="fas fa-link"></i></a>MODE_STATIC 模式</h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream in = getResources().openRawResource(R.raw.ding);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b; (b = in.read()) != -<span class="number">1</span>; ) &#123;</span><br><span class="line">            out.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        mAudioData = out.toByteArray();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Failed to read&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mAudioTrack.write(mAudioData, <span class="number">0</span>, mAudioData.length);</span><br><span class="line">mAudioTrack.play();</span><br></pre></td></tr></table></div></figure>        <h3 id="停止播放">          <a href="#停止播放" class="heading-link"><i class="fas fa-link"></i></a>停止播放</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAudioTrack != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mAudioTrack.stop();</span><br><span class="line">    mAudioTrack.release();</span><br><span class="line">    mAudioTrack = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="AudioTrack-与-MediaPlayer-的对比">          <a href="#AudioTrack-与-MediaPlayer-的对比" class="heading-link"><i class="fas fa-link"></i></a>AudioTrack 与 MediaPlayer 的对比</h2>      <p>Android 中播放声音可以用 MediaPlayer 和 AudioTrack，两者都提供了 Java API 供应用开发者使用。</p><p>虽然都可以播放声音，但两者还是有很大的区别的。</p><p>其中最大的区别是 MediaPlayer 可以播放多种格式的声音文件，例如 MP3，AAC，WAV，OGG，MIDI 等。MediaPlayer 会在 framework 层创建对应的音频解码器，而 AudioTrack 只能播放已经解码的 PCM 流，如果对比支持的文件格式的话则是 AudioTrack 只支持 wav 格式的音频文件，因为 wav 格式的音频文件大部分都是 PCM流。AudioTrack 不创建解码器，所以只能播放不需要解码的 wav 文件。</p><p>MediaPlayer 在 framework 层还是会创建 AudioTrack，把解码后的 PCM 数流传递给 AudioTrack，AudioTrack再传递给 AudioFlinger 进行混音，然后才传递给硬件播放，所以是 MediaPlayer 包含了 AudioTrack。</p>        <h2 id="PCM-转-WAV">          <a href="#PCM-转-WAV" class="heading-link"><i class="fas fa-link"></i></a>PCM 转 WAV</h2>      <p>Waveform Audio File Format（WAVE，又或者是因为 WAV 后缀而被大众所知的），它采用 RIFF（Resource Interchange File Format）文件格式结构。通常用来保存 PCM 格式的原始音频数据，所以通常被称为无损音频。</p><p><strong>WAV 和 PCM 的关系</strong></p><p>PCM 数据本身只是一个裸码流，它是由声道、采样位数、采样频率、时长共同决定的，因此我们至少要知道其中的三个才能将 PCM 所代表的数据提取出来。</p><p>一种常见的方式是使用 WAV 格式定义的规范将 PCM 码流和描述信息封装起来。查看 PCM 和对应 WAV 文件的  hex 文件，可以发现，WAV 文件只是在 PCM 文件的开头多了 44bytes，来表征其声道数、采样频率和采样位数等信息。</p><p><img src="/2020/04/28/android-audiorecord-and-audiotrack/wav.gif"></p><p>PCM 转 WAV 的实现代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PcmToWavUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的音频大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mBufferSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采样率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSampleRate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声道数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mChannel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sampleRate sample rate、采样率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel    channel、声道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encoding   Audio data format、音频格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PcmToWavUtil</span><span class="params">(<span class="keyword">int</span> sampleRate, <span class="keyword">int</span> channel, <span class="keyword">int</span> encoding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mSampleRate = sampleRate;</span><br><span class="line">        <span class="keyword">this</span>.mChannel = channel;</span><br><span class="line">        <span class="keyword">this</span>.mBufferSize = AudioRecord.getMinBufferSize(mSampleRate, mChannel, encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pcm文件转wav文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inFilename  源文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outFilename 目标文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pcmToWav</span><span class="params">(String inFilename, String outFilename)</span> </span>&#123;</span><br><span class="line">        FileInputStream in;</span><br><span class="line">        FileOutputStream out;</span><br><span class="line">        <span class="keyword">long</span> totalAudioLen;</span><br><span class="line">        <span class="keyword">long</span> totalDataLen;</span><br><span class="line">        <span class="keyword">long</span> longSampleRate = mSampleRate;</span><br><span class="line">        <span class="keyword">int</span> channels = mChannel == AudioFormat.CHANNEL_IN_MONO ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> byteRate = <span class="number">16</span> * mSampleRate * channels / <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[mBufferSize];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(inFilename);</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(outFilename);</span><br><span class="line">            totalAudioLen = in.getChannel().size();</span><br><span class="line">            totalDataLen = totalAudioLen + <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line">            writeWaveFileHeader(out, totalAudioLen, totalDataLen,</span><br><span class="line">                    longSampleRate, channels, byteRate);</span><br><span class="line">            <span class="keyword">while</span> (in.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(data);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入wav文件头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeWaveFileHeader</span><span class="params">(FileOutputStream out, <span class="keyword">long</span> totalAudioLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> totalDataLen, <span class="keyword">long</span> longSampleRate, <span class="keyword">int</span> channels, <span class="keyword">long</span> byteRate)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">44</span>];</span><br><span class="line">        <span class="comment">// RIFF/WAVE header</span></span><br><span class="line">        header[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">        header[<span class="number">1</span>] = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">        header[<span class="number">2</span>] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">        header[<span class="number">3</span>] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">        header[<span class="number">4</span>] = (<span class="keyword">byte</span>) (totalDataLen &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">5</span>] = (<span class="keyword">byte</span>) ((totalDataLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">6</span>] = (<span class="keyword">byte</span>) ((totalDataLen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">7</span>] = (<span class="keyword">byte</span>) ((totalDataLen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">//WAVE</span></span><br><span class="line">        header[<span class="number">8</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">        header[<span class="number">9</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        header[<span class="number">10</span>] = <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">        header[<span class="number">11</span>] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">        <span class="comment">// &#x27;fmt &#x27; chunk</span></span><br><span class="line">        header[<span class="number">12</span>] = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">        header[<span class="number">13</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">        header[<span class="number">14</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">        header[<span class="number">15</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="comment">// 4 bytes: size of &#x27;fmt &#x27; chunk</span></span><br><span class="line">        header[<span class="number">16</span>] = <span class="number">16</span>;</span><br><span class="line">        header[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">18</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">19</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// format = 1</span></span><br><span class="line">        header[<span class="number">20</span>] = <span class="number">1</span>;</span><br><span class="line">        header[<span class="number">21</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">22</span>] = (<span class="keyword">byte</span>) channels;</span><br><span class="line">        header[<span class="number">23</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">24</span>] = (<span class="keyword">byte</span>) (longSampleRate &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">25</span>] = (<span class="keyword">byte</span>) ((longSampleRate &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">26</span>] = (<span class="keyword">byte</span>) ((longSampleRate &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">27</span>] = (<span class="keyword">byte</span>) ((longSampleRate &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">28</span>] = (<span class="keyword">byte</span>) (byteRate &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">29</span>] = (<span class="keyword">byte</span>) ((byteRate &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">30</span>] = (<span class="keyword">byte</span>) ((byteRate &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">31</span>] = (<span class="keyword">byte</span>) ((byteRate &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// block align</span></span><br><span class="line">        header[<span class="number">32</span>] = (<span class="keyword">byte</span>) (<span class="number">2</span> * <span class="number">16</span> / <span class="number">8</span>);</span><br><span class="line">        header[<span class="number">33</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// bits per sample</span></span><br><span class="line">        header[<span class="number">34</span>] = <span class="number">16</span>;</span><br><span class="line">        header[<span class="number">35</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//data</span></span><br><span class="line">        header[<span class="number">36</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">        header[<span class="number">37</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        header[<span class="number">38</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">        header[<span class="number">39</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        header[<span class="number">40</span>] = (<span class="keyword">byte</span>) (totalAudioLen &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">41</span>] = (<span class="keyword">byte</span>) ((totalAudioLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">42</span>] = (<span class="keyword">byte</span>) ((totalAudioLen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">43</span>] = (<span class="keyword">byte</span>) ((totalAudioLen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        out.write(header, <span class="number">0</span>, <span class="number">44</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>具体源码已经放在 GitHub：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidMultiMediaLearning">AndroidMultiMediaLearning</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="参考资料">          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>      <ul><li><p><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/TianFang/p/7894630.html">计算机音频基础-PCM简介</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5a9ec68c6fb9a028bf04d8fd">写给小白的音频认识基础</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="http://soundfile.sapp.org/doc/WaveFormat/">WAV 文件格式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员技术资源分享群</title>
      <link href="2020/04/24/programmer-group/"/>
      <url>2020/04/24/programmer-group/</url>
      
        <content type="html"><![CDATA[<p>独学而无友，则孤陋而寡闻。</p><p>我是个爱分享的程序员，遇上好的资源、工具软件都会主动分享给朋友。</p><p>好东西怎么能独享呢，分享给别人的同时，可能会收获更多。</p><p>所以，创建了一个<strong>技术资源分享群</strong>，欢迎爱分享的你加入进来。</p><p>本群主要是技术资源分享，包括：</p><ul><li><p>技术资源</p></li><li><p>工具软件</p></li><li><p>技术心得</p></li><li><p>技术热点</p></li></ul><p>为了让群价值最大化，交流更有效率：</p><ul><li><p>鼓励有价值的内容分享</p></li><li><p>鼓励友善、互相帮助、积极努力的氛围</p></li><li><p>不要只做伸手党</p></li><li><p>禁止低级趣味下流庸俗的内容</p></li><li><p>禁止讨论涉政敏感话题</p></li><li><p>禁止广告和商业推广</p></li></ul><p><strong>进群方式：</strong></p><p>为了群的质量，这里不贴群二维码了，想进的朋友加下我的微信，我拉你进群。（备注：技术群）</p><p>我的微信：<strong>wzy980691533</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频学习：使用三种不同的方式绘制图片</title>
      <link href="2020/04/24/Android-Draw-Image/"/>
      <url>2020/04/24/Android-Draw-Image/</url>
      
        <content type="html"><![CDATA[<p>本系列是个人 Android 音视频学习总结，这是第一篇，主要学习内容是：</p><p>在 Android 平台上绘制一张图片，使用三种不同的 API，ImageView、SurfaceView、自定义 View。</p>        <h2 id="ImageView-绘制图片">          <a href="#ImageView-绘制图片" class="heading-link"><i class="fas fa-link"></i></a>ImageView 绘制图片</h2>      <p>这种方式较为普遍简单。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImageView mImageView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">getContentView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mImageView = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> mImageView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getTitleResId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.string.image_view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initView();</span><br><span class="line">        <span class="comment">// 绘制图片</span></span><br><span class="line">        mImageView.setImageBitmap(FileUtil.getDrawImageBitmap(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="SurfaceView-绘制图片">          <a href="#SurfaceView-绘制图片" class="heading-link"><i class="fas fa-link"></i></a>SurfaceView 绘制图片</h2>      <p>SurfaceView 是 View 的一个子类，特点在于其实现了双缓冲技术，适用于频繁刷新页面的场景。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceViewActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SurfaceView mSurfaceView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getTitleResId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.string.surface_view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">getContentView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSurfaceView = <span class="keyword">new</span> SurfaceView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> mSurfaceView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initView();</span><br><span class="line">        mSurfaceView.getHolder().addCallback(<span class="keyword">new</span> SurfaceHolder.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">                paint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">                paint.setStyle(Paint.Style.STROKE);</span><br><span class="line"></span><br><span class="line">                Canvas canvas = holder.lockCanvas();</span><br><span class="line">                <span class="comment">// 绘制图片</span></span><br><span class="line">                canvas.drawBitmap(FileUtil.getDrawImageBitmap(SurfaceViewActivity.<span class="keyword">this</span>), <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line">                holder.unlockCanvasAndPost(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="自定义-View-绘制图片">          <a href="#自定义-View-绘制图片" class="heading-link"><i class="fas fa-link"></i></a>自定义 View 绘制图片</h2>      <p>还可以通过自定义 View 绘制图片。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="keyword">private</span> Bitmap mBitmap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">        mPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        mBitmap = FileUtil.getDrawImageBitmap(getContext());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="keyword">if</span> (mBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas.drawBitmap(mBitmap, <span class="number">0</span>, <span class="number">0</span>, mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>具体源码看这里：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidMultiMediaLearning">AndroidMultiMediaLearning</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，下一篇总结使用 AudioRecord 和 AudioTrack API 完成音频 PCM 数据的采集和播放，并实现读写音频 wav 文件。</p>]]></content>
      
      
      <categories>
          
          <category> Android 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让百度收录 GitHub Pages 个人博客</title>
      <link href="2020/03/04/let-baidu-index-github-pages/"/>
      <url>2020/03/04/let-baidu-index-github-pages/</url>
      
        <content type="html"><![CDATA[<p>很多程序员朋友都有在 GitHub Pages 上搭建自己的个人博客，对于个人博客，没有被搜索引擎收录的话，别人基本是是看不到的，再好的技术文无法被分享也是白搭。</p><p>基于 GitHub Pages 的个人博客， Google 收录非常及时全面。然而，到目前为止，GitHub 还是拒绝百度爬虫的访问，直接返回 403。</p><p>官方给出原因是，百度爬虫爬得太狠，影响了 Github Pages 服务的正常使用。这就导致了，但凡在 Github Pages 搭建的个人博客，都无法被百度收录。</p>        <h2 id="现有的解决办法">          <a href="#现有的解决办法" class="heading-link"><i class="fas fa-link"></i></a>现有的解决办法</h2>      <p>1、使用 coding.net 建立镜像网站</p><p>我之前使用过 coding.net，在本地 repo 的配置文件中同时添加 GitHub 和 coding.net 远程 repo 地址，发布时，两边都会部署到，加上域名智能解析，对于国内的请求，转发到 Coding Page 即可。</p><p>但是通过 coding.net 访问个人主页时会先出现跳转页面，导致百度无法正确爬取。</p><p>2、利用 CDN</p><p>这个没试过，理论上来说，百度在第一次爬取时，CDN 上必须要已经有相应页面的缓存，否则，爬取的请求会被转发到 GitHub 源站，GitHub 还是会拒绝。</p><p>3、使用 Nginx 反向代理</p><p>Nginx 做反向代理，直接代理百度爬虫，去 GitHub Pages 请求，然后将结果返回给百度爬虫。</p><p>这种方式可行，只不过，这些方法都需要一定的定制能力，对于个人开发者，还得买一台 VPS 或者云服务器。</p>        <h2 id="可靠、免费还简单的方法">          <a href="#可靠、免费还简单的方法" class="heading-link"><i class="fas fa-link"></i></a>可靠、免费还简单的方法</h2>      <p>Guillermo Rauch 大神创业搞了一个静态站 hosting 服务 <span class="exturl"><a class="exturl__link" href="https://zeit.co/">zeit.co</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，可以通过 GitHub Hooks 实现自动部署，zeit 提供 存储 + CDN  + DNS 一套完整的服务。</p><p>我给个人网站配置完成后，去百度站长试了一下，发现抓取成功了，sitemap 也提交成功了，坐等百度收录。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/1.png" alt="1"></p><p>下面我把配置的步骤记录下来，给有需要的朋友一个参考。</p><p>zeit 网站主要就三个步骤：</p><ul><li><p>Github 账户登陆 zeit.io，授予 zeit repo 的 read 权限；</p></li><li><p>导入 GitHub 博客 repo；</p></li></ul><p><img src="/2020/03/04/let-baidu-index-github-pages/2.png"></p><ul><li>稍等片刻，部署成功。</li></ul><p><img src="/2020/03/04/let-baidu-index-github-pages/3.png"></p><p>项目名中的 <code>.</code> 自动替换成 <code>-</code>，生成了一个类似于 <code>xxxx.now.sh</code> 的链接，点击可以访问你的博客主页，这时候静态资源已经部署到 zeit 的边缘 CDN 节点上了，下次你 GitHub 项目的任何更新会触发 zeit 项目更新。</p><p>接下来的就是切换域名，通过智能 DNS 将国内流量切过去。通过 zeit.io 提供的 DNS 解析服务配置自己的域名，然后在百度站长里配置信息。</p><p>在 Domains 下为项目添加你的个人域名。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/4.png"></p><p>我添加后出现以下配置错误，原因我的域名权威 dns 是 dnspod。</p><p>一种解决方式是将直接使用 zeit 提供的 nameserver 智能 DNS，另一种方式，就是保留 dnspod 作为权威 dns 服务器，但是要添加一条 ANAME 记录。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/5.png"></p><p><img src="/2020/03/04/let-baidu-index-github-pages/6.png"></p><p>有两张配置方式，一种是改 nameserver，我用的是这种，权威dns服务器改成左边那些，我看到你还是用的dnspod来解析的。另一种方式，就是保留dnspod作为权威dns服务器，但是要添加一条ANAME记录。</p><p>我使用的是第一种方式，直接在阿里云替换了 DNS 服务器，直接用 zeit 提供的 nameserver 智能 DNS。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/7.png"></p><p>回到 zeit，刷新下，正常是这样，这里是给你签发 https 证书，免费的。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/8-1.png"></p><p>过一会儿应该就好了。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/8-2.png"></p><p>看一下 DNS 解析地址，说明 zeit 域名已经配置成功了。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/9.png"></p><p>最后就是在百度站长里面添加个人域名了。这里注意选择 https 协议，因为 zeit 默认都是 https 了。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/10.png"></p><p>网站验证我采用的是文件验证，下载验证文件放在你博客本地 repo 的 source 目录下，部署到 GitHub，当然也会及时更新到 zeit。然后完成验证就好了，试一下链接诊断，看能不能正常抓取，失败的话，看看抓取的 ip 地址是不是还是之前的缓存，等待一段时间重新抓取下，时间取决于 dns 的 ttl。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/11.png"></p><p>从<span class="exturl"><a class="exturl__link" href="https://zeit.co/">zeit.co</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 官网上看，台湾和香港都有 CDN 节点，免费账户可以有 20G/月，个人博客应该是够用了。</p><p><img src="/2020/03/04/let-baidu-index-github-pages/12.png"></p><p>配置还是很简单的，赶紧试试吧，有问题欢迎交流。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit 源码分析</title>
      <link href="2020/01/15/retrofit-analysis/"/>
      <url>2020/01/15/retrofit-analysis/</url>
      
        <content type="html"><![CDATA[<p>前面的文章我们分析了 OkHttp 的核心源码，而 Retrofit 与 OkHttp 的结合使用，也是目前主流的方式，这篇文章主要分析下目前 Android 最优秀的网络封装框架 Retrofit。</p><p>在分析 Retrofit 源码之前，先看下 Retrofit 的简单使用。</p>        <h2 id="基本使用">          <a href="#基本使用" class="heading-link"><i class="fas fa-link"></i></a>基本使用</h2>      <p>一般情况，Retrofit 的使用流程按照以下三步：</p><p>1、将 HTTP API 定义成接口形式</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path(&quot;user&quot;)</span> String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>2、构建 Retrofit 实例，生成 GitHubService 接口的实现。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit 构建过程</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></div></figure><p>3、发起网络请求，可以做同步或异步请求。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">&quot;octocat&quot;</span>);</span><br><span class="line"></span><br><span class="line">call.execute() 或者 call.enqueue()</span><br></pre></td></tr></table></div></figure><p>这里，Retrofit 用注解标识不同的网络请求类型，极大的简化了 OkHttp 的使用方式。</p><p>这篇文章主要关注的几个问题：</p><ul><li><p>Retrofit 实例是如何创建的，它初始化了哪些东西？</p></li><li><p>GitHubService 实例是如何创建的，这些注解是如何映射到每种网络请求的 ？</p></li><li><p>网络请求的流程是怎样的？</p></li></ul>        <h2 id="Retrofit-创建过程">          <a href="#Retrofit-创建过程" class="heading-link"><i class="fas fa-link"></i></a>Retrofit 创建过程</h2>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></div></figure><p>这里可以看出，Retrofit 实例是使用建造者模式通过 Builder 类进行创建。</p><blockquote><p>建造者模式简言之：将一个复杂对象的构建与表示分离，使得用户在不知道对象的创建细节情况下可以直接创建复杂的对象。</p></blockquote>        <h3 id="Retrofit">          <a href="#Retrofit" class="heading-link"><i class="fas fa-link"></i></a>Retrofit</h3>      <p>Retrofit 包含 7 个成员变量：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 网络请求配置对象，存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 网络请求器的工厂：生产网络请求器</span></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 网络请求的 URL 地址</span></span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据转换器工厂的集合</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 网络请求适配器工厂的集合</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调方法执行器</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否缓存创建的 ServiceMethod</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>再看 Retrofit 构造函数，除了 serviceMethodCache, 其他成员变量都在这里进行赋值。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">         List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">         <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Retrofit-Builder">          <a href="#Retrofit-Builder" class="heading-link"><i class="fas fa-link"></i></a>Retrofit.Builder</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;     <span class="comment">// 平台</span></span><br><span class="line">   <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;      <span class="comment">// 网络请求工厂，默认使用OkHttpCall（工厂方法模式）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;  <span class="comment">// 网络请求URL地址</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">// 数据转换器工厂的集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 网络请求适配器工厂的集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;    <span class="comment">// 回调方法执行器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">   Builder(Platform platform) &#123;</span><br><span class="line">     <span class="keyword">this</span>.platform = platform;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(Platform.get());</span><br><span class="line">   &#125;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里主要关注 Platform，在 Builder 构造函数中调用了 <code>Platform.get()</code> ，然后赋值给自己的 platform 变量，我们来看看 Platform 类。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否是 Android 平台</span></span><br><span class="line">      Class.forName(<span class="string">&quot;android.os.Build&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Java 平台</span></span><br><span class="line">      Class.forName(<span class="string">&quot;java.util.Optional&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>Platform.get()</code> 方法会调用 <code>findPlatform()</code> 方法，这里主要是判断是 Android 平台还是 Java 平台，如果是 Android 平台会返回一个 Android 对象。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IgnoreJRERequirement</span> <span class="comment">// Guarded by API check.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">24</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.isDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">        <span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        DefaultCallAdapterFactory executorFactory = <span class="keyword">new</span> DefaultCallAdapterFactory(callbackExecutor);</span><br><span class="line">        <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span></span><br><span class="line">            ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)</span><br><span class="line">            : singletonList(executorFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">int</span> <span class="title">defaultCallAdapterFactoriesSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> List&lt;? extends Converter.Factory&gt; defaultConverterFactories() &#123;</span><br><span class="line">        <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span></span><br><span class="line">            ? singletonList(OptionalConverterFactory.INSTANCE)</span><br><span class="line">            : Collections.&lt;Converter.Factory&gt;emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">int</span> <span class="title">defaultConverterFactoriesSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>关注三个重要的方法：</p><ul><li><p><code>defaultCallbackExecutor</code>： 返回默认的 Executor 对象，正是 Retrofit 的成员变量回调执行器，它的内部采用 Handler 负责子线程到主线程的切换工作。</p></li><li><p><code>defaultCallAdapterFactories</code>：返回的是默认的 CallAdpter.Factory 的集合，也就是 Retrofit 的成员变量网络请求适配器工厂集合，如果是 Android 7.0 以上或者 Java 8，使用并发包中的 CompletableFuture 保证了回调的同步。</p></li><li><p><code>defaultConverterFactories</code>：返回的是默认的 Converter.Factory 的集合，也就是 Retrofit 的成员变量数据转换器工厂集合。</p></li></ul>        <h3 id="build-过程">          <a href="#build-过程" class="heading-link"><i class="fas fa-link"></i></a>build 过程</h3>      <p>接着看一下 <code>Builder.build()</code> 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认使用 OkHttp</span></span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认的 callbackExecutor</span></span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加你配置的 CallAdapter.Factory 到 List,然后把 Platform 默认的 defaultCallAdapterFactories 添加到 List</span></span><br><span class="line">    <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">    callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 BuiltInConverters 和手动配置的 Converter.Factory 到 List,然后把 Platform 默认的 defaultConverterFactories 添加到 List</span></span><br><span class="line">    <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">        <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">    <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">    converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">    converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">    converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个 Retrofit 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">                        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>至此，Retrofit 的创建流程就完成了，它的成员变量的值如下：</p><ul><li><p>serviceMethodService：暂时为空的 ConcurrentHashMap</p></li><li><p>callFactory：默认OkHttpClient 对象</p></li><li><p>baseUrl：根据配置的 baseUrl，构建 HttpUrl 对象</p></li><li><p>callAdapterFactories：配置的和默认的网络请求适配器工厂集合</p></li><li><p>converterFactories：配置的和默认的数据转换器工厂集合</p></li><li><p>callbackExecutor：MainThreadExecutor 对象</p></li><li><p>validateEagerly：默认 false</p></li></ul>        <h2 id="创建网络请求接口实例">          <a href="#创建网络请求接口实例" class="heading-link"><i class="fas fa-link"></i></a>创建网络请求接口实例</h2>      <p>接着来看 GitHubService 实例是如何创建的。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></div></figure>        <h3 id="Service-创建">          <a href="#Service-创建" class="heading-link"><i class="fas fa-link"></i></a>Service 创建</h3>      <p><code>retrofit.create()</code> 使用了外观模式和代理模式创建了网络请求接口实例。</p><blockquote><p>外观模式：定义一个统一接口，外部与通过该统一的接口对子系统里的其他接口进行访问。</p><p>代理模式：通过访问代理对象的方式来间接访问目标对象。</p></blockquote><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对参数 service 进行校验， service 必须是一个接口，而且没有继承别的接口</span></span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="comment">// 判断是否需要提前验证</span></span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用动态代理技术，自动生成 Service 接口的实现类，将 Service 接口方法中的参数交给 InvocationHandler 处理</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">                                      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                                          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">                                          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                                          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                                   <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                                              <span class="comment">// Object 类的方法直接调用</span></span><br><span class="line">                                              <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                                                  <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                                              &#125;</span><br><span class="line">                                              <span class="comment">// 如果是对应平台本身类就有的方法，直接调用</span></span><br><span class="line">                                              <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">                                                  <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">                                              &#125;</span><br><span class="line">                                              <span class="comment">// 否则通过 loadServiceMethod 方法获取到对应 ServiceMethod 并 invoke</span></span><br><span class="line">                                              <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">                                          &#125;</span><br><span class="line">                                      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>retrofit.create()</code> 返回的是代理对象 Proxy，并转换为 T 类型，即 GitHubService。这里利用了动态代理技术，自动生成 Service 接口的实现类，将 Service 接口方法中的参数交给 InvocationHandler 处理。</p><p>对于 Object 类本身独有以及对应平台本身存在的方法，就直接调用，否则通过 <code>loadServiceMethod()</code> 对 Service  接口中对应的 method 进行解析处理，之后对其调用 <code>invoke()</code> 方法。</p><p>可以看出，Retrofit 不是在创建 Service 接口实例时就立即对所有接口中的方法进行注解解析，而是采用了在方法被调用时才进行注解的解析，也就是懒加载。</p>        <h3 id="validateEagerly-的作用">          <a href="#validateEagerly-的作用" class="heading-link"><i class="fas fa-link"></i></a>validateEagerly 的作用</h3>      <p>我们看看 validateEagerly 这个变量，看看它控制着什么。validateEagerly 为 true 会进入 <code>eagerlyValidateMethods()</code> 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eagerlyValidateMethods</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</span><br><span class="line">    Platform platform = Platform.get();</span><br><span class="line">    <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">            loadServiceMethod(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里循环取出接口中的 Method，调用 <code>loadServiceMethod() </code>，  <code>loadServiceMethod() </code> 先从 serviceMethodCache 获取 Method 对应的 ServiceMethod，如果有直接返回，否则对 Method 进行解析得到一个 ServiceMethod 对象，存入缓存中。</p><p>所以 validateEagerly 变量是用于判断是否需要提前验证解析的，默认为 false，如果在 Retrofit 创建时设置为 true，会对 Service 接口中所有方法进行提前解析处理。</p>        <h3 id="ServiceMethod-创建过程">          <a href="#ServiceMethod-创建过程" class="heading-link"><i class="fas fa-link"></i></a>ServiceMethod 创建过程</h3>      <p><code>loadServiceMethod()</code> 方法的具体实现如下，这里采用了 Double Check 的方式尝试从 serviceMethodCache 中获取 ServiceMethod 对象，如果获取不到则通过 <code>ServiceMethod.parseAnnotations()</code> 方法对该 method 的注解进行处理并将得到的 ServiceMethod 对象加入缓存。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">// 1. 先从缓存中获取，如果有则直接返回</span></span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">        <span class="comment">// 2. 这里又获取一次，原因是网络请求一般是多线程环境下，ServiceMethod 可能创建完成了</span></span><br><span class="line">        result = serviceMethodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 解析方法注解，创建 ServiceMethod</span></span><br><span class="line">            result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">            <span class="comment">// 存入缓存</span></span><br><span class="line">            serviceMethodCache.put(method, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们详细看一下 ServiceMethod 创建过程。 <code>ServiceMethod.parseAnnotations()</code> 方法具体实现：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 RequestFactory 解析注解配置（工厂模式、内部使用了建造者模式）</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                          <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HttpServiceMethod 解析注解的方法</span></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>1、通过 RequestFactory 解析注解配置</strong></p><p>通过工厂模式和建造者模式创建 RequestFactory，解析封装注解配置。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="comment">// 获取网络请求接口方法里的注解</span></span><br><span class="line">    <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">    <span class="comment">// 获取网络请求接口方法里的参数类型</span></span><br><span class="line">    <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="comment">// 获取网络请求接口方法里的注解内容</span></span><br><span class="line">    <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>2、ServiceMethod 的创建</strong></p><p>ServiceMethod 的创建在 HttpServiceMethod 的 <code>parseAnnotations()</code> 方法中。 </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    Type adapterType;</span><br><span class="line">    <span class="comment">// 如果方法是 kotlin 中的 suspend 方法</span></span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">        <span class="comment">// 获取 Continuation 的范型参数，它就是 suspend 方法的返回值类型</span></span><br><span class="line">        Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        Type responseType = Utils.getParameterLowerBound(<span class="number">0</span>,</span><br><span class="line">                                                         (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果 Continuation 的范型参数是 Response，则说明它需要的是 Response，那么将 continuationWantsResponse 置为 true;</span></span><br><span class="line">        <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">            responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">            continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// TODO figure out if type is nullable or not</span></span><br><span class="line">            <span class="comment">// Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)</span></span><br><span class="line">            <span class="comment">// Find the entry for method</span></span><br><span class="line">            <span class="comment">// Determine if return type is nullable or not</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">        annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则获取方法返回值的范型参数，即为请求需要的返回值的类型</span></span><br><span class="line">        adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据网络请求接口方法的返回值和注解类型</span></span><br><span class="line">    <span class="comment">// 从 Retrofit 对象中获取对于的网络请求适配器</span></span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到响应类型</span></span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    <span class="keyword">if</span> (responseType == okhttp3.Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">                          + getRawType(responseType).getName()</span><br><span class="line">                          + <span class="string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseType == Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO support Unit for Kotlin?</span></span><br><span class="line">    <span class="keyword">if</span> (requestFactory.httpMethod.equals(<span class="string">&quot;HEAD&quot;</span>) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">&quot;HEAD method must use Void as response type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据网络请求接口方法的返回值和注解类型从Retrofit对象中获取对应的数据转换器</span></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">        <span class="comment">// 不是 suspend 方法的话则直接创建并返回一个 CallAdapted 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForResponse&lt;&gt;(requestFactory,</span><br><span class="line">                                                                                callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">                                                                            callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">                                                                            continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>HttpServiceMethod.parseAnnotations()</code> 的主要作用就是获取 CallAdapter 以及 Converter 对象，并构建对应 <code>HttpServiceMethod</code>。</p><ul><li>CallAdapter ：根据网络接口方法的返回值类型来选择具体要用哪种 CallAdapterFactory，然后获取具体的 CallAdapter。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(method, e, <span class="string">&quot;Unable to create call adapter for %s&quot;</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">                                         Annotation[] annotations) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 CallAdapter.Factory 集合寻找合适的工厂(该工厂集合在第一步构造 Retrofit 对象时进行添加)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>获取 Converter：根据网络请求接口方法的返回值和注解类型从 Retrofit 对象中获取对应的数据转换器，和创建 CallAdapter 基本一致，遍历 Converter.Factory 集合并寻找具体的 Converter。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(method, e, <span class="string">&quot;Unable to create converter for %s&quot;</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>构建 HttpServiceMethod：根据是否是 kotlin suspend 方法分别返回不同类型的 HttpServiceMethod。如果不是 suspend 方法的话则直接创建并返回一个 CallAdapted 对象，否则根据 suspend 方法需要的是 Response 还是具体的类型，分别返回 SuspendForResponse 和 SuspendForBody 对象。</li></ul>        <h3 id="ServiceMethod-invoke">          <a href="#ServiceMethod-invoke" class="heading-link"><i class="fas fa-link"></i></a>ServiceMethod.invoke()</h3>      <p>ServiceMethod 是一个抽象类，<code>invoke()</code> 是一个抽象方法，具体实现在子类中。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>它的子类是 HttpServiceMethod，HttpServiceMethod 的 <code>invoke()</code> 方法中，首先构造一个 OkHttpCall，然后通过 <code>adapt()</code> 方法实现对 Call 的转换。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">        <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>adapt()</code> 是一个 抽象方法，所以具体实现在 HttpServiceMethod 的子类中。</p><p>HttpServiceMethod 有三个子类，非协程的情况是 CallAdapted，另外两个子类则是在使用协程的情况下为了配合协程的 SuspendForResponse 以及 SuspendForBody 类。</p><ul><li><p>CallAdapted：通过传递进来的 CallAdapter 对 Call 进行转换。</p></li><li><p>SuspendForResponse：首先根据传递进来的 Call 构造了一个参数为 Response 的 Continuation 对象然后通过 Kotlin 实现的 <code>awaitResponse()</code> 方法将 call 的 <code>enqueue</code> 异步回调过程封装成 一个 suspend 的函数。</p></li><li><p>SuspendForBody：SuspendForBody 则是根据传递进来的 Call 构造了一个 Continuation 对象然后通过 Kotlin 实现的 <code>await()</code> 或 <code>awaitNullable()</code> 方法将 call 的 <code>enqueue</code> 异步回调过程封装为了一个 suspend 的函数。</p></li></ul>        <h2 id="发起网络请求">          <a href="#发起网络请求" class="heading-link"><i class="fas fa-link"></i></a>发起网络请求</h2>              <h3 id="创建-Call">          <a href="#创建-Call" class="heading-link"><i class="fas fa-link"></i></a>创建 Call</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">&quot;octocat&quot;</span>);</span><br></pre></td></tr></table></div></figure><p>从前面的分析了解到，Service 对象是动态代理对象，当调用 <code>listRepos()</code> 方法时会调用到 InvocationHandler的 <code>invoke()</code> 方法，得到最终的 Call 对象。</p><p>如果没有传入 CallAdapter 的话，默认情况返回的 Call 是 OkHttpCall 对象，它实现了 Call 接口。</p>        <h3 id="同步请求">          <a href="#同步请求" class="heading-link"><i class="fas fa-link"></i></a>同步请求</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        call = rawCall;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 创建 OkHttp 的 Call 对象</span></span><br><span class="line">                call = rawCall = createRawCall();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">                throwIfFatal(e); <span class="comment">//  Do not assign a fatal error to creationFailure.</span></span><br><span class="line">                creationFailure = e;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行请求并解析返回结果</span></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>很简单，主要就是创建 OkHttp 的 Call 对象，调用 Call 的 <code>execute</code> 方法，对 Response 进行解析返回。</p>        <h3 id="异步请求">          <a href="#异步请求" class="heading-link"><i class="fas fa-link"></i></a>异步请求</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    checkNotNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        call = rawCall;</span><br><span class="line">        failure = creationFailure;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 创建 OkHttp 的 Call 对象</span></span><br><span class="line">                call = rawCall = createRawCall();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                throwIfFatal(t);</span><br><span class="line">                failure = creationFailure = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.onFailure(<span class="keyword">this</span>, failure);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用 Call 的异步执行方法</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">            Response&lt;T&gt; response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 解析返回结果</span></span><br><span class="line">                response = parseResponse(rawResponse);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                throwIfFatal(e);</span><br><span class="line">                callFailure(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 执行回调</span></span><br><span class="line">                callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                throwIfFatal(t);</span><br><span class="line">                t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                throwIfFatal(t);</span><br><span class="line">                t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>也很简单，主要就是创建 OkHttp 的 Call 对象，调用 Call 的 <code>enqueue</code> 方法，解析返回结果，执行回调。</p>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <p>至此，Retrofit 的源码基本上就看完了，虽然还有很多细节没有提及，但 Retrofit 的整体流程很清晰了。</p><p>Retrofit 本质上是一个 RESTful 的 Http 网络请求框架的封装，通过大量的设计模式封装了 OkHttp，使得更加简单易用。它内部主要是用动态代理的方式，动态将网络请求接口的注解解析成 HTTP 请求，最后执行请求的过程。</p><p>建议将 Retrofit 的源码下载下来，使用 IDEA 可以直接打开阅读。我这边已经将源码下载下来，进行了注释说明，有需要的可以直接从 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/android-open-framework-analysis">Android open framework analysis</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 查看。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://github.com/sucese/android-open-framework-analysis/blob/master/doc/Android%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E9%89%B4%E8%B5%8F%EF%BC%9ARetrofit.md">Android开源框架源码鉴赏：Retrofit</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>2、<span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/0c055ad46b6c">Android：手把手带你 深入读懂 Retrofit 2.0 源码</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>3、<span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/101508725">带你一步步剖析Retrofit 源码解析：一款基于 OkHttp 实现的网络请求框架</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 2019 年个人总结</title>
      <link href="2020/01/07/my-2019/"/>
      <url>2020/01/07/my-2019/</url>
      
        <content type="html"><![CDATA[<p>虽然 2020 年已经过去一周时间，但还是想记录一下我的 2019 年个人总结，复盘一下自己过去一年的工作、学习和生活状况。</p><p><strong>工作方面</strong>。</p><p>年初面了几家心仪的公司，但没有得到想要的结果，认识到自身实力一般，而且外界的环境也不是很好，也就还在现在的公司继续干着。</p><p>2018 年部门效益很差，那年年底还裁掉了一些同事。为了生存下来，2019 年整个团队像是在打一场战役，这一年大家都挺忙的，忙碌的时候加班比较严重，所幸团队成员的积极性还算高。</p><p>虽然如王兴说的 「2019 可能会是过去 10 年最差的一年，但却是未来 10 年最好的一年」，但庆幸的是 2019 年部门的业绩应该是超额完成了，这里面有每一个员工的付出和努力。</p><p>毕竟只有企业活得好，员工才能得到应得的回报。企业的成败，每一个员工都有责任，在一个企业里，应该尽职尽责做好自己的工作。</p><p>2020 年，不管自己在哪个企业，都希望自己保持主动、积极、尽职尽责。</p><p><strong>技术学习方面</strong>。</p><p>主要涉及了 Android 音视频知识， Android 性能优化，Android 源码分析以及 Android 面试系列等等。</p><p>其实对这一年的技术成长不是很满意。很多东西从一开始没有做好计划，导致学习的深度和效率不高，技术提升也并不显著。</p><p>所以最近几天，我会好好思考下，今年的技术学习路线到底是什么，做一份详尽的学习计划。</p><p>这一年在个人博客、公众号以及知乎等平台写了几十篇文章，数量还是太少了。</p><p>在互联网平台，做消费者的同时做一个生产者，比只做消费者的收获要大很多。因此我也通过写文章的方式分享一些自己的技术总结、个人见识、生活经验等等，也有帮助到一些朋友，解决了他们的问题，这是一件很棒的事情。只要能帮助到一个朋友，就说明了我的文章是有价值的。</p><p>2020 年我也会争取多多分享，目前确定的会长期持续更新的有 Android 面试系列文章和每周分享周刊。</p><p>技术之外，这一年主要是在微信阅读上面读书，大概读了三十几本书。相比比从前不看书的我，这个提升还是很大的。2020 年，继续保持。</p><p><strong>生活方面</strong>。</p><p>这一年可能是这一生极为重要的一个年份了。因为今年完成了结婚、生娃两件大事。和妻子结束了 9 年的恋爱马拉松，步入婚姻的殿堂，2019 年 12 月 27 日，喜提佩奇，平安喜乐，辛苦妻子。</p><p>这一年，身份角色的转变，伴随而来的是爱与责任。2020 年，多一点时间陪伴亲人。</p><p>以上，算是 2019 年的一点总结。</p><p>其实一年的时间非常快。如果没有目标，没有预先做好计划，按计划执行，一年的时间很容易被荒废，到年底会发现这一年啥事没做成。</p><p>2020 年，有一些目标和想法，没必要轻易说出来，关键还是看行动吧。</p><p>2019 年，感谢大家的关注，2020 年祝福每一位朋友，万事顺意，平安健康。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 6 期</title>
      <link href="2019/12/15/weekly-issue-6/"/>
      <url>2019/12/15/weekly-issue-6/</url>
      
        <content type="html"><![CDATA[<p>这里记录过去一周，我看到的值得分享的内容。</p><p>本周刊开源（GitHub: <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/weekly">zywudev/weekly</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>），欢迎投稿，或者推荐好玩的东西。</p><p><img src="/2019/12/15/weekly-issue-6/titu.jpg" alt="titu"></p><p>(题图：<span class="exturl"><a class="exturl__link" href="https://unsplash.com/@paysonwick">Payson Wick</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>)</p>        <h2 id="资源">          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://pythonguidecn.readthedocs.io/zh/latest/">Python最佳实践指南</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>《Python 开发最佳实践指南》，中文版开源电子书，翻译自英语原版。 </p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/microsoft/api-guidelines/blob/master/Guidelines.md">微软 REST API 设计指南</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>微软官方出品的 REST API 指导规范。</p><p>3、<span class="exturl"><a class="exturl__link" href="https://github.com/andrews1022/web-development-2020-course-list">Web 开发者 2020 年学习指南</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>GitHub 上有一位开发者根据 Udemy 的热门课程，整理了一份 Web 开发者 2020 年学习指南。其中包含常用的 Web 开发工具、设计软件、主流框架、基础知识、后端 &amp; DevOps 技术堆栈等分类。</p>        <h2 id="工具">          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://cs.android.com/">Code Search</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>Android 官方最近为  AOSP 引入了代码搜索工具。</p><p>体验了下，挺好用的，可以在任意开源分支上切换，还支持交叉引用查找，感觉可以替代掉第三方的网站了。</p><p><img src="/2019/12/15/weekly-issue-6/aosp.png"></p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/a312863063/seeprettyface-generator-wanghong">网红脸生成器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一个网红脸生成器项目（非真实人脸）这是一个用 StyleGAN 训练出的网红脸生成器。</p><p>作者还开源了其他几个人脸生成器。</p><p><img src="/2019/12/15/weekly-issue-6/64_examples.jpg" alt="64_examples"></p><p>3、<span class="exturl"><a class="exturl__link" href="https://github.com/bytefury/crater">Crater</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一款免费开源的 Web 与移动端发票应用：Crater。</p><p>可跟踪记录日常费用支出情况，并生成专业发票与消费报告。界面设计清新而简洁，适用于自由职业者或小型企业。</p>        <h2 id="文摘">          <a href="#文摘" class="heading-link"><i class="fas fa-link"></i></a>文摘</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="http://www.readers365.com/baihuajiang/mydoc013.htm">《孩子王》阿城</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>我的父亲是世界中力气最大的人。他在队里扛麻袋，别人都比不过他。我的父亲又是世界中吃饭最多的人。家里的饭，都是母亲让他吃饱。这很对，因为父亲要做工，每月拿钱来养活一家人。但是父亲说：“我没有王福力气大。因为王福在识字。”父亲是一个不能讲话的人，但我懂他的意思。队上有人欺负他，我明白。所以我要好好学文化，替他说话。父亲很辛苦，今天他病了，后来慢慢爬起来，还要去干活，不愿失去一天的钱。我要上学，现在还替不了他。早上出的白太阳，父亲在山上走，走进白太阳里去。我想，父亲有力气啦。</p>        <h2 id="言论">          <a href="#言论" class="heading-link"><i class="fas fa-link"></i></a>言论</h2>      <p>1、</p><p>最后十年</p><p>在我 20 来岁的时候，我觉得青春只剩最后十年了 </p><p>在我 30 来岁的时候，我觉得职场只剩最后十年了 </p><p>在我 40 来岁的时候，我觉得人生只剩最后十年了 </p><p>在我 50 来岁的时候，我觉得精力只剩最后十年了 </p><p>在我 60 来岁的时候，我觉得生命只剩最后十年了 </p><p>是的，我们人生只有最后十年…… </p><p>—— hao chen</p><p>2、</p><p>我们的人生是由命运和因果报应两条法则互相交织而成的。这两者互相干涉，比如当命运非常恶劣时，做一点好事，并不会出现好的结果，因为仅有的一点善行为强势的厄运所淹没。同样，当好运非常旺盛时，稍稍做点坏事，也不会马上出现恶因招恶果的情形。 </p><p>– 稻盛和夫</p><p>3、</p><p>任何傻瓜都能写计算机能理解的代码，优秀的程序员编写人类能够理解的代码</p><p>– Martin Fowler</p>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 5 期</title>
      <link href="2019/12/08/weekly-issue-5/"/>
      <url>2019/12/08/weekly-issue-5/</url>
      
        <content type="html"><![CDATA[<p>这里记录过去一周，我看到的值得分享的内容。</p><p><img src="/2019/12/08/weekly-issue-5/titu.jpg" alt="titu"></p><p>（题图：<span class="exturl"><a class="exturl__link" href="https://unsplash.com/@zuizuii">Duy Hoang</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）</p>        <h2 id="文章">          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/UaN3WphW0W6sn47L65f8MQ">兽爷丨大象踩了他一脚</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>大公司欺负员工真的是轻而易举，就像大象踩蚂蚁一样。</p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/evil-huawei/evil-huawei">华为做过的恶</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>收集华为作过的恶，记录这些不应该被遗忘的历史。</p>        <h2 id="工具">          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://www.snipaste.com/">Snipaste</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p>Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！下载并打开 Snipaste，按下 F1 来开始截图，再按 F3，截图就在桌面置顶显示了。就这么简单！</p>        <h2 id="资源">          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">Best-websites-a-programmer-should-visit</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>学习计算机软件，一些很有用的网站。</p>        <h2 id="言论">          <a href="#言论" class="heading-link"><i class="fas fa-link"></i></a>言论</h2>      <p>1、</p><p>原中央网信办副主任彭波对华为事件的评论</p><ul><li><p>水可以载舟，也可以覆舟。舆论可以把你追捧成“民族英雄”，也可以把你踩在脚下，而且很可能是同一批人。 应该看到“捧”你和“踩”你，都是“爱”你——踩你时，绝大部分网友是希望你更好，希望一个伟大的公司更加伟大，一个心目中偶像级的企业更加完美。 要善待这种爱心。 网上最恐怖的情形，不是沸反盈天、骂声一片，而是鸦雀无声、万马齐喑。</p></li><li><p>此事标志着在新的社会主要矛盾背景下，人们对于公平正义的追求更加强烈。人们用更加严苛的眼光看待企业，看待社会，涉及“公平正义”的问题，往往触动全社会最敏感的神经。</p></li><li><p>不管是谁，永远要敬畏互联网，敬畏网民，敬畏舆论；不管是多大的企业，千万不要傲慢，不要任性。 </p></li><li><p>千万不要把事情随便上纲上线，不要把一般的舆情事件政治化，尽管可能有“境内外阶级敌人”的破坏。 </p></li><li><p>网上舆论的治理如同治水，正确的方法是疏堵结合，以疏为主。有时候处理不当带来的次生舆情，危害大于原始舆情。 </p></li><li><p>同情“弱者”，不符合法治精神，“强者”也有合法的权益，真理不一定掌握在“弱者”手上，但同情“弱者”符合舆情规律。 </p></li><li><p>机构（包括政府机关和企业）处理事情的思维逻辑是“法理情”，先考虑是否合法，再考虑是否有理，最后考虑民众情感上能否接受；而民众处理事情的逻辑是“情理法”，先考虑感情上能否接受。 </p></li><li><p>重大舆情，要由公司公共关系部门统筹处理，实务部门和法务部门在需要时才出现；实务部门和法务部门不能主导舆情处置。 </p></li><li><p>永远留有后手，不要轻易把自己置于悬崖边上。 只有公开透明，才能赢得公平公正。世界上没有不明真相的群众，只有掌握真相又没有说明真相的机构。在一片谴责之声出现时，机构仍不说明真相，这里一定有“难言之隐”，大家要有耐心，让子弹再飞一会儿。拒绝恶意猜测，拒绝恶意炒作。</p></li></ul><p>2、</p><p>拉里佩奇的管理法则</p><ul><li><p>不要推诿：自己去做任何能让产品研发进展更快的事情。</p></li><li><p>如果你不能为产品增值，那么你就不要成为碍事的人。让那些真正做事的人相互讨论，你去做其他事情吧。</p></li><li><p>不要官僚主义。 </p></li><li><p>创意比年龄更重要。提出想法的人很初级不意味着TA不应该获得尊重和合作。</p></li><li><p>最糟糕的事情就是只会说「不，不行。」，而不提出切实可行的改进措施来。</p></li></ul><p>3、</p><p>关于251，看到一个妙评：大象踩了一脚蚂蚁，没踩死，对蚂蚁说，你可以踩我一脚。 </p>        <h2 id="图片">          <a href="#图片" class="heading-link"><i class="fas fa-link"></i></a>图片</h2>      <p>互联网现状</p><p>1、</p><p><img src="/2019/12/08/weekly-issue-5/photo1.jpg" alt="photo1"></p><p>2、</p><p><img src="/2019/12/08/weekly-issue-5/photo2.jpg" alt="photo2"></p><p>3、</p><p><img src="/2019/12/08/weekly-issue-5/photo3.png" alt="photo3"></p>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（8）：抽象类和接口的区别？</title>
      <link href="2019/12/02/android-interview-8-abstract-class-and-interface/"/>
      <url>2019/12/02/android-interview-8-abstract-class-and-interface/</url>
      
        <content type="html"><![CDATA[        <h2 id="抽象类和接口的区别">          <a href="#抽象类和接口的区别" class="heading-link"><i class="fas fa-link"></i></a>抽象类和接口的区别</h2>      <p>1、抽象类可以提供成员方法的实现细节，而接口中只能存在 public 抽象方法；</p><p>接口在 Java 长达 20 多年的时间中，都只能拥有抽象方法，直到 JDK1.8 才能拥有实现的方法（还必须用default关键字修饰）</p><p>2、抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <code>public static final</code> 类型的；</p><p>3、接口中不能含有构造器、静态代码块以及静态方法，而抽象类可以有构造器、静态代码块和静态方法；</p><p>4、一个类只能继承一个抽象类，而一个类却可以实现多个接口；</p><p>5、抽象类访问速度比接口速度要快，因为接口需要时间去寻找在类中具体实现的方法。</p><p>换个角度思考，抽象类和接口的区别在于设计目的不同。</p><p>接口的设计目的，是对类的行为进行约束，强制不同的类具有相同的行为，它只约束行为的有无，不对如何实现进行限制。</p><p>抽象类的设计目的，是代码复用。当不同的类具有相同的行为，且其中一部分行为的实现方式一致时，可以让这些类都派生于一个抽象类。</p>        <h2 id="为什么接口中不能定义变量？">          <a href="#为什么接口中不能定义变量？" class="heading-link"><i class="fas fa-link"></i></a>为什么接口中不能定义变量？</h2>      <blockquote><p>如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口 A 中有一个public 访问权限的静态变量 a。按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx; 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a 的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。</p><p>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，接口是对开闭原则的一种体现。</p><p>参考：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/ameyume/article/details/6189749">Java中接口里定义的成员变量</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
            <tag> Android面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 4 期</title>
      <link href="2019/11/30/weekly-issue-4/"/>
      <url>2019/11/30/weekly-issue-4/</url>
      
        <content type="html"><![CDATA[<p> 这里记录过去一周，我看到的值得分享的内容。 </p><p><img src="/2019/11/30/weekly-issue-4/titu.jpg" alt="titu"></p><p>（题图： <span class="exturl"><a class="exturl__link" href="https://unsplash.com/@martin_schmidli">Martin Schmidli</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ） </p>        <h2 id="文章">          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/yVcCRpIrCN-O8eekJYNzmw">和死神赛跑：趁父亲还在世，我想用人工智能留住他</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>《连线》杂志的一篇文章《<span class="exturl"><a class="exturl__link" href="https://www.wired.com/story/a-sons-race-to-give-his-dying-father-artificial-immortality/">我用 AI 机器人留住去世的父亲</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>》，作者在得知父亲肺癌晚期后，录下了自己与父亲的对话。后来利用这些对话资料，建造了一个人工智能对话机器人。父亲去世以后，跟机器人对话，机器人说出父亲会说的话。</p><p>有网友把这篇文章翻译成了中文，读完很是感动。</p><p><img src="/2019/11/30/weekly-issue-4/dadbot-opener.jpg" alt="dadbot-opener"></p><p>2、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/t3Ob6AHlYeO-rZf5c6cknw">网易裁员事件引发的思考：5点建议，越早懂，越能保护自己</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>这一周，一篇《<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/FW7uR5t6UMMxgkCcAvk-MA">网易裁员，让保安把身患绝症的我赶出公司。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>》的文章获得广泛关注。 最后双方也达成了和解。</p><p>作为普通群众，我们应该从这件事中有所获得，我们应该学到的也许不是公关技巧，而是被很多人忽略的《劳动合同法》的基本知识。</p><p>3、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/agsk7RjZxumx05aQEXurpw">深度调查：人贩子“梅姨”身后嗜血的“寻人灰产”</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>寻亲背后一直有一条灰色产业链，只是你不知道。希望这些吃人血馒头的恶人能被绳之以法。</p><p>另外推荐大家了解下公安部失踪儿童消息紧急发布平台，也叫着 「<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/SfsFTFFdhcQCCjVBi3pnLA">团圆系统</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>」。  </p>        <h2 id="工具">          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://carbon.now.sh/">Carbon</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一个生成代码图片的网站，很多好看的样式。</p><p><img src="/2019/11/30/weekly-issue-4/carbon.png" alt="carbon"></p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/unbug/codelf">codelf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>变量命名神器，写代码不知道变量怎么命名就去这里查，命令多来自与 GitHub 爬虫，具备参考价值。</p><p><img src="/2019/11/30/weekly-issue-4/codelf.png" alt="codelf"></p><p>3、<span class="exturl"><a class="exturl__link" href="https://github.com/crimx/ext-saladict">Saladict</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>聚合词典专业划词翻译，浏览器插件必备。<img src="/2019/11/30/weekly-issue-4/sala.gif" alt="sala"></p><p>4、<span class="exturl"><a class="exturl__link" href="https://www.sourcetrail.com/">Sourcetrail</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一个免费开源、跨平台的可视化源码探索项目。</p><p>特地为它写了一篇文章：<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/BnM4H0aa4mlHc4wwhsUBmw">开源免费的源码阅读神器 Sourcetrail</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><img src="/2019/11/30/weekly-issue-4/sourcetrail.gif" alt="sourcetrail"></p><p>5、<span class="exturl"><a class="exturl__link" href="https://apps.apple.com/cn/app/%E8%8B%B1%E8%AF%AD%E8%BD%BB%E6%9D%BE%E8%AF%BB/id1471605122">英语轻松读</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p>英语轻松读是针对已经有一定英语阅读能力的人群推出的阅读辅助工具。在看新闻的同时学习英语。</p><p>目前 ios App 已经上架，Android 正在开发中，稍等几天即可。</p><p><img src="/2019/11/30/weekly-issue-4/learn_english.png" alt="learn_english"></p>        <h2 id="资源">          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://engfluent.com/blog/">English Learning Blog by EngFluent – EngFluent</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p> 这个博客分享学习英语的经验和方法，听说读写都有。</p>        <h2 id="言论和笑话">          <a href="#言论和笑话" class="heading-link"><i class="fas fa-link"></i></a>言论和笑话</h2>      <p>1、</p><p> 在计算机科学中只有两件难事：缓存失效和命名 。</p><p>–  Phil Karlton</p><p>2、</p><p>未来的世界，我们每人都必须要用一个政府发的手机，收集每个人的数据，且每天都要用手机的人脸识别进行微笑打卡，手机每天推送的文章都会有是否已读标识，如果没读，就会打电话催你，读了就要回复写心得，Al会自动判分，一天要挣够积分，挣不够分就是价值观有问题，要去补习班参加集体学习…… </p><p>– Hao Chen</p><p>3、</p><p>我们这个币圈，不容易啊，真的不容易啊，大家这种有梦想，怀揣着一夜暴富的心理来做币，遇到这种情况真是，真是特别糟糕，我们一定要就是（哽咽），大家一定要（抽泣），同心协力（破声），好吗？ </p><p>– 币圈维权群语音</p>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源免费的源码阅读神器 Sourcetrail</title>
      <link href="2019/11/27/sourcetrail/"/>
      <url>2019/11/27/sourcetrail/</url>
      
        <content type="html"><![CDATA[<p>阅读源码的工具很多，今天给大家推荐一款别具一格的源码阅读神器。</p><p>它就是 Sourcetrail，一个免费开源、跨平台的可视化源码探索项目。</p><p><img src="/2019/11/27/sourcetrail/concept.png" alt="concept"></p><p>直接看效果图：</p><p><img src="/2019/11/27/sourcetrail/step10.png" alt="step10"></p><p>上面是我阅读 okhttp 源码的一个界面，不同于其他代码编辑器的导航栏，左侧使用图形直观地表示了调用上游和下游，类成员列表等等细节，使得理解源代码的结构变得很容易。</p><p>目前支持 C、C++、Python 和 Java 语言，同时提供了相关 SDK 用于拓展支持其它语言，相信在未来会提供更多语言的支持。</p><p>官网地址： </p><p><span class="exturl"><a class="exturl__link" href="https://www.sourcetrail.com/">https://www.sourcetrail.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p>目前已经开源：</p><p><span class="exturl"><a class="exturl__link" href="https://github.com/CoatiSoftware/Sourcetrail">https://github.com/CoatiSoftware/Sourcetrail</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p>支持 Windows、macOS、Linux 三个平台，下载地址：</p><p><span class="exturl"><a class="exturl__link" href="https://github.com/CoatiSoftware/Sourcetrail/releases">https://github.com/CoatiSoftware/Sourcetrail/releases</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>下面简单介绍下如何使用 sourcetrail 阅读源码，以 okhttp 源码为例：</p><p>首先打开界面如下，点击左侧的 <code>New Project</code> 创建项目</p><p><img src="/2019/11/27/sourcetrail/step1.png" alt="step1"></p><p>选择预先下载好的 okhttp 源码文件夹</p><p><img src="/2019/11/27/sourcetrail/step2.png" alt="step2"></p><p>点击 <code>Add Source Group</code>，选择 Empty Java Source Group：</p><p><img src="/2019/11/27/sourcetrail/step3.png" alt="step3"></p><p>点击 <code>Next</code> 到下面这个界面， 依次点击步骤 1、2 指定索引文件： </p><p><img src="/2019/11/27/sourcetrail/step4.png" alt="step4"></p><p>点击 <code>Next</code> 后出现下面的界面，点击 <code>Create</code> 按钮：</p><p><img src="/2019/11/27/sourcetrail/step5.png" alt="step5"></p><p>选择 <code>All Files</code>， 点击 <code>Start</code> 按钮开始索引，等待一段时间。</p><p><img src="/2019/11/27/sourcetrail/step6.png" alt="step6"></p><p><img src="/2019/11/27/sourcetrail/step7.png" alt="step7"></p><p><img src="/2019/11/27/sourcetrail/step8.png" alt="step8"></p><p>出现 Error 是正常的，因为源码中有很多文件找不到，不影响阅读源码。</p><p>索引完成后点击 <code>OK</code>，就可以开始源码阅读了。</p><p><img src="/2019/11/27/sourcetrail/step9.png" alt="step9"></p><p><img src="/2019/11/27/sourcetrail/step10.png" alt="step10"></p><p>项目中的符号都可以点击，支持来回跳转，还支持模糊搜索。左侧源码结构非常清晰，对于熟悉陌生代码结构非常有用。</p><p>还可以与其他编辑器链接，比如： Atom, Clion, Eclipse, Emacs, IntelliJ IDEA 等等。</p><p>还有更多功能可以参见官方文档：</p><p> <span class="exturl"><a class="exturl__link" href="https://www.sourcetrail.com/documentation/">https://www.sourcetrail.com/documentation/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p>一般不特地推荐，一推荐必是利器。赶紧上手体验下。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（7）：你对单例模式了解多少？</title>
      <link href="2019/11/25/android-interview-7-singleton/"/>
      <url>2019/11/25/android-interview-7-singleton/</url>
      
        <content type="html"><![CDATA[<p>不管是在开发还是面试过程中，单例模式出现的频率都非常的高。但很多人对单例模式一知半解，单例模式的写法非常多，不同写法的区别很大，这篇文章的目的是带你深入学习一下单例模式。</p>        <h2 id="什么是单例模式">          <a href="#什么是单例模式" class="heading-link"><i class="fas fa-link"></i></a>什么是单例模式</h2>      <p>单例模式是一种对象创建型模式，用来编写一个类，在整个应用系统中只能有该类的一个实例对象。  </p><p>UML 结构图：</p><p><img src="/2019/11/25/android-interview-7-singleton/singleton.jpg" alt="singleton"></p><p>单例模式的三要点：</p><p>1、某个类只能有一个实例</p><p>2、必须自行创建这个实例</p><p>3、必须自行向整个系统提供这个实例</p>        <h2 id="单例模式的特点">          <a href="#单例模式的特点" class="heading-link"><i class="fas fa-link"></i></a>单例模式的特点</h2>      <p>优点：</p><p>使用单例模式可以减少内存的开销，避免了对象实例的频繁创建和销毁。</p><p>缺点：</p><ul><li><p>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 </p></li><li><p>单例类的职责过重，在一定程度上违背了”单一职责原则”。 </p></li></ul>        <h2 id="单例模式的各种写法">          <a href="#单例模式的各种写法" class="heading-link"><i class="fas fa-link"></i></a>单例模式的各种写法</h2>      <p><strong>1、饿汉式单例类</strong></p><p>饿汉式比较简单，对象在类加载时就实例化，因此称为饿汉式单例类。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> instance;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure><p>优点：线程安全，没有加锁，执行效率高。</p><p>缺点：未使用单例类时，造成内存浪费。</p><p><strong>2、懒汉式单例类</strong></p><p>在需要使用单例类时在创建实例对象，所有称为懒汉式单例类。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>优点：节约内存</p><p>缺点：线程不安全，多线程可能会创建多个实例</p><p><strong>3、同步方法的懒汉式单例类</strong></p><p>在 <code>getInstance()</code> 方法前增加关键字 synchronized。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>优点：解决了线程安全问题</p><p>缺点：除了第一次调用 <code>getInstance()</code>需要同步，后面的调用造成不必要的同步开销，不建议用这种模式。 </p><p><strong>4、 双重检查锁定</strong> </p><p>这种写法是在 <code>getInstance()</code> 方法中进行两次判空，缩小同步锁的粒度。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>第二个判空是必要的，原因如下：</p><p>假如某一瞬间线程 A 和线程 B 都在调用<code>getInstance()</code> 方法，此时 instance 对象为 null，均能通过 “ instance == null ” 的判断。线程 A 进入 synchronized 锁定的代码中执行实例创建代码，线程 B 处于排队等待状态。当 A 执行完毕创建了实例后，线程 B 进入 synchronized 代码，此时 B 并不知道实例已经创建，将创建新的实例。 </p><p>因此需要在 synchronized 锁定代码中再进行一次判空处理，这种方式称为双重检查锁定。实例变量需要加 volatile 关键字保证易变可见性，JDK1.5 起才可用。 </p><p>优点：一定程度上解决了资源的消耗和多余的加锁同步，线程安全等问题。</p><p>缺点：由于 volatile 关键字会屏蔽 Java 虚拟机所做的一些代码优化，可能会导致系统运行效率降低。</p><p><strong>5、静态内部类单例模式</strong></p><p>同样利用了 JVM 类加载机制来保证初始化实例对象时只有一个线程，静态内部类 SingletonHolder 类只有第一次调用 <code>getInstance()</code> 方法时，才会装载从而实例化对象。 </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure><p>优点：解决了线程安全问题，延迟加载、节省内存，性能优于上述几种实现方式。</p><p><strong>6、枚举方式</strong></p><p>定义一个枚举的元素，就代表 Singleton 实例。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    INSTANCE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    **调用方式：Singleton.INSTANCE.doSomethingMethod();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure><p>优点：线程安全，防止反序列化或者反射攻击时实例重新创建。</p>        <h2 id="如何避免-Java-反射破坏单例模式">          <a href="#如何避免-Java-反射破坏单例模式" class="heading-link"><i class="fas fa-link"></i></a>如何避免 Java 反射破坏单例模式</h2>      <p>上面 6 种 Java 单例模式实现方式除枚举方式外，其他几种依然可以通过相关反射方法，改变其权限，创建多个实例，代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Singleton singletonnew = constructor.newInstance();</span><br><span class="line">            System.out.println(singleton == singletonnew);   <span class="comment">// 输出结果：false</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如何避免 Java 反射破坏单例模式呢？可以在构造函数里面进行判断：如果当前已有实例，通过抛出异常来阻止反射创建对象。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != Singleton.singleton) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="如何避免-Java-反序列化破坏单例模式">          <a href="#如何避免-Java-反序列化破坏单例模式" class="heading-link"><i class="fas fa-link"></i></a>如何避免 Java 反序列化破坏单例模式</h2>      <p>除了反射，反序列化也可能破坏单例模式，反序列化会通过反射调用无参数的构造方法创建一个新的对象。 </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">             ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;tempFile&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(Singleton.getInstance());</span><br><span class="line">            Singleton newInstance = (Singleton) ois.readObject();</span><br><span class="line">            System.out.println(newInstance == Singleton.getInstance()); <span class="comment">// 输出 false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>解决方法是只要在 Singleton 类中定义 <code>readResolve()</code> 方法即可。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android面试题 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 3 期</title>
      <link href="2019/11/23/weekly-issue-3/"/>
      <url>2019/11/23/weekly-issue-3/</url>
      
        <content type="html"><![CDATA[<p> 这里记录过去一周，我看到的值得分享的内容。 </p><p><img src="/2019/11/23/weekly-issue-3/titu.jpg" alt="titu"></p><p>（题图：合肥翡翠湖）</p>        <h2 id="文章">          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/ylgfdjRzwAzhiRKGp6lFSQ">我以前在阿里巴巴的流量方法论</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>流量为王，可能对你有所启发。</p><p>2、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/Z_Ut2nOUEFywSD064E0dDg">吕先生的三个贵人</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>中华灵芝宝、双灵固本散、绿谷灵芝宝，你耳熟能详的东西，但可能并不真正了解真相。</p><p>3、<span class="exturl"><a class="exturl__link" href="https://opensource.com/article/19/10/why-switch-mac-linux">为什么我从 Mac 换到了 Linux</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><blockquote><p>它激发了我重新潜入的乐趣，我享受这段旅途的乐趣。 </p></blockquote>        <h2 id="资源">          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://pan.baidu.com/s/1jXvXwQYPtJa5kcektcqJSA">9 大技术领域，1500+道面试题出炉！（资源版）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>阿里技术特别策划。</p><p>2、分享一波安卓面试资料</p><p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/u014803701/article/details/81381491">2019 Android 面试题汇总（面试总结全） </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p><span class="exturl"><a class="exturl__link" href="https://juejin.im/entry/5a1548f7f265da43310d77e2">2018最新安卓面试大全（含BAT，网易，滴滴）—-你面不上BAT的原因：面经宝典，都在这里啦 - Android - 掘金</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5c0f39fa6fb9a04a0d56b19f">Android面试整理(附答案) - 掘金</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p><span class="exturl"><a class="exturl__link" href="https://juejin.im/entry/57bd3a4a2e958a00694b5bcf">还原最真实最完整的一线公司面试题 - 阅读 - 掘金</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/aademeng/articles/11079455.html">Android 面试资料集锦 - 天涯海角路 - 博客园</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>        <h2 id="言论">          <a href="#言论" class="heading-link"><i class="fas fa-link"></i></a>言论</h2>      <p>1、</p><p>我来到推特以后，才发现不管怎么沟通，一半人总是会讨厌另一半人。 </p><p>–  迈克尔·阿灵顿 </p><p>2、</p><p> 关于钱的几个原则： </p><p>1）、不要贪婪，挣自己该挣的钱 </p><p>2）、遵守契约，说好了就遵守约定</p><p>3）、掌握挣钱的能力比你现在有钱好很多。因为钱随时会没有啊。 </p><p>4）、大部分挫折长期来看都是小问题 </p><p>– 池建强</p><p>3、</p><p> “叮铃铃铃……”一阵清脆的铃声惊醒了哥的美梦，关上了 8848 钛金手机闹表，哥从床上缓缓爬了起来，熟练的穿上了脊柱整形明星产品背背佳，下地穿上了内含骨正基鞋垫的足力健老人鞋，嗯，浑身都暖和起来了。哥走了几步，感觉昨天做完火疗之后背痛症状没啥缓解，还不如前天的酸碱平 dds 治疗仪，“算了，可能是疗程不够！”哥心想着，拿出了一瓶本草清液吸了起来，一边打开了 e 人 e 本高端电脑，看了看股市，又咒骂了一番。嗯，这个产品味道还不赖，跟沙棘雪莲果饮料差不太多。哥心满意足的拔出吸管，咂摸着滋味。哎呀，都怪昨天小李，非得让哥多喝几杯鸿茅药酒，整得哥还有些许头晕，差点忘了服用极草 5x 含片。这含片没吃，燕之屋碗燕也喝不下去了，不知道会不会影响胶原蛋白的吸收，搞不好紫草精油还得续一个疗程。正想着，小罐茶茶具里的水沸腾了，哥赶紧拿出大师精心炒制的大红袍，晃了晃，听说好听就好茶。坐在碧玺温灸床垫上，手捧着茶杯，哥不禁感叹人生，所谓成功也不过如此吧！ </p><p>——公众号读者「蜗牛的新微信号」留言 </p><p>4、</p><p> 真正的发现之旅不在于寻找新的土地，而在于用新的眼光来看待。</p><p>– <span class="exturl"><a class="exturl__link" href="https://www.age-of-the-sage.org/quotations/proust_having_seeing_with_new_eyes.html">Marcel Proust</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（6）：谈谈你对 ANR 的了解？</title>
      <link href="2019/11/19/android-interview-6-anr/"/>
      <url>2019/11/19/android-interview-6-anr/</url>
      
        <content type="html"><![CDATA[        <h2 id="什么是-ANR">          <a href="#什么是-ANR" class="heading-link"><i class="fas fa-link"></i></a>什么是 ANR</h2>      <p>ANR(Application Not responding)，即应用程序无响应，简单来说，就是用户界面突然卡住，无法响应用户的操作（比如触摸事件）。</p><p>Android 系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成 ANR。一般情况下，ANR 后会弹出一个提示框，告知用户当前应用无响应，用户可选择继续等待或者关闭应用。</p><p><img src="/2019/11/19/android-interview-6-anr/anr_dialog.png"></p>        <h2 id="出现场景">          <a href="#出现场景" class="heading-link"><i class="fas fa-link"></i></a>出现场景</h2>      <ul><li><p><strong>InputDispatching Timeout</strong>：5 秒内无法响应屏幕触摸事件或键盘输入事件。</p></li><li><p><strong>BroadcastQueue Timeout</strong> ：在执行前台广播（BroadcastReceiver）的<code>onReceive()</code>函数时  10s 没有处理完成，后台为 60s。</p></li><li><p><strong>Service Timeout</strong> ：前台服务 20s 内，后台服务在 200s 内没有执行完毕。</p></li><li><p><strong>ContentProvider Timeout</strong> ：ContentProvider的 publish 在 10s 内没进行完。</p></li></ul>        <h2 id="如何避免">          <a href="#如何避免" class="heading-link"><i class="fas fa-link"></i></a>如何避免</h2>      <p>基本的思路就是将 IO 操作在工作线程来处理，减少其他耗时操作和错误操作。比如网络请求、Socket 通信、SQL操作、文件读写和或者有可能阻塞 UI 线程的操作放在子线程。</p>        <h2 id="ANR-分析">          <a href="#ANR-分析" class="heading-link"><i class="fas fa-link"></i></a>ANR 分析</h2>      <p>ANR 发生时 Logcat 会打印类似下面的日志：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/com.wuzy.anrtest I/zygote64: Thread[3,tid=6428,WaitingInMainSignalCatcherLoop,Thread*=0x7b3965ca00,peer=0x171c0020,&quot;Signal Catcher&quot;]: reacting to signal 3</span><br><span class="line">/com.wuzy.anrtest I/zygote64: Wrote stack traces to &#x27;/data/anr/traces.txt&#x27;</span><br><span class="line">/com.wuzy.anrtest I/Choreographer: Skipped 6000 frames!  The application may be doing too much work on its main thread.</span><br></pre></td></tr></table></div></figure><p>每次产生 ANR 之后，系统都会向<code>/data/anr/traces.txt</code>中写入新的日志数据。</p><p>获取日志的命令：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cat /data/anr/traces.txt &gt; /mnt/sdcard/traces.txt</span><br><span class="line">exit</span><br><span class="line">adb pull /sdcard/traces.txt</span><br></pre></td></tr></table></div></figure><p>这里我模拟一个 ANR 情况，在按钮点击事件中调用 <code>Thread.sleep</code>，查看 traces 文件内容，可以看到线程名、线程优先级、线程 ID、线程状态和 ANR 的原因。</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----- pid 13872 at 2019-11-14 15:18:50 -----</span><br><span class="line">Cmd line: com.wuzy.anrtest</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&quot;main&quot; prio=5 tid=1 Sleeping</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x735f1ad0 self=0x7b396a3a00</span><br><span class="line">  | sysTid=13872 nice=-10 cgrp=default sched=0/0 handle=0x7b3e6f69b0</span><br><span class="line">  | state=S schedstat=( 832049486 21080201 432 ) utm=77 stm=6 core=5 HZ=100</span><br><span class="line">  | stack=0x7fe0065000-0x7fe0067000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Thread.sleep(Native method)</span><br><span class="line">  - sleeping on &lt;0x026e2fdc&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:386)</span><br><span class="line">  - locked &lt;0x026e2fdc&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:327)</span><br><span class="line">  at com.wuzy.anrtest.MainActivity$1.onClick(MainActivity.java:19)</span><br><span class="line">  at android.view.View.performClick(View.java:6291)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:24931)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:808)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:101)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:166)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:7523)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:245)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:921)</span><br></pre></td></tr></table></div></figure>        <h2 id="ANR-监测机制">          <a href="#ANR-监测机制" class="heading-link"><i class="fas fa-link"></i></a>ANR 监测机制</h2>      <p>Android 应用程序是通过消息来驱动的，Android 某种意义上也可以说成是一个以消息驱动的系统，UI、事件、生命周期都和消息处理机制息息相关。Android 的 ANR 监测机制也是一样，大部分就是利用了 Android 的消息机制。 </p><p><img src="/2019/11/19/android-interview-6-anr/anr.png"></p><p>在 Android 中，实际上是系统服务在控制每个组件的生命周期回调，所以可以在这个逻辑入口开始计时，利用 Handler 机制，发生延时消息，如果超时了，就处理 ANR 事件消息，如果没有超时，就取消队列里的延时消息，也就不会出现 ANR。</p><p>具体源码细节，推荐阅读：</p><p><span class="exturl"><a class="exturl__link" href="http://gityuan.com/2019/04/06/android-anr/">彻底理解安卓应用无响应机制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="http://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="http://gityuan.com/2016/12/02/app-not-response/">理解Android ANR的信息收集过程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 2 期</title>
      <link href="2019/11/16/weekly-issue-2/"/>
      <url>2019/11/16/weekly-issue-2/</url>
      
        <content type="html"><![CDATA[<p>这里记录过去一周，我看到的值得分享的内容。</p><p><a href="weekly-issue-2/titu.jpg"><img src="/2019/11/16/weekly-issue-2/titu.jpg" alt="titu"></a></p><p>（题图：J. Berengar Sölter ）</p>        <h2 id="文章">          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/NjIUtuHg_T58ZsZZaPHZCA">我们在淘宝京东拼多多买东西时，有哪些价格歧视？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>作者在京东工作，对平台和商家的一些商业套路比较了解。文章深入介绍了价格歧视的原理，商家使用的价格歧视策略。</p><p>2、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/7IHIGAIrqtyQN4FjhuNjxQ">淘宝 1 小时交易额破千亿！</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>作者在双 11 前使用天猫历年交易额，做了一个多项式的拟合，预测了今年双 11 的交易额是 2692 亿，最终的结果是 2684 亿 ，不得不说，非常神奇。</p><p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/tianmao.jpg"><img src="/2019/11/16/weekly-issue-2/tianmao.jpg" alt="img"></a></p><p>3、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/iVqNKb6M1SfMD3FBOoGjDQ">想砍死北野武的女人们</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>文章介绍了北野武戏剧性的一生，值得一看。</p><p>“ 我认为，一个人是不是长大成熟，由他对父母的感情方式来判定。当你面对父母，觉得他们很不容易时，就是迈向成熟的第一步。”</p><p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/beiyewu.jpg"><img src="/2019/11/16/weekly-issue-2/beiyewu.jpg" alt="img"></a></p><p>4、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/xh1paOC54FwsPxxXVcc_HA">做人，就做这样的人</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>人的一生，到底要怎么度过，如果你感到迷茫，充满焦虑，没有方向，可以看看这篇文章。</p>        <h2 id="工具">          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="http://aospxref.com/">AOSPXRef</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>Android 源码在线阅读网站，支持交叉引用跳转，服务器在国内，访问速度很快。</p><p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/aospxref.png"><img src="/2019/11/16/weekly-issue-2/aospxref.png" alt="img"></a></p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/pd4d10/octohint">octohint</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一款浏览器插件，在 GitHub 上浏览代码时能够快速定位变量出现或声明的位置。</p><p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/octohint.jpg"><img src="/2019/11/16/weekly-issue-2/octohint.jpg" alt="img"></a></p><p>3、<span class="exturl"><a class="exturl__link" href="https://github.com/mobile">GitHub Mobile</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>GitHub 发布首款官方手机客户端应用，目前只要 ios 的 App，安卓版本暂未发布。</p><p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/github_mobile.png"><img src="/2019/11/16/weekly-issue-2/github_mobile.png" alt="github_mobile"></a></p>        <h2 id="资源">          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://segmentfault.com/a/1190000018626163">服务端高并发分布式架构演进之路</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>文章以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p><p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/server.png"><img src="/2019/11/16/weekly-issue-2/server.png" alt="img"></a></p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/jlevy/the-art-of-command-line">命令行的艺术</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。</p><p>3、<span class="exturl"><a class="exturl__link" href="https://github.com/flutterchina/flutter-in-action">Flutter 实战</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>由浅入深的介绍了 Flutter 技术和开发流程。</p><p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/flutter.jpg"><img src="/2019/11/16/weekly-issue-2/flutter.jpg" alt="flutter"></a></p><p>4、<span class="exturl"><a class="exturl__link" href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">正则表达式手册</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>网站包含正则表达式全集和常见正则表达式。</p><p>5、<span class="exturl"><a class="exturl__link" href="https://www.geeksforgeeks.org/">GeeksforGeeks</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>这个网站包含了大量计算机相关的问题和解答，许多问题都有形象的图表和源代码。</p><p>6、<span class="exturl"><a class="exturl__link" href="https://howhttps.works/">HOW HTTPS WORKS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>这个网站用图解的方式把 HTTP 相关的问题都说明得一清二楚，生动形象。如果你对 Http 不够熟悉，不妨看一下，肯定会很有收获的。</p>        <h2 id="摘录">          <a href="#摘录" class="heading-link"><i class="fas fa-link"></i></a>摘录</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="http://m.xsshuku.com/files/article/html/17/17145/2517893.html">司汤达在 1806 年致波丽娜的信中</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，给波丽娜的几点建议：</p><blockquote><p>以下是我着力要培养的习惯。</p><p>1.锻炼身体。</p><p>2.调侃邪恶之人和无聊之人的才能。</p><p>3.选择一个工作，并从中培养习惯。为达到这点，必须悉心寻找自己的主要热情所在。</p><p>4.承受得住悲伤。</p><p>5.不要过分夸大自己无法体味的幸福。</p><p>6.当上前与一个人攀谈时要自问：“他需要什么？”而不是索要什么。</p><p>7.简洁的习惯。</p><p>研习对人体有益的食物，并养成食用的习惯。反复温习上述几条，仔细思考一下以下三条警句：</p><p>1.习惯于伤悲，每个人每天都会经历七八件伤悲的事。</p><p>2.不要过分夸大不属于自己的幸福。</p><p>3.学会顶住各种艰难的时刻，致力于完善我们的思想以及知晓事理的艺术。</p><p>关于以上三条警句的思索几乎囊括了幸福的含义。</p></blockquote><p>2、北野武一些好玩的言论</p><blockquote><p>1.他离婚之后接受采访，北野武说：</p><p>「今年真是没啥好事，我的钱都没了，没钱后朋友都联络不上了。曝光后情妇也没了。<br>早知道这么难，不如和前妻在一起。」</p><p>2.他还有个很出名的渣男语录，逻辑非常奇妙，是这样说的：</p><p>「尽管没多大意思，但情人还是越多越好的。</p><p>如果只有一个情人，就会形成一种三角关系，而三角关系就是一种有棱角的关系。如果有两个呢，就是四角关系。三个呢，五角关系……</p><p>照此类推，情人越多，关系就越接近于圆，棱角也就越少。这样的话，彼此间的摩擦和风波也会减少。」</p><p>3.北野武踏入电视圈之后，没想到路异常的顺利。他对此的感想是：</p><p>「幸好没才华的人这么多，让这件事没有想象中复杂。」</p><p>4.有一次，北野武的后辈又吉直树2015年时得了芥川奖，他很直接地说：</p><p>「这可把我气坏了。当时我就想，那样的东西我也能写出来，我一定要让人惊讶原来北野武也能写出这样的东西。」</p><p>后来呢，纯粹为了赌气，他竟然真的写了一本纯爱小说！[允悲]</p><p>5.在拔除从右脸横穿左脸的器械时，他在书里这样写：</p><p>我能感觉到金属棒在鼻子底下一点一点地挪出去，同时还发出嘎吱嘎吱的声音，那声音就像金属棒把我的脑汁也一并带了出来。</p><p>我说了句：「我现在完全理解了关东煮的心情。」</p><p>结果被医生怒斥：「别说蠢话！」</p><p>6.在某个他拍摄的广告发布会上，主持人热场：<br>「今天闪光灯真的多得让人睁不开眼啦。」</p><p>北野武：「嗯，特别像艺人外遇被曝光后的道歉记者发布会…….」</p><p>7.在欧洲，人们不知道他还是个喜剧演员，以为他是个很出名的黑帮分子。<br>有一次，他受英国电影协会邀请飞去伦敦，协会会长到机场接他，一路上诚惶诚恐。</p><p>「为您准备的豪华轿车突然发生故障，所以只好用这种车子来接您了，实在对不起。请您多包涵。」</p><p>他说自己几年之后才知道为什么会长是这种态度，他们成了好朋友之后会长告诉他：</p><p>「当时我心里真是吓得要死，怕你会为此杀了我。<br>因为我以为你是日本的黑帮头子。」</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（5）：谈谈 Handler 机制和原理？</title>
      <link href="2019/11/13/android-interview-5-handler/"/>
      <url>2019/11/13/android-interview-5-handler/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一系列文章致力于为 Android 开发者查漏补缺，准备面试。</p><p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p><p>由于笔者水平有限，总结的内容难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p></blockquote>        <h2 id="1、说一下-Handler-消息机制中涉及到哪些类，各自的功能是什么？">          <a href="#1、说一下-Handler-消息机制中涉及到哪些类，各自的功能是什么？" class="heading-link"><i class="fas fa-link"></i></a>1、说一下 Handler 消息机制中涉及到哪些类，各自的功能是什么？</h2>      <p>Handler 主要用于跨线程通信。涉及MessageQueue/Message/Looper/Handler 这 4 个类。 </p><ul><li><p>Message：消息，分为硬件产生的消息和软件生成的消息。</p></li><li><p>MessageQueue：消息队列，主要功能是向消息池投递信息 (<code>MessageQueue.enqueueMessage</code>) 和取走消息池的信息 (<code>MessageQueue.next</code>) 。</p></li><li><p>Handler：消息处理者，负责向消息池中发送消息 (<code>Handler.enqueueMessage</code>) 和处理消息 (<code>Handler.handleMessage</code>) 。</p></li><li><p>Looper：消息泵，不断循环执行 (<code>Looper.loop</code>) ，按分发机制将消息分发给目标处理者。</p></li></ul><p>它们之间的类关系：</p><p>Looper 有一个 MessageQueue 消息队列；MessageQueue 有一组待处理的 Message；Message 中有一个用于处理消息的 Handler；Handler 中有 Looper 和 MessageQueue。</p><p><img src="/2019/11/13/android-interview-5-handler/handler_main.jpg" alt="图片来源 gityuan"></p>        <h2 id="2、一个线程可以有几个-Looper、几个-MessageQueue-和几个-Handler？">          <a href="#2、一个线程可以有几个-Looper、几个-MessageQueue-和几个-Handler？" class="heading-link"><i class="fas fa-link"></i></a>2、一个线程可以有几个 Looper、几个 MessageQueue 和几个 Handler？</h2>      <p>在 Android 中，Looper 类利用了 ThreadLocal 的特性，保证了每个线程只存在一个 Looper 对象。</p><p>关于 ThreadLocal 可以看这篇文章：<a href="http://wuzhangyang.com/2019/02/19/threadlocal/">理解 ThreadLocal</a></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Looper 构造函数中创建了 MessageQueue 对象，因此一个线程只有一个 MessageQueue。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以有多个 Handler。</p><p>Handler 在创建时与 Looper 和 MessageQueue 关联起来：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Handler 发送消息是将消息传递给 MessageQueue：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意 <code>msg.target = this;</code>， 这里将当前的 Handler 赋值给 Message 对象，在后面处理消息时就能依据 msg.target 区分不同的 Handler。</p>        <h2 id="3、可以在子线程直接创建一个-Handler-吗？会出现什么问题，那该怎么做？">          <a href="#3、可以在子线程直接创建一个-Handler-吗？会出现什么问题，那该怎么做？" class="heading-link"><i class="fas fa-link"></i></a>3、可以在子线程直接创建一个 Handler 吗？会出现什么问题，那该怎么做？</h2>      <p>不能在子线程直接 new 一个 Handler。因为 Handler 的工作依赖于 Looper，而 Looper 又是属于某一个线程的，其他线程不能访问，所以在线程中使用 Handler 时必须要保证当前线程中 Looper 对象并且启动循环。不然会抛出异常。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread() + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br></pre></td></tr></table></div></figure><p>正确做法是：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();   <span class="comment">// 为线程创建 Looper 对象</span></span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();   <span class="comment">// 启动消息循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="4、既然线程中创建-Handler-时需要-Looper-对象，为什么主线程不用调用-Looper-prepare-创建-Looper-对象？">          <a href="#4、既然线程中创建-Handler-时需要-Looper-对象，为什么主线程不用调用-Looper-prepare-创建-Looper-对象？" class="heading-link"><i class="fas fa-link"></i></a>4、既然线程中创建 Handler 时需要 Looper 对象，为什么主线程不用调用 Looper.prepare() 创建 Looper 对象？</h2>      <p>在 App 启动的时候系统默认启动了一个主线程的 Looper（ActivityThread 的 <code>main</code> 方法中），<code>Loop.prepareMainLooper</code> 方法也是调用了 <code>Looper.prepare</code>方法，里面会创建一个不可退出的 Looper, 并 <code>set</code> 到 sThreadLocal 对象当中。 </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="5、-Looper-死循环为什么不会导致应用卡死，会消耗大量资源吗？">          <a href="#5、-Looper-死循环为什么不会导致应用卡死，会消耗大量资源吗？" class="heading-link"><i class="fas fa-link"></i></a>5、 Looper 死循环为什么不会导致应用卡死，会消耗大量资源吗？</h2>      <p>引用 Gityuan :</p><blockquote><p>对于线程即是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder 线程也是采用死循环的方法，通过循环方式不同与 Binder 驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。真正会卡死主线程的操作是在回调方法 onCreate/onStart/onResume 等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。</p></blockquote><blockquote><p>主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到 Linux pipe/epoll 机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 Loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步 I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量 CPU 资源。</p></blockquote><p>详细解答：<span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/34652589">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="6、-MessageQueue-是队列吗？它是什么数据结构？">          <a href="#6、-MessageQueue-是队列吗？它是什么数据结构？" class="heading-link"><i class="fas fa-link"></i></a>6、 MessageQueue 是队列吗？它是什么数据结构？</h2>      <p>MessageQueue 不是队列，它内部使用一个 Message 链表实现消息的存和取。 链表的排列依据是  <code>Message.when</code>，表示 Message 期望被分发的时间，该值是 <code>SystemClock. uptimeMillis()</code> 与 <code>delayMillis</code> 之和。 </p><p>##7、 <code>handler.postDelayed()</code> 函数延时执行计时是否准确？</p><p>当上一个消息存在耗时任务的时候，会占用延时任务执行的时机，实际延迟时间可能会超过预设延时时间，这时候就不准确了。</p><p>##8、 你对 IdleHandler 有多少了解? </p><p>IdleHandler 是一个接口， 这个接口方法是在消息队列全部处理完成后或者是在阻塞的过程中等待更多的消息的时候调用的，返回值 false 表示只回调一次，true 表示可以接收多次回调。 </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure><p>##9、 你了解 HandlerThread 吗?</p><p>HandlerThread 继承自 Thread，它是一种可以使用 Handler 的 Thread，它的实现也很简单，在 <code>run</code>方法中也是通过 <code>Looper.prepare()</code> 来创建消息队列，并通过<code>Looper.loop()</code>来开启消息循环（与我们手动创建方法基本一致），这样在实际的使用中就允许在 HandlerThread 中创建 Handler 了。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>由于 HandlerThread 的<code>run</code>方法是一个无限循环，因此当不需要使用的时候通过<code>quit</code>或者<code>quitSafely</code>方法来终止线程的执行。</p><p>##10、 你对 <code>Message.obtain()</code> 了解吗, 或者你知道怎么维护消息池吗 ？</p><p> <code>Message.obtain()</code>  是从消息池取 Message，消息池其实是使用 Message 链表结构实现，消息池默认最大值 50。 <code>Message.obtain()</code>  每次都是把消息池表头的 Message 取走 ，再把表头指向 next。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;  <span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清除in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(); <span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>消息在 loop 中被 handler 分发消费之后会执行回收的操作，将该消息内部数据清空并添加到消息链表的表头。 </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123; <span class="comment">//判断消息是否正在使用</span></span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123; <span class="comment">//Android 5.0以后的版本默认为true,之前的版本默认为false.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将消息标示位置为IN_USE，并清空消息所有的参数。</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++; <span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>最后，关于 Handler 的详细分析推荐阅读 Gityuan 的文章。</p><p><span class="exturl"><a class="exturl__link" href="http://gityuan.com/2015/12/26/handler-message-framework/">Android消息机制1-Handler(Java层)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="http://gityuan.com/2015/12/27/handler-message-native/">Android消息机制2-Handler(Native层)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p><span class="exturl"><a class="exturl__link" href="http://gityuan.com/2016/01/01/handler-message-usage/">Android消息机制3-Handler(实战)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周分享第 1 期</title>
      <link href="2019/11/09/weekly-issue-1/"/>
      <url>2019/11/09/weekly-issue-1/</url>
      
        <content type="html"><![CDATA[<p>这里记录过去一周，我看到的值得分享的内容。 </p><p><img src="/2019/11/09/weekly-issue-1/titu.jpg" alt="titu"></p><p>（题图：大学一角，2019.10）</p><p>非常喜欢阮一峰老师的<span class="exturl"><a class="exturl__link" href="https://github.com/ruanyf/weekly" title="科技互联网周刊">科技互联网周刊</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，增长了不少见识，也很佩服阮老师的坚持。信息爆炸的时代，能够阅读到优质内容很不容易。</p><p>受阮老师的启发，将每周看到的优质内容分享出来，应该挺有价值的。其实，分享本身就是一件有趣有意义的事。</p>        <h2 id="文章">          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/5WzCzb6MHsLVa13tQppUdA">GQ报道 | 幸存者李佳琦：一个人变成算法，又想回到人</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>万字长文，GQ 带你走近当事人李佳琦，也许和你想象的不一样。</p><p>“李佳琦”这个符号是这台精密齿轮上最关键的部件，他也无法停止直播：“我不播了，那外面我的同事们怎么办？” 外面的同事怎么办？</p><p>2、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/w8qCG-amQe6dm5yoY9jxbA">你适合搞副业么？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>其实搞副业这事，如小马过河，有的适合，有的不适合，因人而异。有的人副业发达，甚至副业转正。有的人捡了副业的芝麻丢了主业的西瓜，明显得不偿失。有的人为了追求副业收益被人狠狠收割。 </p><p>3、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/NcDfRcK8ZC38mJh3IKmeig">这些年我从互联网收获的三桶金和五点感悟</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>别人的路也许复制不了，但是思维模式可以学习借鉴。</p><p>4、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/VmKsttIccfhA45TJQzPmxw">为刘润公号读者写了600多篇文章后，说说我的4点感悟</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>写作是每个人都应该学习的技能。</p><p>5、<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/b_BXZNXR9tS2ct3AdHeaGg">华为的“信任危机”</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>华为应该是今年最受关注的公司，这次华为 HR 胡玲发表在华为心声社区的实名控诉信，也再一次让华为成为舆论的热点。</p>        <h2 id="寓言">          <a href="#寓言" class="heading-link"><i class="fas fa-link"></i></a>寓言</h2>      <p>1、小马过河</p><p>马棚里住着一匹老马和一匹小马。</p><p>有一天，老马对小马说：“你已经长大了，能帮妈妈做点事吗？”小马连蹦带跳地说：“怎么不能？我很愿意帮您做事。”老马高兴地说：“那好哇，你把这半口袋麦子驮到磨坊去吧。”</p><p>小马驮起麦子，飞快地往磨坊跑去。跑着跑着，一条小河挡住了去路，河水哗哗地流着。小马为难了，心想：我能不能过去呢？如果妈妈在身边，问问她该怎么办，那多好哇！</p><p>他向四周望望，看见一头老牛在河边吃草。小马嗒嗒嗒跑过去，问道：“牛伯伯，请您告诉我，这条河，我能趟过去吗？”老牛说：“水很浅，刚没小腿，能趟过去。”</p><p>小马听了老牛的话，立刻跑到河边，准备趟过去。突然，从树上跳下一只松鼠，拦住他大叫：“小马，别过河，别过河，河水会淹死你的！”小马吃惊地问：“水很深吗？”松鼠认真地说：“深得很呢！昨天，我的一个伙伴就是掉进这条河里淹死的！”</p><p>小马连忙收住脚步，不知道怎么办才好。他叹了口气，说：“唉！还是回家问问妈妈吧！”</p><p>小马甩甩尾巴，跑回家去。妈妈问：“怎么回来啦？”小马难为情地说：“一条河挡住了，我……我过不去。”妈妈说：“那条河不是很浅吗？”小马说：“是啊！牛伯伯也这么说。可是松鼠说河水很深，还淹死过他的伙伴呢！”妈妈说：“那么河水到底是深还是浅？你仔细想过他们的话吗？”小马低下了头，说：“没……没想过。”妈妈亲切地对小马说：“孩子，光听别人说，自己不动脑筋，不去试试，是不行的。河水是深是浅，你去试一试就会明白了。”</p><p>小马跑到河边，刚刚抬起前蹄，松鼠又大叫起来：“怎么，你不要命啦！”小马说：“让我试试吧。”他下了河，小心地趟了过去。原来河水既不像老牛说的那样浅，也不像松鼠说的那样深。 </p><p>2、父子骑驴</p><p>在一个炎热的下午，一位父亲带着他儿子和一头驴走过满足灰尘的街。</p><p>父亲骑在驴上，儿子牵着它走。“可怜的孩子，”一位路人说道，“这个人怎能心安理得地骑在驴背上…”</p><p>父亲听到之后，就从驴背上下来让儿子坐上去。但走了没多久，又一位路人的声音传来“多么不孝。可怜的老父亲却在一旁跟着跑。小孩子听了之后连忙让父亲也坐在驴背上。</p><p>“你们谁见过这种事”一位妇女说道，“这么残酷地对待动物，可怜的驴子的背在下陷，而这个老家伙和他的儿子却悠然自得。”</p><p>父子俩闻言，只好从驴背上爬下来。但是，他们徒步走没多远，又一个陌生人笑着说：“我才不会这么蠢，放着好好的驴不用，却用脚来走。”</p><p>最后，人们看到这对父子俩抬着这头驴从街头走过。</p>        <h2 id="工具">          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>      <p>1、<span class="exturl"><a class="exturl__link" href="https://mdnice.com/" title="markdown-nice">markdown-nice</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>支持自定义样式的微信 Markdown 排版工具，可能是目前最好用的。</p>        <h2 id="言论">          <a href="#言论" class="heading-link"><i class="fas fa-link"></i></a>言论</h2>      <p>1、</p><p>人呐，往往一辈子要利还要名，就为个光宗耀祖。</p><p>– 三表龙门阵《<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/R0UVe6WlFntJLQirKAU3qQ">李佳琦的阶级欲望</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>》</p><p>2、</p><p>大家 955 的时候，有些聪明人觉得如果自己 996 那么裁掉的就是别人了。结果聪明人太多了。</p><p>3、</p><p>你妈不知道的，你知道的，叫网红。 </p><p>你妈知道的，你也知道的，叫明星。</p><p>你妈知道的，你知道的，你姥姥也知道的，叫大明星。</p><p>你妈知道的，你不知道的，叫过气明星。</p><p>– 三表龙门阵《<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/R0UVe6WlFntJLQirKAU3qQ">李佳琦的阶级欲望</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>》</p><p>4、</p><p>计算机行业是个很有活力的行业，这个行业创造了很多让人羡慕的职位，比如：1）命令行运维（能够在十个以上的终端窗口来回切换输入命令还不出错）；2）功能程序员（能够一个月做10个以上的功能）；3）周报经理（能够把周报写得左手一条龙右手一个彩虹）；4）PPT架构师（能够在PPT上把架构画成顶尖水平）；5）JS全栈工程师（只掌握JS一门语言，有百年以上足够的耐心等待JS成为所有软件的语言）；6）三句话产品经理（能够下面用三句话就能让开发把产品实现出来，比如：你我们的竞对有！客户就是要！告诉我能不能做？）</p><p>– 左耳朵耗子</p>]]></content>
      
      
      <categories>
          
          <category> 每周分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（4）：谈谈 Activity 的启动模式</title>
      <link href="2019/11/06/android-interview-4-launcher-mode/"/>
      <url>2019/11/06/android-interview-4-launcher-mode/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p><p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p><p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p></blockquote><p>众所周知，Activity 有 4 种启动模式，分别是：standard、singleTop、singleTask 和 singleInstance，它们控制了 Activity 的启动行为，不同的启动模式使用于不同的应用场景。</p><p>启动的 Activity 会放在任务栈中，任务栈是一种后进先出的结构，按 Back 键的时候栈顶 Activity 会从任务栈中返回，当任务栈为空时系统就会回收这个任务栈。 </p><p>本文将通过具体 Demo，详细分析这几种模式的差异和使用场景。</p>        <h2 id="standard-标准模式">          <a href="#standard-标准模式" class="heading-link"><i class="fas fa-link"></i></a>standard 标准模式</h2>      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;standard&quot;</span><br></pre></td></tr></table></div></figure><p>Activity 默认的启动模式，每次启动都会创建新的实例，不管这个实例是否已经存在于任务栈。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动顺序</span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容（adb shell dumpsys activity activities）</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b4e290f #18017 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;1666db1 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18017&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;17fa3e6 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18017&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;9e18184 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18017&#125;</span><br></pre></td></tr></table></div></figure><p>启动两次 StandardActivity 会创建两个 StandardActivity 的实例对象。</p><p><strong>使用场景</strong>：</p><p>在一系列启动 Activity 的过程中需要保留用户操作的 Activity 的页面。比如： 社交应用中，点击查看用户 A 信息 -&gt; 查看用户 A 粉丝 -&gt; 在粉丝中挑选查看用户 B 信息 -&gt; 查看用户 B 粉丝。</p>        <h2 id="singleTop-栈顶复用模式">          <a href="#singleTop-栈顶复用模式" class="heading-link"><i class="fas fa-link"></i></a>singleTop 栈顶复用模式</h2>      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;singleTop&quot;</span><br></pre></td></tr></table></div></figure><p>singleTop 与 standard 几乎一样，使用 singleTop 的 Activity 也可以创建多个实例。不同点在于，如果启动的 Activity 已经位于任务栈的栈顶，则不需要创建新的实例，直接复用栈顶的 Activity 实例，intent 通过 Activity 的<code>onNewIntent</code> 方法传递到这个 Activity 。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">例 1：</span><br><span class="line">&#x2F;&#x2F; 启动顺序</span><br><span class="line">MainActivity -&gt; SingleTopActivity -&gt; SingleTopActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;9de11c2 #18073 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;f0acc0c u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTopActivity t18073&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b884d57 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18073&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">例 2：</span><br><span class="line">&#x2F;&#x2F; 启动顺序</span><br><span class="line">MainActivity -&gt; SingleTopActivity -&gt; StandardActivity -&gt; SingleTopActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;9de11c2 #18073 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;4&#125;</span><br><span class="line">    Run #3: ActivityRecord&#123;c282b33 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTopActivity t18073&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;76fb23e u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18073&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;b6969a8 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTopActivity t18073&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b884d57 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18073&#125;</span><br></pre></td></tr></table></div></figure><p>例 1 中由于栈顶已经是 SingleTopActivity，再启动 SingleTopActivity 时直接复用了栈顶 Activity，无需创建新的实例。</p><p>例 2 中第二次启动 SingleTopActivity 时，由于栈顶是 StandardActivity，所以启动 SingleTopActivity 时会创建新的实例。</p><p><strong>使用场景</strong>：</p><p>假设你在当前的 Activity 中又要启动同类型的 Activity，此时建议将此类型 Activity 的启动模式指定为 singleTop，能够减少 Activity 的创建，节省内存。</p>        <h2 id="singleTask-栈内复用模式">          <a href="#singleTask-栈内复用模式" class="heading-link"><i class="fas fa-link"></i></a>singleTask 栈内复用模式</h2>      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;singleTask&quot; </span><br></pre></td></tr></table></div></figure><p>singleTask 标记的 Activity 是栈内复用模式，如果当前任务栈内没有这个 Activity，那么创建新的 Activity，如果当前任务栈内有这个 Activity，不管它在任务栈的哪个位置，都会直接复用这个 Activity，这个 Activity 上面的其他的 Activity 都被移出栈， intent 通过 <code>onNewIntent</code> 传递到这个 Activity 。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容：</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;ebb2593 #18095 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;49b6bb8 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18095&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;48628d2 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskActivity t18095&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;86fe71f u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18095&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskActivity -&gt; StandardActivity -&gt; SingleTaskActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;ebb2593 #18095 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;48628d2 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskActivity t18095&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;86fe71f u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18095&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到，在第二次启动 SingleTaskActivity 时，由于栈内已经存在了 SingleTaskActivity  实例，栈顶 StandardActivity 被移出任务栈，复用了栈内 SingleTaskActivity 实例。</p><p>当以 singleTask 启动一个 Activity 的时候，首先去判断是否要为该 Activity 去创建一个任务栈？如果需要的话，那么就会创建一个任务栈，并且将该 Activity 放入栈中；如果不需要的话，直接将该 Activity 放入当前的任务栈中。 </p><p>那么如何判断要不要为 singleTask Activity 创建一个任务栈？</p><p>任务栈的创建跟 taskAffinity 的属性相关，每个 Activity 都有 taskAffinity 属性，这个属性指出了它希望进入的任务栈。如果一个 Activity 没有显式的指明该 Activity 的 taskAffinity，那么它的这个属性就等于 Application 指明的 taskAffinity，如果 Application 也没有指明，那么该 taskAffinity 的值就等于包名。</p><p>这里我指定一下 Activity 的 taskAffinity ：</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SingleTaskWithAffinityActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;SingleTaskWithAffinity Activity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.jaqen&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure><p>看一下测试结果：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 任务栈</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;fa7e695 #18097 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;6267f33 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskWithAffinityActivity t18097&#125;</span><br><span class="line">    TaskRecord&#123;efcc3aa #18096 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;ccdada8 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18096&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskWithAffinityActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;3f4af35 #18097 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;23b4c1a u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18097&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;d234ee0 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskWithAffinityActivity t18097&#125;</span><br><span class="line">    TaskRecord&#123;e27d53b #18096 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;f445d23 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18096&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskWithAffinityActivity -&gt; StandardActivity -&gt; SingleTaskWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;3f4af35 #18097 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;d234ee0 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskWithAffinityActivity t18097&#125;</span><br><span class="line">    TaskRecord&#123;e27d53b #18096 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;f445d23 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18096&#125;</span><br></pre></td></tr></table></div></figure><p>首次启动 SingleTaskWithAffinityActivity 会创建新的任务栈（<em>大括号内 <code>#</code> 后的数字标识任务栈 id</em>）。</p><p>在 SingleTaskWithAffinityActivity 启动 StandardActivity ， 这个 StandardActivity 与 SingleTaskWithAffinityActivity 在同一个栈。</p><p>SingleTaskWithAffinityActivity  会出现在多任务界面。</p><p>第二次启动 SingleTopActivity 时直接复用了栈内已存 Activity，已存 Activity 上的 Activity 被移出任务栈。</p><p><strong>使用场景</strong>：</p><p>一般应用主页面可以用 singleTask 方式。比如用户在主页跳转到其他页面，运行多次操作后想返回到主页。</p>        <h2 id="singleInstance-单实例模式">          <a href="#singleInstance-单实例模式" class="heading-link"><i class="fas fa-link"></i></a>singleInstance 单实例模式</h2>      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;singleInstance&quot;</span><br></pre></td></tr></table></div></figure><p>singleInstance 与 singleTask 类似，在应用都只存在一个实例，不同点在于存放 singleInstance Activity 实例的任务栈只能存放唯一的 singleInstance Activity。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动顺序</span><br><span class="line">MainActivity -&gt; SingleInstanceActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;cd22626 #18116 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;462d9a2 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleInstanceActivity t18116&#125;</span><br><span class="line">    TaskRecord&#123;c2b08bd #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;812c79c u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18115&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动顺序</span><br><span class="line">MainActivity -&gt; SingleInstanceActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;540b885 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18115&#125;</span><br><span class="line">    TaskRecord&#123;5cab9d7 #18116 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;18780a3 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleInstanceActivity t18116&#125;</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;6ceacf3 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18115&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动顺序</span><br><span class="line">MainActivity -&gt; SingleInstanceActivity -&gt; StandardActivity -&gt; SingleInstanceActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;540b885 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18115&#125;</span><br><span class="line">    TaskRecord&#123;5cab9d7 #18116 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;18780a3 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleInstanceActivity t18116&#125;</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;6ceacf3 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18115&#125;</span><br></pre></td></tr></table></div></figure><p>启动 SingleInstanceActivity 会创建新的任务栈，从 SingleInstanceActivity 中启动 StandardActivity，StandardActivity 会被放到上一个任务栈中。</p><p>再此启动 SingleInstanceActivity，SingleInstanceActivity 会被复用。</p><p><strong>使用场景</strong>：</p><p>singleInstance 模式常应用于独立栈操作的应用，如闹钟的提醒页面，当你在A应用中看视频时，闹钟响了，你点击闹钟提醒通知后进入提醒详情页面，然后点击返回就再次回到A的视频页面，这样就不会过多干扰到用户先前的操作了。 </p>        <h2 id="Intent-Flags">          <a href="#Intent-Flags" class="heading-link"><i class="fas fa-link"></i></a>Intent Flags</h2>      <p> 除了在 manifest 文件中设置 launchMode 之外，还可以在 Intent 中设置 Flag 达到同样的效果。</p><p>常见几种 Flag：</p><p>1、<strong>FLAG_ACTIVITY_NEW_TASK</strong></p><p> 在 google 的官方文档中介绍，它与 <code>launchMode=&quot;singleTask&quot;</code> 具有相同的行为。实际上，并不是完全相同！具体看下面的案例分析。 </p><p>2、<strong>FLAG_ACTIVITY_SINGLE_TOP</strong></p><p> 等同于 <code>launchMode=&quot;singleTop&quot;</code> 。</p><p>3、<strong>FLAG_ACTIVITY_CLEAR_TOP</strong></p><p> 清除包含目标 Activity 的任务栈中位于该 Activity 实例之上的其他 Activity 实例。 但是是复用已有的目标 Activity，还是先删除后重建，则有以下规则： </p><ul><li><p>若是使用 FLAG_ACTIVITY_SINGLE_TOP 和 FLAG_ACTIVITY_CLEAR_TOP 标志位组合，那么不管目标 Activity 是什么启动模式，都会被复用。 </p></li><li><p>若是单独使用 FLAG_ACTIVITY_CLEAR_TOP，那么只有非 standard 启动模式的目标 Activity 才会被复用，否则都先被删除，然后被重新创建并入栈。 </p></li></ul><p>4、<strong>FLAG_ACTIVITY_CLEAR_TASK</strong> </p><p>首先清空已经存在的目标 Activity 实例所在的任务栈，这自然也就清除了之前存在的目标 Activity 实例，然后创建新的目标 Activity 实例并入栈。</p><p>通过几个案例查看 Flag 的使用效果。</p><ul><li><p>MainActivity 为 standard 模式，未设置 Flag。</p></li><li><p>IntentFlagTestActivity 为 standard 模式，未设置 taskAffinity。</p></li></ul><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;.IntentFlagTestActivity&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:label</span>=<span class="string">&quot;IntentFlagTestActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>IntentFlagTestWithAffinityActivity 为 standard 模式，设置与 MainActivity 不同的 taskAffinity。 </li></ul><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.IntentFlagTestWithAffinityActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.jaqen&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;IntentFlagTestWithAffinityActivity&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></div></figure>        <h3 id="1、单独使用-FLAG-ACTIVITY-NEW-TASK">          <a href="#1、单独使用-FLAG-ACTIVITY-NEW-TASK" class="heading-link"><i class="fas fa-link"></i></a>1、单独使用 FLAG_ACTIVITY_NEW_TASK</h3>      <ul><li>taskAffinity 相同时：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>测试结果：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">TaskRecord&#123;89317d5 #18128 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;4&#125;</span><br><span class="line">Run #3: ActivityRecord&#123;2f1ac92 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18128&#125;</span><br><span class="line">Run #2: ActivityRecord&#123;a0104eb u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18128&#125;</span><br><span class="line">Run #1: ActivityRecord&#123;9b84b56 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18128&#125;</span><br><span class="line">Run #0: ActivityRecord&#123;f9a57f4 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18128&#125;</span><br></pre></td></tr></table></div></figure><p>从任务栈可以看出，在  taskAffinity 相同的情况下，单独使用 FLAG_ACTIVITY_NEW_TASK 不会产生任何效果！</p><ul><li>taskAffinity 不同时：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestWithAffinityActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestWithAffinityActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>测试结果：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;d07e70 #18135 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;997119c u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18135&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;8a7f641 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18135&#125;</span><br><span class="line">    TaskRecord&#123;84f526e #18134 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5aca49d u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18134&#125;</span><br></pre></td></tr></table></div></figure><p>在 taskAffinity 不同的情况下， 添加 FLAG_ACTIVITY_NEW_TASK 确实产生了一些效果，第一次启动 IntentFlagTestWithAffinityActivity 创建了新的任务栈，但是第二次从 MainActivity 中启动 IntentFlagTestWithAffinityActivity  时，没有任何反应。</p><p><strong>结论：</strong></p><p><strong>单独使用 FLAG_ACTIVITY_NEW_TASK 并不会产生与 singleTask 相同的效果</strong>。</p>        <h3 id="2、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TOP">          <a href="#2、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TOP" class="heading-link"><i class="fas fa-link"></i></a>2、FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TOP</h3>      <ul><li>taskAffinity 相同时：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>测试结果：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity -&gt; MainActivity</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7bb1982 #18139 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;535c0d0 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18139&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c5253ff u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18139&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;1b04db1 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18139&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7bb1982 #18139 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;705bf3 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18139&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;1b04db1 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18139&#125;</span><br></pre></td></tr></table></div></figure><p>在 taskAffinity 相同情况下，FLAG_ACTIVITY_NEW_TASK  + FLAG_ACTIVITY_CLEAR_TOP 不会创建新的任务栈。</p><p>貌似和 singleTask 启动模式效果相同，但是细看会发现区别：前后两次 IntentFlagTestActivity 并不是同一个实例，也就是并没有复用栈内的 IntentFlagTestActivity，而是清除了 IntentFlagTestActivity 本身及其之上的所有 Activity，然后新建 IntentFlagTestActivity 实例添加到当前任务栈。</p><ul><li>taskAffinity 不同时：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestWithAffinityActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestWithAffinityActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>测试结果：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 任务栈</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;a1b1a38 #18152 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;ae8c352 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18152&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;5647f4a u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18152&#125;</span><br><span class="line">    TaskRecord&#123;e2f8776 #18151 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;864a2f5 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18151&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line">    </span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;a1b1a38 #18152 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;cf5fce6 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18152&#125;</span><br><span class="line">    TaskRecord&#123;e2f8776 #18151 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;864a2f5 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18151&#125;</span><br></pre></td></tr></table></div></figure><p>可见，与 taskAffinity 相同类似（除了创建新的任务栈），在第二次启动 IntentFlagTestWithAffinityActivity 时也是直接清除了 IntentFlagTestWithAffinityActivity 自身及其之上所有的 Activity，然后创建新的 IntentFlagTestWithAffinityActivity 实例添加到任务栈中。</p><p><strong>结论：</strong></p><p><strong><code>FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TOP</code> 标志位组合产生的效果总体上和 singleTask 模式相同，但不会复用 Activity。</strong></p>        <h3 id="3、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TASK">          <a href="#3、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TASK" class="heading-link"><i class="fas fa-link"></i></a>3、FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TASK</h3>      <ul><li>taskAffnity 相同时：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>测试结果:</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;572ae8d #18253 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;e0aa3a u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18253&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;572ae8d #18253 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;65fb5c2 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18253&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;e0aa3a u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18253&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;572ae8d #18253 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;9eccfa3 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18253&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>可见， 当通过<code>FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TASK </code> 标志位组合启动 IntentFlagTestActivity 时，首先会清空 IntentFlagTestActivity 所在的任务栈，然后再创建新的 IntentFlagTestActivity 实例并入栈。 </p><ul><li>taskAffnity 不同时：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestWithAffinityActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestWithAffinityActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>测试结果:</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;c081b17 #18257 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;8f8a3c5 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18257&#125;</span><br><span class="line">    TaskRecord&#123;60908ed #18256 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5924b86 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18256&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;c081b17 #18257 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;7e1a8a0 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18257&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;8f8a3c5 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18257&#125;</span><br><span class="line">    TaskRecord&#123;60908ed #18256 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5924b86 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18256&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;c081b17 #18257 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;e52a3c0 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18257&#125;</span><br><span class="line">    TaskRecord&#123;60908ed #18256 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5924b86 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18256&#125;</span><br></pre></td></tr></table></div></figure><p>结果与 taskAffnity 相同情况下类似， 首先会清空 IntentFlagTestWithAffinityActivity 所在的任务栈，然后再创建新的 IntentFlagTestWithAffinityActivity 实例并入栈，这和 taskAffinity 属性相同是一致的效果，只不过这里第一次为 IntentFlagTestWithAffinityActivity 创建了新的任务栈。 </p><p><strong>结论：</strong></p><p><strong><code>FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TASK </code> 标志位组会先清空任务栈，再创建新的 Activity 实例入栈。</strong></p>        <h3 id="4、单独使用-FLAG-ACTIVITY-CLEAR-TOP">          <a href="#4、单独使用-FLAG-ACTIVITY-CLEAR-TOP" class="heading-link"><i class="fas fa-link"></i></a>4、单独使用 FLAG_ACTIVITY_CLEAR_TOP</h3>      <ul><li>IntentFlagTestActivity 启动模式：standard</li></ul><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b6045f3 #18282 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;44dcf5f u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18282&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;c713f21 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b6045f3 #18282 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;13c806b u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;44dcf5f u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18282&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;c713f21 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b6045f3 #18282 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;fa6320c u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18282&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;c713f21 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br></pre></td></tr></table></div></figure><ul><li>IntentFlagTestActivity 启动模式：singleTask</li></ul><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7c9d493 #18280 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;daafb1e u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18280&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b547fca u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7c9d493 #18280 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;511762c u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;daafb1e u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18280&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b547fca u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7c9d493 #18280 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;daafb1e u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18280&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b547fca u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br></pre></td></tr></table></div></figure><p>从上面两个例子看出，单独使用 FLAG_ACTIVITY_CLEAR_TOP 时，</p><p>standard 启动模式下，目标 Activity 自身及其上的 Activity 都会被销毁，目标 Activity 自身会重新创建放入栈中；singleTask 启动模式下，先销毁目标 Activity 之上的所有 Activity，然后复用已有的 Activity。</p><p>此外，singleTop、singleInstance 与 singleTask 一样，都会复用已有 Activity。这里不在赘述。</p><p><strong>结论：</strong></p><p><strong>单独使用 FLAG_ACTIVITY_CLEAR_TOP，那么只有非 standard 启动模式的目标 Activity 才会被复用，否则都先被删除，然后被重新创建并入栈。</strong></p>        <h3 id="5、FLAG-ACTIVITY-CLEAR-TOP-FLAG-ACTIVITY-SINGLE-TOP">          <a href="#5、FLAG-ACTIVITY-CLEAR-TOP-FLAG-ACTIVITY-SINGLE-TOP" class="heading-link"><i class="fas fa-link"></i></a>5、FLAG_ACTIVITY_CLEAR_TOP  + FLAG_ACTIVITY_SINGLE_TOP</h3>      <ul><li>IntentFlagTestActivity 启动模式 standard</li></ul><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;bf65b55 #18326 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c62eb86 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18326&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;eb38b03 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;bf65b55 #18326 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;be92d5b u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c62eb86 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18326&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;eb38b03 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;bf65b55 #18326 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c62eb86 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18326&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;eb38b03 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br></pre></td></tr></table></div></figure><p><code>FLAG_ACTIVITY_CLEAR_TOP  + FLAG_ACTIVITY_SINGLE_TOP</code> 标志位组合情况， standard 模式下的 IntentFlagTestActivity 被复用了， 那么其他启动模式的 Activity 也必然会被复用。（单独使用 FLAG_ACTIVITY_CLEAR_TOP 都会被复用，何况又添加了 FLAG_ACTIVITY_SINGLE_TOP 标志位，通过 Demo 验证也确实如此，就不再给出具体案例了）。 </p><p><strong>结论：</strong></p><p><strong>使用 FLAG_ACTIVITY_SINGLE_TOP 和 FLAG_ACTIVITY_CLEAR_TOP 标志位组合，那么不管目标 Activity 是什么启动模式，都会被复用。</strong> </p><p>OK，Activity 启动模式相关的内容就介绍这些，希望感兴趣的朋友有帮助。</p><p>Demo 我已经放在了 GitHub 上，有兴趣可以下载下来，运行看看结果。</p><p> <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidLaunchModeTest">https://github.com/zywudev/AndroidLaunchModeTest</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
            <tag> Android面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（3）：回答一下什么是强、软、弱、虚引用以及它们之间的区别？</title>
      <link href="2019/10/30/android-interview-3-java-reference/"/>
      <url>2019/10/30/android-interview-3-java-reference/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p><p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p><p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p></blockquote><p>从 JDK1.2 版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>        <h4 id="1、强引用（Strong-Reference）">          <a href="#1、强引用（Strong-Reference）" class="heading-link"><i class="fas fa-link"></i></a>1、强引用（Strong Reference）</h4>      <p>强引用就是我们经常使用的引用，其写法如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></div></figure><p><strong>特点</strong>：</p><ul><li>只要还有强引用指向一个对象，垃圾收集器就不会回收这个对象。</li><li>显式地设置 o 为 null，或者超出对象的生命周期，此时就可以回收这个对象。具体回收时机还是要看垃圾收集策略。</li><li>在不用对象的时将引用赋值为 null，能够帮助垃圾回收器回收对象。比如  ArrayList 的 clear() 方法实现：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2、软引用（Soft-Reference）">          <a href="#2、软引用（Soft-Reference）" class="heading-link"><i class="fas fa-link"></i></a>2、软引用（Soft Reference）</h4>      <p>如果一个对象只具有软引用，在内存足够时，垃圾回收器不会回收它；如果内存不足，就会回收这个对象的内存。</p><p>使用场景：</p><ul><li>图片缓存。图片缓存框架中，“内存缓存”中的图片是以这种引用保存，使得  JVM 在发生 OOM 之前，可以回收这部分缓存。</li><li>网页缓存。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Browser prev = <span class="keyword">new</span> Browser();               <span class="comment">// 获取页面进行浏览</span></span><br><span class="line">SoftReference sr = <span class="keyword">new</span> SoftReference(prev); <span class="comment">// 浏览完毕后置为软引用</span></span><br><span class="line"><span class="keyword">if</span>(sr.get()!=<span class="keyword">null</span>) &#123; </span><br><span class="line">rev = (Browser) sr.get();           <span class="comment">// 还没有被回收器回收，直接获取</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev = <span class="keyword">new</span> Browser();               <span class="comment">// 由于内存吃紧，所以对软引用的对象回收了</span></span><br><span class="line">sr = <span class="keyword">new</span> SoftReference(prev);       <span class="comment">// 重新构建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3、弱引用（Weak-Reference）">          <a href="#3、弱引用（Weak-Reference）" class="heading-link"><i class="fas fa-link"></i></a>3、弱引用（Weak Reference）</h4>      <p>简单来说，就是将对象留在内存的能力不是那么强的引用。当垃圾回收器扫描到只具有弱引用的对象，不管当前内存空间是否足够，都会回收内存。</p><p><strong>使用场景</strong>：</p><p>在下面的代码中，如果类 B 不是虚引用类 A 的话，执行 main 方法会出现内存泄漏的问题， 因为类 B 依然依赖于 A。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(b.getA());  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WeakReference&lt;A&gt; weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weakReference.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在静态内部类中，经常会使用虚引用。例如：一个类发送网络请求，承担 callback 的静态内部类，则常以虚引用的方式来保存外部类的引用，当外部类需要被 JVM 回收时，不会因为网络请求没有及时回应，引起内存泄漏。</p>        <h4 id="4、虚引用（Phantom-Reference）">          <a href="#4、虚引用（Phantom-Reference）" class="heading-link"><i class="fas fa-link"></i></a>4、虚引用（Phantom Reference）</h4>      <p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue refQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj,refQueue);</span><br></pre></td></tr></table></div></figure><p><strong>使用场景</strong>：</p><p>可以用来跟踪对象呗垃圾回收的活动。一般可以通过虚引用达到回收一些非java内的一些资源比如堆外内存的行为。例如：在 DirectByteBuffer 中，会创建一个 PhantomReference 的子类 Cleaner 的虚引用实例用来引用该 DirectByteBuffer 实例，Cleaner 创建时会添加一个 Runnable 实例，当被引用的 DirectByteBuffer 对象不可达被垃圾回收时，将会执行 Cleaner 实例内部的 Runnable 实例的 run 方法，用来回收堆外资源。</p>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
            <tag> Android面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（2）：一般什么情况下会导致内存泄漏问题？</title>
      <link href="2019/10/24/android-interview-2-memory-leak-case/"/>
      <url>2019/10/24/android-interview-2-memory-leak-case/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p><p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p><p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p></blockquote><p>内存泄漏也是面试常见问题，主要可以考察面试者是否了解内存泄漏，工作中是如何排查解决内存泄漏问题，还可以延伸考察 Java 内存回收机制，Java 中对象的引用方式等等。</p><p>这篇文章先来介绍下 Android 开发中常见的内存泄漏案例以及相应的解决方案。</p>        <h2 id="单例造成的内存泄漏">          <a href="#单例造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>单例造成的内存泄漏</h2>      <p>单例模式在 Android 开发中使用率非常高，但使用不恰当的话也会造成内存泄漏。比如下面的代码：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> Singleton(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>单例类对象的生命周期与应用的周期一样长，如果传入的是 Activity 的 Context，在 Activity 退出时，因单例对象持有 Activity 的引用，导致 Activity 的内存不能被回收，即内存泄漏。</p><p><strong>解决方案</strong>：</p><p>1）使用 Application 的 Context，生命周期一致；</p><p>2）将短生命周期的属性的引用方式改为弱引用。</p>        <h2 id="非静态内部类造成的内存泄漏">          <a href="#非静态内部类造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>非静态内部类造成的内存泄漏</h2>      <p>非静态内部类持有外部类的引用，如果外部类的实例已经结束生命周期，但内部类仍然在执行，就会导致外部类不能被回收。比如上一期讲解的自定义 Handler 的使用造成的内存泄漏，主要原因 Activity 退出时，Handler 仍然持有 Activity 的引用，导致 Activity 不能被回收。</p><p><strong>解决方案</strong>：</p><p>1） 创建一个静态内部类，然后外部类的对象引用使用弱引用；</p><p>2）及时关闭耗时或者延时任务，在 Activity 被销毁时及时清除消息，从而及时回收 Activity，避免内存泄漏问题。 </p>        <h2 id="系统服务注册未取消造成的内存泄漏">          <a href="#系统服务注册未取消造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>系统服务注册未取消造成的内存泄漏</h2>      <p>系统服务可以通过 <code>Context.getSystemService</code> 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 Context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有 Activity 的引用，如果在 Activity 的 <code>onDestory()</code> 函数中没有释放掉引用就会内存泄漏。 </p><p><strong>解决方案</strong>：</p><p>1）使用 Application 的 Context 代替 Activity 的 Context；</p><p>2）在 Activity 的 <code>onDestory()</code> 方法，调用反注册释放。</p>        <h2 id="全局集合类造成的内存泄漏">          <a href="#全局集合类造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>全局集合类造成的内存泄漏</h2>      <p>一般情况下集合类不会造成内存泄漏，但如果是全局性的集合，如果在使用完毕后未进行 remove 清理操作，就很有可能造成内存泄漏，所以在集合不需要的时候要及时清理集合元素。</p>        <h2 id="资源未关闭的内存泄漏">          <a href="#资源未关闭的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>资源未关闭的内存泄漏</h2>      <p> 对于使用了 BroadcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap 等资源，应该在 Activity 销毁时及时关闭或者注销。</p>        <h2 id="WebView-造成的内存泄漏">          <a href="#WebView-造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>WebView 造成的内存泄漏</h2>      <p> WebView 存在内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。</p><p><strong>解决方案</strong>：</p><p>为 WebView 开启一个独立的进程，使用 AIDL 与应用的主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。 </p>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <p>总的来说就是生命周期长的对象持有了生命周期短的对象，导致生命周期短的对象在回收时无法被释放，就会导致内存泄漏。</p><p>了解常见内存泄漏及解决方案，能够帮助我们在开发中尽量少的出现内存泄漏问题。但有些内存泄漏的定位排查比较困难，需要借助一些工具，比如 LeakCanary、MAT 等。内存泄漏的排查定位方法会在后续文章中介绍，欢迎持续关注。</p>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题（1）：使用 Handler 时如何有效地避免内存泄漏问题？</title>
      <link href="2019/10/23/android-interview-1-how-handler-avoid-memory-leaks/"/>
      <url>2019/10/23/android-interview-1-how-handler-avoid-memory-leaks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p><p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p><p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p></blockquote>        <h2 id="什么是内存泄漏？">          <a href="#什么是内存泄漏？" class="heading-link"><i class="fas fa-link"></i></a>什么是内存泄漏？</h2>      <p>Java 中采用可达性分析算法判断一个对象是否可被回收。</p><p>基本思路是这样的：</p><p>通过一系列称为 “GC Roots” 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。</p><p>可作为 GC Roots 的对象有：</p><ul><li><p>虚拟机栈中的引用的对象</p></li><li><p>方法区的静态变量和常量引用的对象</p></li><li><p>本地方法栈中 JNI 引用的对象</p></li></ul><p><strong>当一个对象不需要在再使用了，本该被回收时， 而另外一个正在使用的对象持有它的引用从而导致它不能被回收，这就导致本该被回收的对象不能被回收而停留在堆内存中，内存泄漏就产生了。</strong> </p>        <h2 id="Handler-是如何造成内存泄漏的？">          <a href="#Handler-是如何造成内存泄漏的？" class="heading-link"><i class="fas fa-link"></i></a>Handler 是如何造成内存泄漏的？</h2>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 耗时任务</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p> 上面是一段简单的 Handler 的使用。 这种方式有可能造成内存泄漏吗？答案是有可能的。我们来分析下造成内存泄漏的原因？</p><p>我们知道 Java中非静态内部类会隐式持有外部类的引用，所以这里创建的 Handler 隐式持有外部类 MainActivity 的引用。</p><p>而 Handler 一般用来处理后台线程任务的执行结果，如果在线程任务之慈宁宫过程中，用户关闭了 Activity，此时线程尚未执行完，而该线程持有 Handler 的引用，Handler 又持有 Activity 的引用，就导致了 Activity 无法被回收（即内存泄漏）。</p><p>还有一种情况，如果你调用 Handler 的 <code>postDelay()</code> 方法执行了延时任务， 该方法会将你的Handler 装入一个 Message，并把这条 Message 推到 MessageQueue 中，那么在你设定的 delay 到达之前，会有一条 MessageQueue -&gt; Message -&gt; Handler -&gt; Activity 的链，导致你的 Activity 被持有引用而无法被回收。 </p>        <h2 id="如果解决-Handler-导致的内存泄漏问题？">          <a href="#如果解决-Handler-导致的内存泄漏问题？" class="heading-link"><i class="fas fa-link"></i></a>如果解决 Handler 导致的内存泄漏问题？</h2>      <p><strong>方法 1、静态内部类 + 弱引用</strong></p><p>既然非静态内部类持有外部类的引用，那么可以将 Handler 声明为静态内部类，Handler 也就不再持有 Activity 的引用，所以 Activity 可以随便被回收。代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>此时 Handler 不再持有 Activity 的引用，导致 Handler 无法操作 Activity 中对象，所以可以在 Handler 中添加一个对 Activity 的弱引用（ WeakReference ）：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    WeakReference&lt;Activity &gt; mActivityReference;</span><br><span class="line"></span><br><span class="line">    MyHandler(Activity activity) &#123;</span><br><span class="line">        mActivityReference= <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Activity activity = mActivityReference.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>弱引用的特点是： 在垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 所以用户在关闭 Activity 之后，就算后台线程还没结束，但由于仅有一条来自 Handler 的弱引用指向 Activity，Activity 也会被回收掉。这样，内存泄露的问题就不会出现了。 </p><p><strong>方法2： 通过程序逻辑来进行保护</strong></p><p> 在 Activity 被销毁时及时清除消息，从而及时回收 Activity，避免内存泄漏问题。 </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>)  &#123;</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Android面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ijkplayer 编译实践</title>
      <link href="2019/10/14/compile-ijkplayer/"/>
      <url>2019/10/14/compile-ijkplayer/</url>
      
        <content type="html"><![CDATA[<p>记录 ijkplayer 的编译过程，以及遇到的问题，有需要的朋友可以参考。</p>        <h2 id="编译环境">          <a href="#编译环境" class="heading-link"><i class="fas fa-link"></i></a>编译环境</h2>              <h3 id="Linux-环境">          <a href="#Linux-环境" class="heading-link"><i class="fas fa-link"></i></a>Linux 环境</h3>      <p>由于主机是 Windows 系统，所以使用 VMware 安装了 Ubuntu 18.0.4 系统。</p><p>VMware 安装 Ubuntu 系统的安装步骤网上非常多，这篇文章比较详细，没有经验的可以参考。</p><p><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/38797088">https://zhuanlan.zhihu.com/p/38797088</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="Android-SDK">          <a href="#Android-SDK" class="heading-link"><i class="fas fa-link"></i></a>Android SDK</h3>      <p>下载地址：<span class="exturl"><a class="exturl__link" href="https://developer.android.com/studio#downloads">https://developer.android.com/studio#downloads</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="Android-NDK">          <a href="#Android-NDK" class="heading-link"><i class="fas fa-link"></i></a>Android NDK</h3>      <p>下载地址：<span class="exturl"><a class="exturl__link" href="https://developer.android.google.cn/ndk/downloads/older_releases.html">https://developer.android.google.cn/ndk/downloads/older_releases.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>注意 NDK 的最小版本支持是 10e，目前不支持 NDK 15！我这边下载的是 <code>android-ndk-r14b</code>。</p><p>Android SDK 和 Android NDK 下载解压后，需要配置环境变量，可以参考我写的这篇文章。</p><p><a href="http://wuzhangyang.com/2019/10/14/ubuntu-android-studio/">http://wuzhangyang.com/2019/10/14/ubuntu-android-studio/</a></p>        <h3 id="安装-git-和-yasm">          <a href="#安装-git-和-yasm" class="heading-link"><i class="fas fa-link"></i></a>安装 git 和 yasm</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt install yasm</span><br></pre></td></tr></table></div></figure><p>注意，如果安装报错，先要执行 <code>sudo apt update</code> 进行更新。</p>        <h2 id="开始编译">          <a href="#开始编译" class="heading-link"><i class="fas fa-link"></i></a>开始编译</h2>              <h3 id="拉取-ijkplayer-源码">          <a href="#拉取-ijkplayer-源码" class="heading-link"><i class="fas fa-link"></i></a>拉取 ijkplayer 源码</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br><span class="line">cd ijkplayer-android</span><br><span class="line">git checkout -B latest k0.8.8</span><br></pre></td></tr></table></div></figure>        <h3 id="初始化-android">          <a href="#初始化-android" class="heading-link"><i class="fas fa-link"></i></a>初始化 android</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android.sh</span><br></pre></td></tr></table></div></figure>        <h3 id="初始化-openssl-支持-https">          <a href="#初始化-openssl-支持-https" class="heading-link"><i class="fas fa-link"></i></a>初始化 openssl 支持 https</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android-openssl.sh</span><br></pre></td></tr></table></div></figure>        <h3 id="配置编解码器格式支持">          <a href="#配置编解码器格式支持" class="heading-link"><i class="fas fa-link"></i></a>配置编解码器格式支持</h3>      <p>默认为最少支持，如果足够你使用，可以跳过这一步，否则可以改为以下配置:</p><ul><li><p><code>module-default.sh</code> 更多的编解码器/格式</p></li><li><p><code>module-lite-hevc.sh</code> 较少的编解码器/格式(包括 hevc)</p></li><li><p><code>module-lite.sh</code> 较少的编解码器/格式(默认情况)</p></li></ul><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 config 目录</span></span><br><span class="line">cd config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前的 module.sh 文件</span></span><br><span class="line">rm module.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建软链接 module.sh 指向 module-default.sh</span></span><br><span class="line">ln -s module-default.sh module.sh</span><br></pre></td></tr></table></div></figure>        <h3 id="编译-openssl">          <a href="#编译-openssl" class="heading-link"><i class="fas fa-link"></i></a>编译 openssl</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 android/contrib 目录</span></span><br><span class="line">cd android/contrib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除 openssl 的编译文件</span></span><br><span class="line">./compile-openssl.sh clean</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 openssl</span></span><br><span class="line">./compile-openssl.sh all</span><br></pre></td></tr></table></div></figure><p><code>./compile-openssl.sh</code> 后跟 <code>all</code> 表示编译所有 CPU 架构的 so 库， 如果只编译指定 CPU 架构的 so 库，后面就跟 CPU 架构，比如：<code>./compile-ffmpeg.sh armv7a</code>。</p><p>这里，在执行 <code>./compile-openssl.sh all</code> 时出现了编译错误：<strong>ERROR: Failed to create toolchain.</strong></p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">jaqen@jaqen-virtual-machine:~/Android/Projects/ijkplayer-android/android/contrib$ ./compile-openssl.sh all</span><br><span class="line">====================</span><br><span class="line">[*] check archs</span><br><span class="line">====================</span><br><span class="line">FF_ALL_ARCHS = armv5 armv7a arm64 x86 x86_64</span><br><span class="line">FF_ACT_ARCHS = armv5 armv7a arm64 x86 x86_64</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">[*] make NDK standalone toolchain</span><br><span class="line">--------------------</span><br><span class="line">build on Linux x86_64</span><br><span class="line">ANDROID_NDK=/home/jaqen/Android/Sdk/android-ndk-r14b</span><br><span class="line">IJK_NDK_REL=14.1.3816874</span><br><span class="line">NDKr14.1.3816874 detected</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">[*] make NDK standalone toolchain</span><br><span class="line">--------------------</span><br><span class="line">build on Linux x86_64</span><br><span class="line">ANDROID_NDK=/home/jaqen/Android/Sdk/android-ndk-r14b</span><br><span class="line">IJK_NDK_REL=14.1.3816874</span><br><span class="line">NDKr14.1.3816874 detected</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_EXE=</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_TAG=linux-x86_64</span><br><span class="line">HOST_NUM_CPUS=4</span><br><span class="line">BUILD_NUM_CPUS=8</span><br><span class="line">Auto-config: --arch=arm</span><br><span class="line">ERROR: Failed to create toolchain.</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>解决办法是安装 python 后再执行编译。</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python</span><br></pre></td></tr></table></div></figure>        <h3 id="编译-ffmpeg">          <a href="#编译-ffmpeg" class="heading-link"><i class="fas fa-link"></i></a>编译 ffmpeg</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清除 ffmpeg 的编译文件</span></span><br><span class="line">./compile-ffmpeg.sh clean</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 ffmpeg</span></span><br><span class="line">./compile-ffmpeg.sh all</span><br></pre></td></tr></table></div></figure><p>执行 <code>./compile-ffmpeg.sh all</code> 时出现编译错误：<strong>linux/perf_event.h: No such file or directory</strong>。</p><p>解决办法是在 <code>config</code> 文件夹下的 <code>module.sh</code> 文件中加入下面两句：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-bzlib&quot;</span><br></pre></td></tr></table></div></figure><p>再重新执行编译。</p>        <h3 id="编译-ijkplayer">          <a href="#编译-ijkplayer" class="heading-link"><i class="fas fa-link"></i></a>编译 ijkplayer</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 android 目录</span></span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 ijkplayer</span></span><br><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></div></figure><p> 编译完成之后，在 <code>android/ijkpleyer</code> 文件夹的对应架构文件下，在<code>/src/main/libs/架构名/</code>下生成<code>libijkplayer.so</code>、<code>libijkffmpeg.so</code>、<code>libijksdl.so</code> 三个文件。 </p><p><img src="/2019/10/14/compile-ijkplayer/ijkplayer_so.png" alt="ijkplayer_so"></p><p>至此，ijkplayer 的编译工作就全部完成了。</p><p>编译过程中遇到问题的朋友欢迎留言交流。</p><p>不想编译的朋友，可以在公众号 「贾小昆」后台回复 <code>ijk</code> 获取 so 包。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
            <tag> ijkplayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 下 Android Studio 安装与配置</title>
      <link href="2019/10/14/ubuntu-android-studio/"/>
      <url>2019/10/14/ubuntu-android-studio/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录一下 Ubuntu 环境下 Android Studio 的安装和配置，方便查找使用。</p>        <h2 id="Android-Studio-安装">          <a href="#Android-Studio-安装" class="heading-link"><i class="fas fa-link"></i></a>Android Studio 安装</h2>      <p>Android Studio 下载地址：</p><p><span class="exturl"><a class="exturl__link" href="https://developer.android.com/studio">https://developer.android.com/studio</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>下载后，直接解压即可。</p><p>然后进入 <code>/android-studio/bin/</code> 文件下，会看到一个<code>studio.sh</code>的执行文件。</p><p><img src="/2019/10/14/ubuntu-android-studio/ubuntu_android_studio1.png" alt="ubuntu_android_studio1"></p><p>终端命令进入 <code>/android-studio/bin/ </code> , 执行命令 <code>./studio.sh</code> ，进行安装即可，没啥好说的。</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd android-studio/bin</span><br><span class="line">./studio.sh</span><br></pre></td></tr></table></div></figure>        <h2 id="Android-Studio-配置">          <a href="#Android-Studio-配置" class="heading-link"><i class="fas fa-link"></i></a>Android Studio 配置</h2>              <h3 id="配置-Android-环境变量">          <a href="#配置-Android-环境变量" class="heading-link"><i class="fas fa-link"></i></a>配置 Android 环境变量</h3>      <p>终端命令：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></div></figure><p>在文档末尾添加：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 Android 环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 你的ADB路径</span></span><br><span class="line">ADB=/home/jaqen/Android/Sdk/platform-tools</span><br><span class="line">export ADB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 你的ANDROID_NDK和ANDROID_SDK 路径</span></span><br><span class="line">ANDROID_NDK=/home/jaqen/Android/Sdk/android-ndk-r14b</span><br><span class="line">export ANDROID_NDK</span><br><span class="line">ANDROID_SDK=/home/jaqen/Android/Sdk</span><br><span class="line">export ANDROID_SDK </span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入到PATH路径</span></span><br><span class="line">PATH=$&#123;PATH&#125;:$&#123;ADB&#125;:$&#123;ANDROID_NDK&#125;:$&#123;ANDROID_SDK&#125;</span><br></pre></td></tr></table></div></figure><p>NDK 需要单独去下载：</p><p><span class="exturl"><a class="exturl__link" href="https://developer.android.google.cn/ndk/downloads/older_releases.html">https://developer.android.google.cn/ndk/downloads/older_releases.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>注意需要执行下面的命令，使修改生效。</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></div></figure>        <h3 id="设置-Android-Studio-别名">          <a href="#设置-Android-Studio-别名" class="heading-link"><i class="fas fa-link"></i></a>设置 Android Studio 别名</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 你的android studio安装路径</span></span><br><span class="line">alias as=/home/jaqen/Downloads/android-studio-ide-191.5900203-linux/android-studio/bin/studio.sh</span><br></pre></td></tr></table></div></figure><p>然后，就可以用命令行执行命令 <code>as</code> 启动 Android Studio 了。</p>        <h3 id="制作启动图标">          <a href="#制作启动图标" class="heading-link"><i class="fas fa-link"></i></a>制作启动图标</h3>      <p>制作一个启动图标，方便鼠标点击启动。</p><p>终端命令进入 <code>/android-studio/bin/ </code> ，新建一个 <code>Studio.desktop</code> 文件，然后打开。</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit Studio.desktop</span><br></pre></td></tr></table></div></figure><p>输入以下内容：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=AndroidStudio</span><br><span class="line">Type=Application</span><br><span class="line"><span class="meta">#</span><span class="bash"> 你的Android Studio 图标路径</span></span><br><span class="line">Icon=/home/jaqen/Downloads/android-studio-ide-191.5900203-linux/android-studio/bin/studio.png</span><br><span class="line"><span class="meta">#</span><span class="bash"> 你的Android Studio 启动路径</span></span><br><span class="line">Exec=sh /home/jaqen/Downloads/android-studio-ide-191.5900203-linux/android-studio/bin/studio.sh</span><br></pre></td></tr></table></div></figure><p>保存。</p><p>右键该文件 &gt; 属性 &gt; 权限 &gt; 选择允许作为程序执行文件，这个时候文件名和图标都会相应改变了。</p><p>好了，双击可以启动 Android Studio 了。</p><p>将启动图标添加到 <code>/usr/share/applications/</code>下。</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /home/jaqen/Downloads/android-studio-ide-191.5900203-linux/android-studio/bin/Studio.desktop /usr/share/applications</span><br></pre></td></tr></table></div></figure><p>终端命令：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nautilus  usr/share/applications</span><br></pre></td></tr></table></div></figure><p><img src="/2019/10/14/ubuntu-android-studio/ubuntu_android_studio2.png" alt="ubuntu_android_studio2"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《韭菜的自我修养》</title>
      <link href="2019/10/08/jiucai/"/>
      <url>2019/10/08/jiucai/</url>
      
        <content type="html"><![CDATA[<p>近来读到李笑来老师的一本书，光书名就很有意思，叫做《韭菜的自我修养》。</p><p>李笑来不亏是曾经当过名师的人，整本书的内容浅显易懂，可读性很高。非常适合大多数新入门的投资者好好读读。</p><p>我挑重点概要总结了一些精要，和你们分享下。</p>        <h2 id="什么是韭菜？">          <a href="#什么是韭菜？" class="heading-link"><i class="fas fa-link"></i></a>什么是韭菜？</h2>      <p>书中一开始的定义是：“在交易市场中没赚到钱甚至赔钱的势单力薄的散户”，他们一般是缺乏基本的阅读能力，比如购买所有的产品都不会去看说明书的人，他们拒绝学习，拿来主义，伸手党，他们一进场不管三七二十一就买买买。</p>        <h2 id="一买就跌，一卖就涨？">          <a href="#一买就跌，一卖就涨？" class="heading-link"><i class="fas fa-link"></i></a>一买就跌，一卖就涨？</h2>      <p>交易市场有个诡异的定律就是：</p><p>你一买，它就开始跌；你一卖，它就开始涨。</p><p>为什么？</p><p>因为每一次行情结束的根本原因是”入场资金枯竭“。换言之，当连街边卖茶叶蛋的大妈都在讨论股票的时候，那么股市的“入场资金”已经到了枯竭边缘……你想啊，连你这个八竿子打不着的人都知道了，要冲进来赚钱的时候，那交易市场的行情是不是到头了？</p><p>对于新手，两句重要的话。</p><p>连你都开始进场的时候，牛市就要结束了；</p><p>你就应该干看着，啥都不买……到了熊市，等到大家都骂娘的时候，再开始买买买！</p>        <h2 id="亡羊补牢犹未晚矣">          <a href="#亡羊补牢犹未晚矣" class="heading-link"><i class="fas fa-link"></i></a>亡羊补牢犹未晚矣</h2>      <p>很多新手，一进场就犯了个大错，不知道牛市即将结束，激动的“买买买”，自然就被套住了。</p><p>更可怕的错误是，一进场就把自己的钱花光了！</p><p>还有更可怕的就是，一进场就连借来的钱都花光了！</p><p>对于聪明人来说，他们会怎么做？</p><p>还有钱的话，在漫长的熊市里，慢慢补仓，降低成本建仓。钱不够的话，就在场外拼命赚钱。</p>        <h2 id="投机者和投资者的区别">          <a href="#投机者和投资者的区别" class="heading-link"><i class="fas fa-link"></i></a>投机者和投资者的区别</h2>      <p>区分投机者和投资者的依据在于：</p><p> 投机者拒绝学习，投资者善于学习。</p><p>投资者交易之前，认真研究，深入学习；交易过后，无论输赢，都要总结归纳，修正自己的观念和思考，以便完善下一次的决策——这么做的人，在我眼里都是投资者，哪怕他们是“快进快出”。</p><p>而投机者呢？他们拒绝学习，最好有人告诉他怎么买就行，伸手党。这其实就是韭菜，是傻逼。</p><p>思考带来决策，决策带来行动，行动改变命运——这是大实话。</p>        <h2 id="韭菜错误的观点">          <a href="#韭菜错误的观点" class="heading-link"><i class="fas fa-link"></i></a>韭菜错误的观点</h2>      <p>韭菜都认同一个实际上错误的观点：</p><p>所谓的交易，是一种“零和游戏”。</p><p>也就是说，他们相信自己赚到的钱，是别人赔掉的钱；或者反过来说，他们自己赔掉了多少钱，一定被别人赚走了同样数额的钱。</p><p>这是一种错误的观点：</p><p>在牛市里，绝大多数人都赚到钱了，少数人赔掉的金额，全然抵不上那么多人赚到的总数；到底哪一根韭菜被割了？在熊市里，绝大多数人都赔钱了，大量的人赔掉的总金额，是少数人赚到的总额的无数倍，谁在割韭菜？</p><p>所以，这根本就不是“零和游戏”！</p>        <h2 id="韭菜缺的是实力">          <a href="#韭菜缺的是实力" class="heading-link"><i class="fas fa-link"></i></a>韭菜缺的是实力</h2>      <p>所谓“被割离场的韭菜”，本质的原因根本不是他们缺乏耐心。正如你之前看到的那样，哪怕是笨蛋，也天然在不断学习。只要是个人，在条件恰当的情况下，都有足够的耐心——这是事实。</p><p>缺乏耐心，其实是表象，本质是什么？本质是缺乏实力。</p><p>所以，想要摆脱“韭菜的宿命”，只有一个办法：提高自己的实力。</p>        <h2 id="实力指的是什么？">          <a href="#实力指的是什么？" class="heading-link"><i class="fas fa-link"></i></a>实力指的是什么？</h2>      <p>在交易市场里，实力指的究竟是什么？有一个清楚的定义：</p><p> 长期稳定的低成本现金流。</p><p>控制仓位。</p>        <h2 id="止损线如何制定才合理？">          <a href="#止损线如何制定才合理？" class="heading-link"><i class="fas fa-link"></i></a>止损线如何制定才合理？</h2>      <p>你可以估算一下交易标的的“日常波动幅度”。如果，X的日常波动幅度是 25%，那么，你的止损线，或者换个说法，你的“最大可忍受亏损”应该比 25% 更高，比如 40%，因为你在考虑的是风险，尤其是价格波动剧烈的交易市场里的风险，所以，“做更坏的打算”永远比“盲目乐观”更靠谱。</p><p>止损线到底应该定在哪里，有很多因素在起作用。甚至，连交易者的性格都是很重要的因素之一。最要命的是，你的性格确实在此时此刻决定你的行为，但回头仔细观察，你此时此刻的性格，更可能是你过去长期行为所决定的。</p>        <h2 id="降低交易频次">          <a href="#降低交易频次" class="heading-link"><i class="fas fa-link"></i></a>降低交易频次</h2>      <p>交易频次越高，交易越是接近“零和游戏”。</p><p>韭菜想要翻身，说一千道一万，只有一条路可走：</p><p>降低交易频次……降低降低再降低。</p><p>在交易市场里：</p><p>越是短期的预测，越接近于抛硬币； </p><p>越是长期的预测，越容易接近真实的逻辑推断……</p><p>所以，降低交易频次的本质，是拒绝抛硬币，坚持逻辑推断。</p>        <h2 id="提升收益风险比的方法">          <a href="#提升收益风险比的方法" class="heading-link"><i class="fas fa-link"></i></a>提升收益风险比的方法</h2>      <p>新手想要躲避韭菜宿命，就得天天反思，时时刻刻反思，反思之后还要再反思……</p><p>回报风险比=可能的回报÷可能的风险</p><p>看着公式，就知道，提高回报风险比的方法，无非有两个：要么加大分子，要么减小分母……</p><p>减小分母，可行的手段有这么几个：</p><p>调整止损线，降低自己的风险承担</p><p>降低每次的交易金额在总资金的占比</p><p>提高自己在场外的赚钱能力（或者募资能力）</p>        <h2 id="孤独的交易">          <a href="#孤独的交易" class="heading-link"><i class="fas fa-link"></i></a>孤独的交易</h2>      <p>参考少数人的意见</p><p>自己做决定</p>        <h2 id="把握周期">          <a href="#把握周期" class="heading-link"><i class="fas fa-link"></i></a>把握周期</h2>      <p>几乎所有的人，冲进交易市场的时候，都自然而然地犯下一个错误：一进场就买买买。</p><p>其深层次的原因是，这些人在冲进交易市场的时候，脑子里没有“周期”这个概念。如果交易者脑子里有这个概念，了解这个概念，擅长应用这个概念，那他就不大可能把交易当作零和游戏了，不是吗？</p><p>关注周期，以及多个周期背后显现出来的真正趋势，会给你一个全新且更为可靠的世界和视界。</p><p>如何把握周期呢？</p><p>仔细观察体会绝大多数交易者的情绪。牛市里，FOMO情绪达到顶峰，各种投资者开始ALL-IN的时候，上升趋势渐渐到头了；熊市里，大多数“韭菜”经过失望谩骂而后竟然平静了的时候，下跌趋势渐渐到底了……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 应用启动速度优化</title>
      <link href="2019/09/09/android-launch-time-performance-optimization/"/>
      <url>2019/09/09/android-launch-time-performance-optimization/</url>
      
        <content type="html"><![CDATA[<p>应用启动时间的长短，影响到用户体验。对研发人员来说，启动速度是我们的“门面”。</p><p>本文主要记录 Android 应用启动速度优化学习笔记。</p>        <h2 id="应用启动类型">          <a href="#应用启动类型" class="heading-link"><i class="fas fa-link"></i></a>应用启动类型</h2>      <p>应用的启动流程即从点击图标到用户可操作的全部过程。启动分为三种类型：</p><ul><li><p><strong>冷启动</strong>：当启动应用时，后台没有该应用的进程，这时系统会首先会创建一个新的进程分配给该应用。</p></li><li><p><strong>热启动</strong>：当启动应用时，后台已有该应用的进程，比如按下 home 键。</p></li><li><p><strong>温启动</strong>：当启动应用时，后台已有该应用的进程，但是启动的入口 Activity 被干掉了，比如按了 back 键，应用虽然退出了，但是该应用的进程是依然会保留在后台。</p></li></ul><p>其中启动最慢的就是冷启动，系统和应用本身的工作都是从零开始。</p><p>冷启动开始时，系统有三个任务：</p><ul><li><p>启动 App</p></li><li><p>App 启动后显示一个空白的 Window</p></li><li><p>创建 App 的进程</p></li></ul><p>在此之后，应用进程马上会执行以下任务：</p><ul><li><p>创建 App 对象</p></li><li><p>启动 main thread</p></li><li><p>创建要启动的 Activity</p></li><li><p>加载 View</p></li><li><p>布置页面</p></li><li><p>进行第一次绘制</p></li></ul>        <h2 id="测量时间方式">          <a href="#测量时间方式" class="heading-link"><i class="fas fa-link"></i></a>测量时间方式</h2>              <h3 id="adb-命令">          <a href="#adb-命令" class="heading-link"><i class="fas fa-link"></i></a>adb 命令</h3>      <p>使用 adb shell 获取应用启动时间：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W [packageName]/[packageName.AppstartActivity]</span><br></pre></td></tr></table></div></figure><p>输出的结果类似于：</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb shell am start -W com.speed.test/com.speed.test.HomeActivity</span></span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.speed.test/.HomeActivity &#125;</span><br><span class="line">Status: ok</span><br><span class="line">Activity: com.speed.test/.HomeActivity</span><br><span class="line">ThisTime: 496    </span><br><span class="line">TotalTime: 496</span><br><span class="line">WaitTime: 503</span><br><span class="line">Complete</span><br></pre></td></tr></table></div></figure><ul><li>ThisTime： 代表一连串启动 Activity 的最后一个 Activity 的启动耗时。</li><li>TotalTime 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，但不包括前一个应用 Activity <code>pause</code> 的耗时。</li><li>WaitTime 返回从 <code>startActivity</code> 到应用第一帧完全显示这段时间。 就是总的耗时，包括前一个应用 Activity <code>pause</code> 的时间和新应用启动的时间。</li></ul><p>一般只需关注 TotalTime，即应用自身真正的启动耗时。</p><p>缺点：adb 命令无法精确查看方法具体耗费的时间，局限性比较大。</p>        <h3 id="AOP">          <a href="#AOP" class="heading-link"><i class="fas fa-link"></i></a>AOP</h3>      <blockquote><p>AOP : Aspect Oriented Programming的缩写，意为：面向切面编程</p></blockquote><p>优点：</p><ol><li>针对同一问题的统一处理</li><li>无侵入添加代码</li></ol><p>Android 中使用 AspecJ 实现 AOP。详细内容看这篇文章：<a href="https://wuzhangyang.com/2020/06/03/aspectj/">Android AspectJ 学习笔记</a></p><p>项目根目录的 build.gradle 添加</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath &#39;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>app 项目的 build.gradle 新建的 module的 build.gradle 里添加</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;android-aspectjx&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    api &#39;org.aspectj:aspectjrt:1.9.5&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>MyApplication 代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        initBugly();</span><br><span class="line">        initBaiduMap();</span><br><span class="line">        initJPushInterface();</span><br><span class="line">        initShareSDK();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBugly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗费的时间</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBaiduMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗费的时间</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initJPushInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗费的时间</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initShareSDK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟耗费的时间</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>创建切面</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;PerformanceAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;call(* com.wuzy.aspectjdemo.MyApplication.**(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, methodName + <span class="string">&quot;方法耗时：&quot;</span> + (System.currentTimeMillis() - startTim</span><br><span class="line">                                          e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>无需修改任何工程代码，就可以获取运行时长了</p><p><img src="/2019/09/09/android-launch-time-performance-optimization/performaceaspect.png" alt="performaceaspect"></p>        <h3 id="TraceView">          <a href="#TraceView" class="heading-link"><i class="fas fa-link"></i></a>TraceView</h3>      <p><span class="exturl"><a class="exturl__link" href="https://developer.android.google.cn/studio/profile/generate-trace-logs">TraceView</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是 Android SDK 内置的一个工具，它可以加载 trace 文件，用图形的形式展示代码的执行时间、次数及调用栈。</p><p>使用方式</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(<span class="string">&quot;文件名&quot;</span>);</span><br><span class="line"></span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></div></figure><p>代码运行后，会在</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mnt/sdcard/Android/data/包名/files</span><br></pre></td></tr></table></div></figure><p>生成一个<code>.trace</code>后缀的文件，然后可以用 Android Studio 的 Profiler 添加打开它。</p><p><img src="/2019/09/09/android-launch-time-performance-optimization/traceview1.png" alt="traceview1"></p><p><strong>Wall Clock Time</strong>：表示实际经过的时间。包含线程在阻塞和等待的时间。</p><p><strong>Thread Time</strong>：表示实际经过的时间减去线程没有占用 CPU 资源的那部分时间。</p><p><strong>Flame Chart</strong>：火焰图。y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。 x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><blockquote><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题。</p></blockquote><p><strong>Top Down</strong>：显示一个函数调用列表，在该列表中展开函数节点会显示函数的被调用方。</p><p><strong>Bottom Up</strong>：显示一个函数调用列表，在该列表中展开函数节点将显示函数的调用方。</p><p><img src="/2019/09/09/android-launch-time-performance-optimization/top_down_and_bottom_down.png" alt="top_down_and_bottom_down"></p><p><strong>缺点</strong>：traceView 的原理就是抓取所有线程的所有函数里的信息，所以会导致程序变慢，工具本身带来的性能开销过大，有时无法反映真实的情况。比如一个函数本身的耗时是 1 秒，开启 TraceView 后可能会变成 5 秒。</p>        <h3 id="Systrace-函数插桩">          <a href="#Systrace-函数插桩" class="heading-link"><i class="fas fa-link"></i></a>Systrace + 函数插桩</h3>      <p>Systrace 原理：在系统的一些关键链路（如SystemServcie、虚拟机、Binder驱动）插入一些信息（Label），<br>通过 Label 的开始和结束来确定某个核心过程的执行时间，然后把这些Label信息收集起来得到系统关键路径的运行时间信息，最后得到整个系统的运行性能信息。Android Framework 里面一些重要的模块都插入了 label 信息(Java 层通过 android.os.Trace 类完成，native层通过 ATrace 宏完成），用户 App 中可以添加自定义的 Lable，这样就组成了一个完成的性能分析系统。</p><p>具体使用教程可以看这篇文章：<span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/27331842">手把手教你使用Systrace（一）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>Systrace 的优点：</p><ul><li>可以看大整个流程系统和应用程序的调用流程。包括系统关键线程的函数调用，渲染耗时、线程锁、GC 耗时等。</li><li>性能损耗可以接受。</li></ul>        <h2 id="异步优化">          <a href="#异步优化" class="heading-link"><i class="fas fa-link"></i></a>异步优化</h2>      <p>异步优化的核心思想：子线程来分担主线程的任务，并减少运行时间。</p>        <h3 id="FixThreadPool">          <a href="#FixThreadPool" class="heading-link"><i class="fas fa-link"></i></a>FixThreadPool</h3>      <p>线程池核心个数</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前CPU的核心数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的核心线程数2-4之间,但是取决于CPU核数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></div></figure><p>创建线程池</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(CORE_POOL_SIZE);</span><br></pre></td></tr></table></div></figure><p>将耗时方法放在线程池中，不影响主线程页面加载。对于必须要先执行完毕才能进入页面的情况，使用 CountDownLatch 处理。</p><p>MyApplication#onCreate：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"><span class="comment">//        Debug.startMethodTracing();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(CORE_POOL_SIZE);</span><br><span class="line"></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                initBugly();</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                initBaiduMap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                initJPushInterface();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                initShareSDK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Debug.stopMethodTracing();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p>上面代码中：只有在 <code>initBugly</code> 执行完毕后才能跳转页面，而  <code>initBugly</code>  是可以在子线程执行，所以可以采用线程池 + CountDownLatch 实现。</p><p>但是，对于多个耗时任务存在依赖关联，比如必须先执行完A，根据A的返回值，再执行B，然后根据B的返回再执行C，任务串联的情况，使用线程池 + CountDownLatch  就比较麻烦。</p>        <h3 id="启动器">          <a href="#启动器" class="heading-link"><i class="fas fa-link"></i></a>启动器</h3>      <p>先将任务分类：</p><p>![task_classification ](android-launch-time-performance-optimization/task_classification .jpg)</p><ul><li><p>head task : 我们会把一些必须先启动的task放到这里</p></li><li><p>主线程：将必须要在主线程中初始化的task放入这里</p></li><li><p>并发：将非必须在主线程中初始化的task放入这里</p></li><li><p>tail task: 一些在所有任务执行完毕之后才去初始化的放入这里，比如一些log打印等</p></li><li><p>ilde task: 通过字面就知道了将一些可以有空再初始化的task放入这里</p></li></ul><p>启动器的目的就是保证并发任务的执行顺序的正确性。任务执行顺序的排序采用：<strong>有向无环图的<span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/b59db381561a">拓扑排序</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p><p><strong>拓扑排序（Topological Sorting</strong>）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。</p><p>且该序列必须满足下面两个条件：</p><ul><li><p>每个顶点出现且只出现一次。</p></li><li><p>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</p></li></ul><p><strong>拓扑排序的写法思路：</strong></p><p>1、从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</p><p>2、从图中删除该顶点和所有以它为起点的有向边。</p><p>3、重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</p><p><img src="/2019/09/09/android-launch-time-performance-optimization/DAG.png" alt="DAG"></p><p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p><p>启动器外部调用：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TaskDispatcher instance = TaskDispatcher.createInstance();</span><br><span class="line">       instance.addTask(<span class="keyword">new</span> InitBuglyTask()) <span class="comment">// 默认添加，并发处理</span></span><br><span class="line">               .addTask(<span class="keyword">new</span> InitBaiduMapTask())  <span class="comment">// 在这里需要先处理了另外一个耗时任务initShareSDK，才能再处理它</span></span><br><span class="line">               .addTask(<span class="keyword">new</span> InitJPushTask())  <span class="comment">// 等待主线程处理完毕，再进行执行</span></span><br><span class="line">               .start();</span><br><span class="line">       instance.await();</span><br></pre></td></tr></table></div></figure><p>启动器主要流程：</p><p><img src="/2019/09/09/android-launch-time-performance-optimization/starter_flow.jpg" alt="starter_flow"></p><p>具体代码：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/PerformanceDemo">PerformanceDemo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="启动窗口优化">          <a href="#启动窗口优化" class="heading-link"><i class="fas fa-link"></i></a>启动窗口优化</h2>      <p>使用 Activity 的 windowBackground 属性为启动的 Activity 提供一个闪屏预览界面（layer-list），这样点击应用图标会立马显示闪屏界面。具体操作方法：</p><p>Layout XML：</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:opacity</span>=<span class="string">&quot;opaque&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 背景颜色 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 闪屏页图片 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitmap</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:src</span>=<span class="string">&quot;@drawable/product_logo_144dp&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>style：</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme.Launcher&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@mipmap/layer-list<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>Manifest：</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme.Launcher&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure><p>Activity：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 替换回原来的主题，注意在 super.onCreate 之前调用</span></span><br><span class="line">    setTheme(R.style.Theme_MyApp);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这种方案在通过交互体验优化了展示效果，但并没有真正的加速启动。</p><p>对于中低端机，总的闪屏时间会更长，建议在 Android 6.0 或者 Android 7.0 以上才启用“闪屏优化” 方案。</p>        <h2 id="延迟初始化">          <a href="#延迟初始化" class="heading-link"><i class="fas fa-link"></i></a>延迟初始化</h2>      <p>首页渲染完成后，再初始化数据，也就是延迟初始化，目的就是让界面先显示出来，保证 UI 绘制的流畅性。</p><p>核心方法是在 Activity 的 <code>onCreate</code> 函数中加入下面的方法 ：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myHandler.post(mLoadingRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure><p>这里的 <code>run</code> 方法是在 Activity 的 <code>onResume</code> 之后执行的。</p><p>关于这种方案的机制参见 ：<span class="exturl"><a class="exturl__link" href="https://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/">Android 应用启动优化:一种 DelayLoad 的实现和原理(上篇)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="建议">          <a href="#建议" class="heading-link"><i class="fas fa-link"></i></a>建议</h2>      <p>1、减少布局层级，建议使用约束布局 ConstraintLayout。</p><p>2、去掉无用代码、重复逻辑。</p><p>3、避免 Application 中创建线程池，尽量延迟操作。</p><p>4、避免启动过多工作线程。</p><p>5、尽量减少 GC 的次数，避免造成主线程长时间的卡顿。</p><p>6、一句话准则：可以异步的都异步，不可以异步的尽量延迟。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/">https://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/f5514b1a826c">https://www.jianshu.com/p/f5514b1a826c</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/">https://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://developer.android.google.cn/topic/performance/launch-time.html">https://developer.android.google.cn/topic/performance/launch-time.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/27331842">https://zhuanlan.zhihu.com/p/27331842</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://juejin.im/user/5d618e106fb9a06b084d0073/posts">https://juejin.im/user/5d618e106fb9a06b084d0073/posts</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> TraceView </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能分析工具 TraceView</title>
      <link href="2019/09/04/android-traceview/"/>
      <url>2019/09/04/android-traceview/</url>
      
        <content type="html"><![CDATA[<p>在做应用启动、卡顿优化时，经常会用到 Android 性能分析工具 TraceView，这里简单介绍下 TraceView 的基础使用。</p>        <h2 id="TraceView-是什么">          <a href="#TraceView-是什么" class="heading-link"><i class="fas fa-link"></i></a>TraceView 是什么</h2>      <p><span class="exturl"><a class="exturl__link" href="https://developer.android.google.cn/studio/profile/generate-trace-logs">TraceView</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是 Android SDK 内置的一个工具，它可以加载 <strong>trace</strong> 文件，用图形的形式展示<strong>代码的执行时间、次数及调用栈</strong>，便于我们分析。</p>        <h2 id="生成-trace-文件">          <a href="#生成-trace-文件" class="heading-link"><i class="fas fa-link"></i></a>生成 trace 文件</h2>      <p>trace 文件是 log 信息文件的一种，可以通过代码，Android Studio，或者 DDMS 生成。</p>        <h3 id="使用代码生成-trace-文件">          <a href="#使用代码生成-trace-文件" class="heading-link"><i class="fas fa-link"></i></a>使用代码生成 trace 文件</h3>      <p>在想要记录的地方调用 <code>Debug.startMethodTracing(&quot;sample&quot;)</code>，参数指定 <code>trace</code> 文件的名称。</p><p>在结束记录的地方调用 <code>Debug.stopMethodTracing()</code>，文件会被保存到 <code>/sdcard/Android/data/packageName/files</code> 文件夹下。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(<span class="string">&quot;sample&quot;</span>); <span class="comment">// 开始 trace</span></span><br><span class="line">...</span><br><span class="line">Debug.stopMethodTracing();  <span class="comment">// 结束 trace</span></span><br></pre></td></tr></table></div></figure><p>可以使用 adb 命令导出 trace 文件，使用 Android Studio Profiler 或者 DDMS 打开。</p>        <h3 id="使用-Android-Studio-生成-trace-文件">          <a href="#使用-Android-Studio-生成-trace-文件" class="heading-link"><i class="fas fa-link"></i></a>使用 Android Studio 生成 trace 文件</h3>      <p>点击工具栏中的 Profiler（Android Studio 版本是 3.4.2）, 点击 CPU 时间轴上的任意位置以打开 CPU Profiler。</p><p><img src="/2019/09/04/android-traceview/cpu_profiler1.png" alt="cpu_profiler1"></p><p>1.  <strong>事件时间轴</strong>：显示应用中的 Activity 在其生命周期内不断转换而经历各种不同状态的过程，并指示用户与设备的交互，包括屏幕旋转事件。</p><p>2. <strong>CPU 时间轴</strong> : 显示应用的实时 CPU 使用率以及应用当前使用的线程总数。通过沿时间线的水平轴移动鼠标，还可以检查历史 CPU 使用率数据。</p><p>3. <strong>线程活动时间轴</strong>：应用进程的所有线程。不同颜色对应的含义：</p><ul><li><p><strong>绿色</strong>： 表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。</p></li><li><p><strong>黄色</strong>： 表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。</p></li><li><p><strong>灰色</strong>： 表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。</p></li></ul><p>要开始记录跟踪数据，点击 CPU Profiler 顶部的下拉框选择适当的记录配置：</p><ul><li><p><strong>对 Java 方法采样</strong>：在应用的 Java 代码执行期间，频繁捕获应用的调用堆栈。分析器会比较捕获的数据集，以推导与应用的 Java 代码执行有关的时间和资源使用信息。</p></li><li><p><strong>跟踪 Java 方法</strong> ：在运行时检测应用，以在每个方法调用开始和结束时记录一个时间戳。系统会收集并比较这些时间戳，以生成方法跟踪数据，包括时间信息和 CPU 使用率。</p></li><li><p><strong>对 C/C++ 函数采样</strong>：捕获应用的原生线程的采样跟踪数据。</p></li></ul><p><img src="/2019/09/04/android-traceview/cpu_profiler2.png" alt="cpu_profiler2"></p><p>选择配置后，点击 <code>Record</code> 进行跟踪，交互完成后点击 <code>Stop</code> 结束数据跟踪。分析器会分析 trace 数据，如下图所示。</p><p><img src="/2019/09/04/android-traceview/cpu_profiler3.png" alt="cpu_profiler3"></p><p>1. <strong>选择时间范围</strong>： 确定要在跟踪窗格中检查所记录时间范围的哪一部分。 当首次记录函数跟踪时，CPU Profiler 将在 CPU 时间线中自动选择完整长度。 如果想仅检查所记录时间范围一小部分的函数跟踪数据，可以点击并拖动突出显示的区域边缘以修改其长度。</p><p>2. <strong>时间戳</strong>： 用于表示所记录函数跟踪的开始和结束时间（相对于分析器从设备开始收集 CPU 使用率信息的时间）。 可以点击时间戳以自动选择完整记录。</p><p>3. <strong>跟踪窗格</strong>： 用于显示所选的时间范围和线程的函数跟踪数据。</p><p>4. <strong>跟踪数据窗格标签</strong>：通过Call Chart（调用图表）、Flame Chart（火焰图）、 Top Down 树或 Bottom Up 树的形式显示函数跟踪。</p><ul><li><p><strong>Call Chart</strong> : 水平轴表示函数调用（或调用方）的时间，并沿垂直轴显示其被调用者。 对系统 API 的函数调用显示为橙色，对应用自有函数的调用显示为绿色，对第三方 API（包括 Java 语言 API）的函数调用显示为蓝色。 </p></li><li><p><strong>Flame Chart</strong>: 一个倒置的调用图表，其中水平轴不再代表时间线，它表示每个函数相对的执行时间。</p></li><li><p><strong>Top Down</strong>：显示一个函数调用列表，在该列表中展开函数节点会显示函数的被调用方。</p></li><li><p><strong>Bottom Up</strong>：显示一个函数调用列表，在该列表中展开函数节点将显示函数的调用方。</p></li></ul><p>5. <strong>时间参考菜单</strong> ：确定如何测量每个函数调用的时间信息：</p><ul><li><p><strong>Wall clock time</strong>：实际经过的时间。</p></li><li><p><strong>Thread time</strong>：实际经过的时间减去线程没有消耗 CPU 资源的时间。</p></li></ul>        <h3 id="使用-DDMS-生成-trace-文件">          <a href="#使用-DDMS-生成-trace-文件" class="heading-link"><i class="fas fa-link"></i></a>使用 DDMS 生成 trace 文件</h3>      <p>DDMS 即 Dalvik Debug Monitor Server ，是 Android 调试监控工具，它为我们提供了截图，查看 log，查看视图层级，查看内存使用等功能。</p><p>Android Studio 3.0 后可在 Android SDK 的 <code>tools</code> 目录，找到 <code>monitor.bat</code>，使用命令行启动它，就能打开 DDMS。 </p><p>DDMS 界面点击 <code>Start Method Profiling</code> 按钮，开始记录 trace，同一个按钮停止 trace。DDMS 会自动启用 TraceView 加载 trace 文件，如下图：</p><p><img src="/2019/09/04/android-traceview/ddms_trace.png" alt="ddms_trace"></p><p>图中上半部分展示了不同线程的执行时间，其中不同的颜色代表不同的方法，同一颜色越长，说明执行时间越长，空白表示这个时间段内没有执行内容。</p><p>下半部分展示了不同方法的执行时间信息。各个指标的含义：</p><ul><li><p>Incl Cpu Time：方法占用的 CPU 时间（包括调用子函数所消耗的时间）。</p></li><li><p>Excl Cpu Time：方法自身占用的 CPU 时间（不包括调用其他方法所消耗的时间）。</p></li><li><p>Incl Real Time：方法运行的真实时间（包括调用子函数所消耗的时间）。</p></li><li><p>Excl Real Time：方法自身运行的真实时间（不包括调用其他方法所消耗的时间）。</p></li><li><p>Calls+RecurCalls/Total：方法被调用的次数+重复调用的次数。</p></li><li><p>Cpu Time/Call：方法调用 CPU 时间与调用次数的比，相当于方法平均执行时间。</p></li><li><p>Real Time/Call：同 Cpu Time/Call 类似，只不过统计单位换成了真实时间。</p></li></ul><p>在分析耗时的时候一般有两种情况：</p><ul><li><p>调用次数不多。但是，本身就非常耗时。</p></li><li><p>本身不是很耗时。但是，调用非常频繁。</p></li></ul><p>第一种情况，可以使用 <code>Cpu Time</code> 来查看它的耗时情况。 </p><p>第二种情况，可以使用 <code>Calls+RecurCalls/Total</code> 来查看它的调用情况。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://developer.android.google.cn/studio/profile/cpu-profiler">https://developer.android.google.cn/studio/profile/cpu-profiler</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/u011240877/article/details/54347396">https://blog.csdn.net/u011240877/article/details/54347396</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> TraceView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员成长离不开的技能</title>
      <link href="2019/08/31/ten-step-learning-method/"/>
      <url>2019/08/31/ten-step-learning-method/</url>
      
        <content type="html"><![CDATA[<p>很多人，在学生阶段习惯了被动、填鸭式学习，进入社会后，不知道如何去自我学习，严重限制了提升自己的知识和技能的机会。</p><p>在这个飞速发展的世界里，做一个终身学习者，自我学习的能力越强越好。</p><p>最近看了一本书《软技能: 代码之外的生存指南》，里面的一个主题，讲述了技术人员如何在新技术发展日新月异的世界里，如何快速高效学习技术，以下是我整理的「十步学习法」笔记，供大家参考。</p><p>十步学习法的基本思想就是：</p><p>要对自己要学的内容有个基本的了解：了解自己不知道什么就足矣。然后，利用这些信息勾勒出学习的范围，即需要学哪些内容，以及学成之后又会获得什么。依靠这些知识，你可以找出各种资源来帮助自己学习。最后，你们可以创建自己的学习计划，列出要去学习哪些相关课程，筛选学习材料，只保留能帮助自己达成目标的优质内容。</p><p>一旦完成这些工作，你对自己要学什么和怎样学都了然于胸，你就可以把控自己的学习计划中的每个关键点，通过「学习—实践—掌握—教授」(Learning, Doing, Learning and Teaching，LDLT) 的过程，获得对该学科的深刻理解，同时你也向着自己的目标前进。</p><p><img src="/2019/08/31/ten-step-learning-method/ten-step-learing-method.jpg" alt="ten-step-learing-method"></p>        <h3 id="第-1-步-了解全局">          <a href="#第-1-步-了解全局" class="heading-link"><i class="fas fa-link"></i></a>第 1 步 了解全局</h3>      <p>unknown unknowns，即你根本不知道自己不知道。</p><p>在你打开一本新书开始阅读的时候，你对自己所不知道的一无所知。闷头往下看的话，会出现学费所需、力所不及的情况。</p><p>所以，在学习某一技术之前，至少要对其有所了解，对技术有一个全局的了解，这一点非常重要。</p>        <h3 id="第-2-步-确定范围">          <a href="#第-2-步-确定范围" class="heading-link"><i class="fas fa-link"></i></a>第 2 步 确定范围</h3>      <p>充分利用第 1 步获得的信息，根据自己的需求，明确自己到底要学什么，确定学习范围。</p><p>这一步容易犯的一个错误：试图解决太大的问题而让自己陷入困境中。</p><p>可以将大的主题，分解小而聚焦的主题。</p><p>因此，学习范围务必大小适当，符合自己的学习理由，同时要保持专注。</p>        <h3 id="第-3-步-定义目标">          <a href="#第-3-步-定义目标" class="heading-link"><i class="fas fa-link"></i></a>第 3 步 定义目标</h3>      <p>确定自己的学习目标，明确学习完成后应该达成的效果，根据简明清晰的目标，勾勒出勤奋学习后成功的图景。成功的标准应该是具体的，无二义性的。</p>        <h3 id="第-4-步-寻找资源">          <a href="#第-4-步-寻找资源" class="heading-link"><i class="fas fa-link"></i></a>第 4 步 寻找资源</h3>      <p>尽可能的尝试多种渠道和方式收集与学习主题相关的资源。这个阶段，资源的质量无需考虑。</p>        <h3 id="第-5-步-创建学习计划">          <a href="#第-5-步-创建学习计划" class="heading-link"><i class="fas fa-link"></i></a>第 5 步 创建学习计划</h3>      <p>打造自己的学习计划，一个好方法就是观察别人是如何教你感兴趣的主题的。通览你收集的全部资源，你就对自己需要哪些内容及如何组合这些内容有更清晰的认识。</p>        <h3 id="第-6-步-筛选资源">          <a href="#第-6-步-筛选资源" class="heading-link"><i class="fas fa-link"></i></a>第 6 步 筛选资源</h3>      <p>对找到的资源进行筛选，挑选出最有价值的几项来帮助你实现自己的目标。</p><p>现在，你可以就你想要了解的一个主题，实际演练一下以上 6 个步骤了。</p>        <h3 id="第-7-步-开始学习-浅谈辄止">          <a href="#第-7-步-开始学习-浅谈辄止" class="heading-link"><i class="fas fa-link"></i></a>第 7 步 开始学习 浅谈辄止</h3>      <p>大多数人，包括我自己，在学习的过程中通常会犯两类错误：第一类错误是在知之不多的情况下就盲目开始，即行动太快；第二类错误是在行动之前准备过多，即行动太晚。</p><p>这一步的关键在于避免过犹不及。开始学习时很容易失去自控力，深入学习计划学习中列出的所有资源。你要专注于掌握自己所需的、能在下一步动手操作的最小量的知识。</p>        <h3 id="第-8-步-动手操作-边玩边学">          <a href="#第-8-步-动手操作-边玩边学" class="heading-link"><i class="fas fa-link"></i></a>第 8 步 动手操作 边玩边学</h3>      <p>在掌握操作动手最小量的知识的情况下亲自操作和亲身体验。</p><p>在探索和实践过程中，会产生的各种问题。这些问题会引导着你走向真正重要的方向。当回头寻找问题的答案时，不只是这些问题迎刃而解，而且你记得的东西比你学习的东西要多得多，因为你所学到的都是对你很重要的东西。</p>        <h3 id="第-9-步-全面掌握-学以致用">          <a href="#第-9-步-全面掌握-学以致用" class="heading-link"><i class="fas fa-link"></i></a>第 9 步 全面掌握 学以致用</h3>      <p>好奇心是学习特别是自学的重要组成部分。</p><p>为了有效利用自己选择的资料，为了上一步生产的问题寻求答案（带着问题学习）。不用担心回头再去操作，付出更多，因为这不仅能够让你找到问题的答案，也能让你学习新东西。给自己足够多的时间去深入理解自己的主题，你可以阅读，可以实验，可以观察，也可以操作。试着把自己正在学习的内容与最终目标关联起来。</p>        <h3 id="第-10-步-乐为人师-融会贯通">          <a href="#第-10-步-乐为人师-融会贯通" class="heading-link"><i class="fas fa-link"></i></a>第 10 步 乐为人师 融会贯通</h3>      <p>要想深入掌握一门学问，并且融会贯通，那么必须要做到能够教授给别人，在这一过程中，你要切实刨析并理解自己所学的知识，将其内化到自己的思想；同时，也要用能够让他人理解的方式精心组织这些信息。</p><p>在这个过程中，你会发现很多自以为明白的知识点，其实并没有你想象的那么透彻。这一过程会将那些以前自己没太明白的东西联系起来，并简化到自己的大脑中已有的信息，将它们浓缩并经常复习。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软技能 </tag>
            
            <tag> 十步学习法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Python 爬取微信公众号文章</title>
      <link href="2019/08/09/python-save-wechat-article/"/>
      <url>2019/08/09/python-save-wechat-article/</url>
      
        <content type="html"><![CDATA[<p>我比较喜欢看公众号，有时遇到一个感兴趣的公众号时，都会感觉相逢恨晚，想一口气看完所有历史文章。但是微信的阅读体验挺不好的，看历史文章得一页页的往后翻，下一次再看时还得重复操作，很是麻烦。</p><p>于是便想着能不能把某个公众号所有的文章都保存下来，这样就很方便自己阅读历史文章了。</p><p>话不多说，下面我就介绍如何使用 Python 爬取微信公众号所有文章的。</p><p>主要有以下步骤：</p><p>1 使用 Fiddler 抓取公众号接口数据</p><p>2 使用 Python 脚本获取公众号所有历史文章数据</p><p>3 保存历史文章</p>        <h2 id="Fiddler-抓包">          <a href="#Fiddler-抓包" class="heading-link"><i class="fas fa-link"></i></a>Fiddler 抓包</h2>      <p>Fiddler 是一款抓包工具，可以监听网络通讯数据，开发测试过程中非常有用，这里不多做介绍。没有使用过的可以查看这篇文章，很容易上手。</p><p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/jingjingshizhu/article/details/80566191">https://blog.csdn.net/jingjingshizhu/article/details/80566191</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>接下来，使用微信桌面客户端，打开某个公众号的历史文章，这里以我的公众号举例，如下图。</p><p><img src="/2019/08/09/python-save-wechat-article/wechat_article.png" alt="wechat_article"></p><p>如果你的 fiddler 配置好了的话，能够看到如下图的数据。</p><p><img src="/2019/08/09/python-save-wechat-article/fiddler_wechat.png" alt="fiddler_wechat"></p><p>图中包含抓取的 url、一些重要的参数和我们想要的数据。</p><p>这些参数中，<code>offset</code> 控制着翻页，其他参数在每一页中都是固定不变的。</p><p>接口返回的数据结构如下图，其中 <code>can_msg_continue</code> 字段控制着能否翻页，1 表示还有下一页，0 表示没有已经是最后一页了。 <code>next_offset</code> 字段就是下一次请求的 <code>offset</code> 参数。</p><p><img src="/2019/08/09/python-save-wechat-article/wechat_json.png" alt="wechat_json"></p>        <h2 id="构造请求，获取数据">          <a href="#构造请求，获取数据" class="heading-link"><i class="fas fa-link"></i></a>构造请求，获取数据</h2>      <p>接下来我们的目标就是根据 url 和一些参数，构建请求，获取标题、文章 url 和日期等数据，保存数据。</p><p>保存数据一种是使用 pdfkit 将 文章 url 保存为 pdf 文件；另一种是先保存 html 文件，然后将 html 制作成 chm 文件。</p><p>1 将 文章 url 保存为 pdf 文件，关键代码如下：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">index, biz, uin, key</span>):</span></span><br><span class="line">    <span class="comment"># url前缀</span></span><br><span class="line">    url = <span class="string">&quot;https://mp.weixin.qq.com/mp/profile_ext&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求头</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 &quot;</span></span><br><span class="line">                      <span class="string">&quot;Safari/537.36 MicroMessenger/6.5.2.501 NetType/WIFI WindowsWechat QBCore/3.43.901.400 &quot;</span></span><br><span class="line">                      <span class="string">&quot;QQBrowser/9.0.2524.400&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxies = &#123;</span><br><span class="line">        <span class="string">&#x27;https&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">        <span class="string">&#x27;http&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重要参数</span></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;getmsg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__biz&#x27;</span>: biz,</span><br><span class="line">        <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;offset&#x27;</span>: index * <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;count&#x27;</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;is_ok&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;scene&#x27;</span>: <span class="string">&#x27;124&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;uin&#x27;</span>: uin,</span><br><span class="line">        <span class="string">&#x27;key&#x27;</span>: key,</span><br><span class="line">        <span class="string">&#x27;wxtoken&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;x5&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求，获取响应</span></span><br><span class="line">    response = requests.get(url, headers=headers, params=param, proxies=proxies)</span><br><span class="line">    response_dict = response.json()</span><br><span class="line"></span><br><span class="line">    print(response_dict)</span><br><span class="line"></span><br><span class="line">    next_offset = response_dict[<span class="string">&#x27;next_offset&#x27;</span>]</span><br><span class="line">    can_msg_continue = response_dict[<span class="string">&#x27;can_msg_continue&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    general_msg_list = response_dict[<span class="string">&#x27;general_msg_list&#x27;</span>]</span><br><span class="line">    data_list = json.loads(general_msg_list)[<span class="string">&#x27;list&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(data_list)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 文章发布时间</span></span><br><span class="line">            datetime = data[<span class="string">&#x27;comm_msg_info&#x27;</span>][<span class="string">&#x27;datetime&#x27;</span>]</span><br><span class="line">            date = time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(datetime))</span><br><span class="line"></span><br><span class="line">            msg_info = data[<span class="string">&#x27;app_msg_ext_info&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 文章标题</span></span><br><span class="line">            title = msg_info[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 文章链接</span></span><br><span class="line">            url = msg_info[<span class="string">&#x27;content_url&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 自己定义存储路径（绝对路径）</span></span><br><span class="line">            pdfkit.from_url(url, <span class="string">&#x27;C:/Users/admin/Desktop/wechat_to_pdf/&#x27;</span> + date + title + <span class="string">&#x27;.pdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            print(title + date + <span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">&quot;不是图文消息&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> can_msg_continue == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;爬取完毕&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></div></figure><p>2 保存 html 文件，关键代码如下</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">index, biz, uin, key</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># url前缀</span></span><br><span class="line">    url = <span class="string">&quot;https://mp.weixin.qq.com/mp/profile_ext&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求头</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 &quot;</span></span><br><span class="line">                      <span class="string">&quot;Safari/537.36 MicroMessenger/6.5.2.501 NetType/WIFI WindowsWechat QBCore/3.43.901.400 &quot;</span></span><br><span class="line">                      <span class="string">&quot;QQBrowser/9.0.2524.400&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxies = &#123;</span><br><span class="line">        <span class="string">&#x27;https&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">        <span class="string">&#x27;http&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重要参数</span></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;getmsg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__biz&#x27;</span>: biz,</span><br><span class="line">        <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;offset&#x27;</span>: index * <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;count&#x27;</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;is_ok&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;scene&#x27;</span>: <span class="string">&#x27;124&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;uin&#x27;</span>: uin,</span><br><span class="line">        <span class="string">&#x27;key&#x27;</span>: key,</span><br><span class="line">        <span class="string">&#x27;wxtoken&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;x5&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求，获取响应</span></span><br><span class="line">    reponse = requests.get(url, headers=headers, params=param, proxies=proxies)</span><br><span class="line">    reponse_dict = reponse.json()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(reponse_dict)</span></span><br><span class="line">    next_offset = reponse_dict[<span class="string">&#x27;next_offset&#x27;</span>]</span><br><span class="line">    can_msg_continue = reponse_dict[<span class="string">&#x27;can_msg_continue&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    general_msg_list = reponse_dict[<span class="string">&#x27;general_msg_list&#x27;</span>]</span><br><span class="line">    data_list = json.loads(general_msg_list)[<span class="string">&#x27;list&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    print(data_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            datetime = data[<span class="string">&#x27;comm_msg_info&#x27;</span>][<span class="string">&#x27;datetime&#x27;</span>]</span><br><span class="line">            date = time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(datetime))</span><br><span class="line"></span><br><span class="line">            msg_info = data[<span class="string">&#x27;app_msg_ext_info&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 标题</span></span><br><span class="line">            title = msg_info[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 内容的url</span></span><br><span class="line">            url = msg_info[<span class="string">&#x27;content_url&#x27;</span>].replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;http&quot;</span>, <span class="string">&quot;https&quot;</span>)</span><br><span class="line">            url = html.unescape(url)</span><br><span class="line">            print(url)</span><br><span class="line"></span><br><span class="line">            res = requests.get(url, headers=headers, proxies=proxies)</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">&#x27;C:/Users/admin/Desktop/test/&#x27;</span> + title + <span class="string">&#x27;.html&#x27;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(res.content)</span><br><span class="line"></span><br><span class="line">            print(title + date + <span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">&quot;不是图文消息&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> can_msg_continue == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;全部获取完毕&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></div></figure>        <h2 id="保存文章">          <a href="#保存文章" class="heading-link"><i class="fas fa-link"></i></a>保存文章</h2>      <p><strong>保存为 pdf 文件</strong>，用到了 python 的第三方库 pdfkit 和 wkhtmltopdf。</p><p>安装 pdfkit：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pdfkit</span><br></pre></td></tr></table></div></figure><p>安装 wkhtmltopdf：</p><p>下载地址：</p><p><span class="exturl"><a class="exturl__link" href="https://wkhtmltopdf.org/downloads.html">https://wkhtmltopdf.org/downloads.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>安装后将 wkhtmltopdf 目录下的 bin 添加到环境变量中。</p><p><strong>保存为 chm 文件</strong>，可以下载 Easy CHM ，使用这个软件可以将 html 制作成 chm，使用教程网上比较多。</p><p>下载地址：</p><p><span class="exturl"><a class="exturl__link" href="http://www.etextwizard.com/cn/easychm.html">http://www.etextwizard.com/cn/easychm.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>效果图：</p><p><img src="/2019/08/09/python-save-wechat-article/chm.png" alt="chm"></p><p><strong>pdf 和 chm 对比</strong>：</p><p>pdf 支持多终端，阅读体验好，但是有个大坑，就是微信文章保存的 pdf 没有图片，很影响阅读体验，暂未找到解决办法。</p><p>chm 的好处是可以建立索引，查看文章方便。一个公众号制作成一个 chm 文件，管理方便。不会出现图片不显示问题。</p><p>所以推荐将爬取到的公众号文章保存为 chm 文件，方便阅读。</p><p>需要完整代码和文中相关软件的朋友，可以关注公众号「贾小昆」，后台回复关键词 ”<strong>公众号文章</strong>“ 获取。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV 格式详解</title>
      <link href="2019/07/28/yuv-format-explaination/"/>
      <url>2019/07/28/yuv-format-explaination/</url>
      
        <content type="html"><![CDATA[<p>一般的视频采集芯片输出的码流一般都是 YUV 格式数据流，后续视频处理也是对 YUV 数据流进行编码和解析。所以，了解 YUV 数据流对做视频领域的人而言，至关重要。</p><p>在介绍 YUV 格式之前，首先介绍一下我们熟悉的 RGB 格式。</p>        <h2 id="RGB">          <a href="#RGB" class="heading-link"><i class="fas fa-link"></i></a>RGB</h2>      <p>RGB 分别表示红（R）、绿（G）、蓝（B），也就是三原色，将它们以不同的比例叠加，可以产生不同的颜色。</p><p>比如一张 1920 * 1280 的图片，代表着有 1920 * 1280 个像素点。如果采用 RGB 编码方式，每个像素点都有红、绿、蓝三个原色，其中每个原色占用 8bit，每个像素占用 24bit，也就是 3 个字节。</p><p>那么，一张 1920 * 1280 大小的图片，就占用 1920 * 1280 * 3 / 1024 / 1024 = 7.03MB 存储空间。</p>        <h2 id="YUV">          <a href="#YUV" class="heading-link"><i class="fas fa-link"></i></a>YUV</h2>      <p>YUV 编码采用了明亮度和色度表示每个像素的颜色。</p><p>其中 Y 表示明亮度（Luminance、Luma），也就是灰阶值。</p><p>U、V 表示色度（Chrominance 或 Chroma），描述的是色调和饱和度。</p><p>YCbCr 其实是 YUV 经过缩放和偏移的翻版。其中 Y 与 YUV 中的 Y 含义一致,Cb,Cr 同样都指色彩，只是在表示方法上不同而已。YCbCr 其中 Y 是指亮度分量，Cb 指蓝色色度分量，而 Cr 指红色色度分量。</p><p><img src="/2019/07/28/yuv-format-explaination/yuv-image.png" alt="yuv-image"></p>        <h2 id="YUV-优点">          <a href="#YUV-优点" class="heading-link"><i class="fas fa-link"></i></a>YUV 优点</h2>      <p>对于 YUV 所表示的图像，Y 和 UV 分量是分离的。如果只有 Y 分量而没有 UV 分离，那么图像表示的就是黑白图像。彩色电视机采用的就是 YUV 图像，<strong>解决与和黑白电视机的兼容问题，使黑白电视机也能接受彩色电视信号</strong>。</p><p>人眼对色度的敏感程度低于对亮度的敏感程度。主要原因是视网膜杆细胞多于视网膜锥细胞，其中视网膜杆细胞的作用就是识别亮度，视网膜锥细胞的作用就是识别色度。所以，眼睛对于亮度的分辨要比对颜色的分辨精细一些。</p><p>利用这个原理，可以把色度信息减少一点，人眼也无法查觉这一点。</p><p>所以，并不是每个像素点都需要包含了 Y、U、V 三个分量，根据不同的采样格式，可以每个 Y 分量都对应自己的 UV 分量，也可以几个 Y 分量共用 UV 分量。<strong>相比 RGB，能够节约不少存储空间。</strong></p>        <h2 id="YUV-采样格式">          <a href="#YUV-采样格式" class="heading-link"><i class="fas fa-link"></i></a>YUV 采样格式</h2>      <p>YUV 图像的主流采样方式有如下三种：</p><ul><li>YUV 4:4:4 采样</li><li>YUV 4:2:2 采样</li><li>YUV 4:2:0 采样</li></ul>        <h3 id="YUV-4-4-4">          <a href="#YUV-4-4-4" class="heading-link"><i class="fas fa-link"></i></a>YUV 4:4:4</h3>      <p>YUV 4:4:4 表示 Y、U、V 三分量采样率相同，即每个像素的三分量信息完整，都是 8bit，每个像素占用 3 个字节。</p><p>如下图所示：</p><p><img src="/2019/07/28/yuv-format-explaination/yuv444.gif" alt="yuv444"></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">四个像素为： [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span><br><span class="line">采样的码流为： Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3</span><br><span class="line">映射出的像素点为：[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span><br></pre></td></tr></table></div></figure><p>可以看到这种采样方式与 RGB 图像大小是一样的。</p>        <h3 id="YUV-4-2-2">          <a href="#YUV-4-2-2" class="heading-link"><i class="fas fa-link"></i></a>YUV 4:2:2</h3>      <p>YUV 4:2:2 表示 UV 分量的采样率是 Y 分量的一半。</p><p>如下图所示：</p><p><img src="/2019/07/28/yuv-format-explaination/yuv422.gif" alt="yuv422"></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">四个像素为： [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span><br><span class="line">采样的码流为： Y0 U0 Y1 V1 Y2 U2 Y3 U3</span><br><span class="line">映射出的像素点为：[Y0 U0 V1]、[Y1 U0 V1]、[Y2 U2 V3]、[Y3 U2 V3]</span><br></pre></td></tr></table></div></figure><p>其中，每采样一个像素点，都会采样其 Y 分量，而 U、V 分量都会间隔采集一个，映射为像素点时，第一个像素点和第二个像素点共用了 U0、V1 分量，以此类推。从而节省了图像空间。</p><p>比如一张 1920 * 1280 大小的图片，采用 YUV 4:2:2 采样时的大小为：</p><blockquote><p>(1920 * 1280 * 8 + 1920 * 1280 * 0.5 * 8 * 2 ) / 8 / 1024 / 1024 = 4.68M</p></blockquote><p>可以看出，比 RGB 节省了三分之一的存储空间。</p>        <h3 id="YUV-4-2-0">          <a href="#YUV-4-2-0" class="heading-link"><i class="fas fa-link"></i></a>YUV 4:2:0</h3>      <p>YUV 4:2:0 并不意味着不采样 V 分量。它指的是对每条扫描线来说，只有一种色度分量以 2:1 的采样率存储，相邻的扫描行存储不同的色度分量。也就是说，如果第一行是 4:2:0，下一行就是 4:0:2，在下一行就是 4:2:0，以此类推。</p><p>如下图所示：</p><p><img src="/2019/07/28/yuv-format-explaination/yuv420.gif" alt="yuv420"></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">图像像素为：</span><br><span class="line">[Y0 U0 V0]、[Y1 U1 V1]、 [Y2 U2 V2]、 [Y3 U3 V3]</span><br><span class="line">[Y5 U5 V5]、[Y6 U6 V6]、 [Y7 U7 V7] 、[Y8 U8 V8]</span><br><span class="line"></span><br><span class="line">采样的码流为：</span><br><span class="line">Y0 U0 Y1 Y2 U2 Y3 </span><br><span class="line">Y5 V5 Y6 Y7 V7 Y8</span><br><span class="line"></span><br><span class="line">映射出的像素点为：</span><br><span class="line">[Y0 U0 V5]、[Y1 U0 V5]、[Y2 U2 V7]、[Y3 U2 V7]</span><br><span class="line">[Y5 U0 V5]、[Y6 U0 V5]、[Y7 U2 V7]、[Y8 U2 V7]</span><br></pre></td></tr></table></div></figure><p>其中，每采样一个像素点，都会采样 Y 分量，而 U、V 分量都会隔行按照 2:1 进行采样。</p><p>一张 1920 * 1280 大小的图片，采用 YUV 4:2:0 采样时的大小为：</p><blockquote><p>(1920 * 1280 * 8 + 1920 * 1280 * 0.25 * 8  * 2 ) / 8 / 1024 / 1024 = 3.51M</p></blockquote><p>相比 RGB，节省了一半的存储空间。</p>        <h2 id="YUV-存储格式">          <a href="#YUV-存储格式" class="heading-link"><i class="fas fa-link"></i></a>YUV 存储格式</h2>      <p>YUV 数据有两种存储格式：平面格式（planar format）和打包格式（packed format）。</p><ul><li>planar format：先连续存储所有像素点的 Y，紧接着存储所有像素点的 U，随后是所有像素点的 V。</li><li>packed format：每个像素点的 Y、U、V 是连续交错存储的。</li></ul><p>因为不同的采样方式和存储格式，就会产生多种 YUV 存储方式，这里只介绍基于 YUV422 和  YUV420 的存储方式。</p>        <h3 id="YUYV">          <a href="#YUYV" class="heading-link"><i class="fas fa-link"></i></a>YUYV</h3>      <p>YUYV 格式属于 YUV422，采用打包格式进行存储，Y 和 UV 分量按照 2:1 比例采样，每个像素都采集 Y 分量，每隔一个像素采集它的 UV 分量。</p><blockquote><p>Y0 U0 Y1 V0 Y2 U2 Y3 V2</p></blockquote><p>Y0 和 Y1 共用 U0 V0 分量，Y2 和 Y3 共用 U2 V2 分量。</p>        <h3 id="UYVY">          <a href="#UYVY" class="heading-link"><i class="fas fa-link"></i></a>UYVY</h3>      <p>UYVY 也是 YUV422 采样的存储格式中的一种，只不过与 YUYV 排列顺序相反。</p><blockquote><p>U0 Y0 V0 Y1 U2 Y2 V2 Y3</p></blockquote>        <h3 id="YUV-422P">          <a href="#YUV-422P" class="heading-link"><i class="fas fa-link"></i></a>YUV 422P</h3>      <p>YUV422P 属于 YUV422 的一种，它是一种 planer 模式，即 Y、U、V 分别存储。</p>        <h3 id="YUV420P-和-YUV420SP">          <a href="#YUV420P-和-YUV420SP" class="heading-link"><i class="fas fa-link"></i></a>YUV420P 和 YUV420SP</h3>      <p>YUV420P 是基于 planar 平面模式进行存储，先存储所有的 Y 分量，然后存储所有的 U 分量或者 V 分量。</p><p><img src="/2019/07/28/yuv-format-explaination/yuv420p.png" alt="yuv420p"></p><p>同样，YUV420SP 也是基于 planar 平面模式存储，与 YUV420P 的区别在于它的 U、V 分量是按照 UV 或者 VU 交替顺序进行存储。</p><p><img src="/2019/07/28/yuv-format-explaination/yuv420sp.png" alt="yuv420sp"></p>        <h3 id="YU12-和-YU21">          <a href="#YU12-和-YU21" class="heading-link"><i class="fas fa-link"></i></a>YU12 和 YU21</h3>      <p>YU12 和 YV12 格式都属于 YUV 420P 类型，即先存储 Y 分量，再存储 U、V 分量，区别在于：YU12 是先 Y 再 U 后 V，而 YV12 是先 Y 再 V 后 U 。</p>        <h3 id="NV21-和-NV21">          <a href="#NV21-和-NV21" class="heading-link"><i class="fas fa-link"></i></a>NV21 和 NV21</h3>      <p>NV12 和 NV21 格式都属于 YUV420SP 类型。它也是先存储了 Y 分量，但接下来并不是再存储所有的 U 或者 V 分量，而是把 UV 分量交替连续存储。</p><p>NV12 是 IOS 中有的模式，它的存储顺序是先存 Y 分量，再 UV 进行交替存储。</p><p>NV21 是 安卓 中有的模式，它的存储顺序是先存 Y 分量，在 VU 交替存储。</p>        <h2 id="YUV-与-RGB-转换">          <a href="#YUV-与-RGB-转换" class="heading-link"><i class="fas fa-link"></i></a>YUV 与 RGB 转换</h2>      <p>YUV 与 RGB 之间的转换，就是将 图像所有像素点的 R、G、B 分量和 Y、U、 分量相互转换。</p><p>有如下转换公式：</p><p><img src="/2019/07/28/yuv-format-explaination/yuv2rgb.png" alt="yuv2rgb"></p><p><img src="/2019/07/28/yuv-format-explaination/rgb2yuv.png" alt="rgb2yuv"></p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/wiki/YUV">https://zh.wikipedia.org/wiki/YUV</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://glumes.com/post/ffmpeg/understand-yuv-format/">https://glumes.com/post/ffmpeg/understand-yuv-format/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/MrJonathan/article/details/17718761">https://blog.csdn.net/MrJonathan/article/details/17718761</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="http://www.fourcc.org/pixel-format/yuv-i420/">http://www.fourcc.org/pixel-format/yuv-i420/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://msdn.microsoft.com/zh-cn/library/ms867704.aspx">https://msdn.microsoft.com/zh-cn/library/ms867704.aspx</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin Koans 学习笔记</title>
      <link href="2019/06/28/kotlin-koans-notes/"/>
      <url>2019/06/28/kotlin-koans-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p><span class="exturl"><a class="exturl__link" href="https://github.com/Kotlin/kotlin-koans">Kotlin Koans</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是 Kotlin 官方推出的一系列 Kotlin 语法练习。</p><p>一共分为 6 个模块，每个模块若干任务，每个任务都有一系列单元测试，目标就是编码通过单元测试。</p><p>本文是在学习 Kotlin Koans 过程中将相关语法点做一个简单的记录。</p></blockquote>        <h1 id="Introduction">          <a href="#Introduction" class="heading-link"><i class="fas fa-link"></i></a>Introduction</h1>              <h2 id="Hello-World">          <a href="#Hello-World" class="heading-link"><i class="fas fa-link"></i></a>Hello_World</h2>      <p>和大多数语言一样，第一个任务的名称就是 Hello World。这个任务很简单，就是要求 task0 函数返回一个字符串<code>ok</code>。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task0</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Kotlin 中函数使用关键字<code>fun</code>声明，返回类型在函数名称的后面，中间以<code>:</code>分开。</p>        <h2 id="Java-to-Kotlin-Convert">          <a href="#Java-to-Kotlin-Convert" class="heading-link"><i class="fas fa-link"></i></a>Java to Kotlin Convert</h2>      <p>将 Java 代码转化为 Kotlin 代码。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> String task1(Collection&lt;Integer&gt; collection) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = collection.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Integer element = iterator.next();</span><br><span class="line">        sb.append(element);</span><br><span class="line">        <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task1</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">Int</span>&gt;)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    sb.append(<span class="string">&quot;&#123;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> iterator = collection.iterator()</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> element = iterator.next()</span><br><span class="line">        sb.append(element)</span><br><span class="line">        <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Named-Arguments">          <a href="#Named-Arguments" class="heading-link"><i class="fas fa-link"></i></a>Named Arguments</h2>      <p>使用 kotlin 提供的 <code>joinToString()</code> 完成任务1，只指定 <code>joinToString()</code> 的参数。</p><p>kotlin 中函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语言相比，这可以减少重载数量：</p><p>默认值通过类型后面的<code>=</code>及给出的值定义。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, off: <span class="type">Int</span> = <span class="number">0</span>, len: <span class="type">Int</span> = b.size)</span></span> &#123; …… &#125;</span><br></pre></td></tr></table></div></figure><p>重写一个有默认参数的函数时，我们不允许重新指定默认参数的值。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123; …… &#125;  <span class="comment">// 不能有默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以在调用函数时使用命名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。</p><p>回到任务本身，先看一下函数 <code>joinToString</code>：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(separator: <span class="type">CharSequence</span> = <span class="string">&quot;, &quot;</span>, prefix: <span class="type">CharSequence</span> = <span class="string">&quot;&quot;</span>, postfix: <span class="type">CharSequence</span> = <span class="string">&quot;&quot;</span>, limit: <span class="type">Int</span> = <span class="number">-1</span>, truncated: <span class="type">CharSequence</span> = <span class="string">&quot;...&quot;</span>, transform: ((<span class="type">T</span>) -&gt; <span class="type">CharSequence</span>)? = <span class="literal">null</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>该函数对分隔符，前缀，后缀等其他参数都指定了默认值，我们只需要重新指定前缀、后缀两个参数。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task2</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">Int</span>&gt;)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> collection.joinToString(postfix = <span class="string">&quot;&#125;&quot;</span>,prefix = <span class="string">&quot;&#123;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Default-Arguments">          <a href="#Default-Arguments" class="heading-link"><i class="fas fa-link"></i></a>Default Arguments</h2>      <p>使用参数默认值，修改<code>foo</code>函数，实现 Java 中需要重载才能实现的功能。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(name: <span class="type">String</span>, number: <span class="type">Number</span> = <span class="number">42</span>, toUpperCase: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">if</span> (toUpperCase) name.toUpperCase() <span class="keyword">else</span> name) + number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (foo(<span class="string">&quot;a&quot;</span>) +</span><br><span class="line">            foo(<span class="string">&quot;b&quot;</span>, number = <span class="number">1</span>) +</span><br><span class="line">            foo(<span class="string">&quot;c&quot;</span>, toUpperCase = <span class="literal">true</span>) +</span><br><span class="line">            foo(name = <span class="string">&quot;d&quot;</span>, number = <span class="number">2</span>, toUpperCase = <span class="literal">true</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>非常简洁。这里还可以看出 <code>if</code> 是一个表达式，即它会返回一个值。 因此就不需要三元运算符（条件 ? 然后 : 否则）</p>        <h2 id="Lambdas">          <a href="#Lambdas" class="heading-link"><i class="fas fa-link"></i></a>Lambdas</h2>      <p>使用 Lambda 重写 Java 代码：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> boolean task4(Collection&lt;Integer&gt; collection) &#123;</span><br><span class="line">     <span class="keyword">return</span> Iterables.any(collection, new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> boolean apply(Integer element) &#123;</span><br><span class="line">             <span class="keyword">return</span> element % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task4</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Boolean</span> = collection.any &#123; x -&gt; x % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></div></figure><p>Lambda 表达式的特征：</p><ul><li>Lambdas 表达式是花括号括起来的代码块。</li><li>如果一个 lambda 表达式有参数，前面是参数，后跟<code>-&gt;</code> 。</li><li>函数体写在<code>-&gt;</code>符号后面。</li></ul>        <h2 id="String-Templates">          <a href="#String-Templates" class="heading-link"><i class="fas fa-link"></i></a>String Templates</h2>      <p>生成一个正则表达式，可以匹配<code>13 JUN 1992</code> 这样格式的字符串。</p><p>kotlin 中支持两种字符串格式：</p><p>一种是一对<code>&quot;</code>包起来的字符串，支持转义字符。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;Hello, world!\n&quot;</span></span><br></pre></td></tr></table></div></figure><p>一种是一对<code> &quot;&quot;&quot;</code>包起来的字符串，不需要用<code>\</code>来转义，可以直接使用各种符号，包括换行符。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val text &#x3D; &quot;&quot;&quot;</span><br><span class="line">    for (c in &quot;foo&quot;)</span><br><span class="line">        print(c)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></div></figure><p>字符串字面值可以包含<em>模板表达式</em> ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（<code>$</code>）开头，由一个简单的名字构成:</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>) <span class="comment">// 输出“i = 10”</span></span><br></pre></td></tr></table></div></figure><p>回到任务，修改模板字符串，使其可以匹配测试中的日期格式。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> month = <span class="string">&quot;(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task5</span><span class="params">()</span></span>: String = <span class="string">&quot;&quot;&quot;\d&#123;2&#125;\ <span class="variable">$month</span>\ \d&#123;4&#125;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></div></figure>        <h2 id="Data-Classes">          <a href="#Data-Classes" class="heading-link"><i class="fas fa-link"></i></a>Data Classes</h2>      <p>将 Java 中的数据实体类转化成 Kotlin。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> static <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> int age;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Person(String name, int age) &#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">         <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> int getAge() &#123;</span><br><span class="line">         <span class="keyword">return</span> age;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></div></figure><p>kotlin 中使用<code>data</code>标记的类，编译器会自动根据主构造函数中定义的属性生成下面这些成员函数：</p><ul><li><code>equals()</code>/<code>hashCode()</code> 对；</li><li><code>toString()</code> 格式是 <code>&quot;Person(name=John, age=42)&quot;</code>；</li><li><code>componentN()</code>按声明顺序对应于所有属性；</li><li><code>copy()</code> 函数。</li></ul>        <h2 id="Nullable-Type">          <a href="#Nullable-Type" class="heading-link"><i class="fas fa-link"></i></a>Nullable Type</h2>      <p>将 Java 版本的 <code>sendMessageToClient</code> 方法使用 kotlin 改写，只能使用 <code>if</code> 表达式。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageToClient</span><span class="params">(<span class="meta">@Nullable</span> Client client, <span class="meta">@Nullable</span> String message, <span class="meta">@NotNull</span> Mailer mailer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span> || message == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    PersonalInfo personalInfo = client.getPersonalInfo();</span><br><span class="line">    <span class="keyword">if</span> (personalInfo == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    String email = personalInfo.getEmail();</span><br><span class="line">    <span class="keyword">if</span> (email == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mailer.sendMessage(email, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>kotlin 中，如果一个变量可能为空，在定义的时候需要在类型后面加上 <code>?</code> </p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br></pre></td></tr></table></div></figure><p>对于可能为空的变量，如果必须在其值不为 null 时才进行后续操作，可以使用 <code>?.</code>操作符进行保护。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.toLong()</span><br></pre></td></tr></table></div></figure><p>如果变量为空，想要提供一个替代值，可以使用 <code>?:</code>：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b = a?.toLong() ?: <span class="number">0L</span></span><br></pre></td></tr></table></div></figure><p>回到任务本身。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendMessageToClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        client: <span class="type">Client</span>?, message: <span class="type">String</span>?, mailer: <span class="type">Mailer</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> email = client?.personalInfo?.email</span><br><span class="line">    <span class="keyword">if</span> (email != <span class="literal">null</span> &amp;&amp; message != <span class="literal">null</span>) &#123;</span><br><span class="line">        mailer.sendMessage(email,message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Smart-Casts">          <a href="#Smart-Casts" class="heading-link"><i class="fas fa-link"></i></a>Smart Casts</h2>      <p>使用 kotlin 中 的Smart Cast 和 when表达式重新实现 Java 代码中的 <code>eval()</code> 函数。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eval</span><span class="params">(Expr expr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expr <span class="keyword">instanceof</span> Num) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Num) expr).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expr <span class="keyword">instanceof</span> Sum) &#123;</span><br><span class="line">        Sum sum = (Sum) expr;</span><br><span class="line">        <span class="keyword">return</span> eval(sum.getLeft()) + eval(sum.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown expression&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>kotlin 中使用<code>when</code>代替了<code>switch</code>，功能更强大。</p><p>在 <code>when</code> 中，我们使用 <code>-&gt;</code> 表示执行某一分支后的操作，<code>-&gt;</code> 之前是条件，可以是任何表达式。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 0 or x == 1&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;otherwise&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt; print(<span class="string">&quot;x is in the range&quot;</span>)</span><br><span class="line">    <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">&quot;x is valid&quot;</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">&quot;x is outside the range&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;none of the above&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>回到任务本身。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown expression&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Extension-Functions">          <a href="#Extension-Functions" class="heading-link"><i class="fas fa-link"></i></a>Extension Functions</h2>      <p>kotlin 支持为已经存在的类编写扩展方法，而且不需要对原有类进行任何改动，只需要使用<code>className.extensionFun</code>的形式就可以了</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br></pre></td></tr></table></div></figure><p>任务要求为<code>Int</code>和<code>Pair&lt;Int, Int&gt;</code>分别实现一个扩展函数<code>r()</code>。<code>r()</code>函数的功能就是创建一个有理数。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RationalNumber</span></span>(<span class="keyword">val</span> numerator: <span class="built_in">Int</span>, <span class="keyword">val</span> denominator: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">r</span><span class="params">()</span></span>: RationalNumber = RationalNumber(<span class="keyword">this</span>, <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Pair<span class="type">&lt;Int, Int&gt;</span>.<span class="title">r</span><span class="params">()</span></span>: RationalNumber = RationalNumber(<span class="keyword">this</span>.first, <span class="keyword">this</span>.second)</span><br></pre></td></tr></table></div></figure>        <h2 id="Object-Expression">          <a href="#Object-Expression" class="heading-link"><i class="fas fa-link"></i></a>Object Expression</h2>      <p>任务的要求是创建一个比较器（comparator），提供给 Collection 类对 list 按照降序排序。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task10</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> arrayList = arrayListOf(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">    Collections.sort(arrayList, <span class="keyword">object</span> : Comparator&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(o1: <span class="type">Int</span>, o2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arrayList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="SAM-Conversions">          <a href="#SAM-Conversions" class="heading-link"><i class="fas fa-link"></i></a>SAM Conversions</h2>      <p>SAM conversions 就是如果一个 object 实现了一个 SAM（Single Abstract Method）接口时，可以直接传递一个 lambda 表达式。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task11</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> arrayList = arrayListOf(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">    arrayList.sortWith(Comparator &#123; x, y -&gt; y - x &#125;)</span><br><span class="line">    <span class="keyword">return</span> arrayList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Extensions-On-Collections">          <a href="#Extensions-On-Collections" class="heading-link"><i class="fas fa-link"></i></a>Extensions On Collections</h2>      <p>使用扩展函数<code>sortedDescending</code>重写上一个任务中的代码：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task12</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayListOf(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>).sortedDescending()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Collections">          <a href="#Collections" class="heading-link"><i class="fas fa-link"></i></a>Collections</h1>      <p>这一模块主要是集合的一些任务，所有任务都是围绕一个商店（Shop）展开，商店有一个客户（Customer）列表。</p><p>客户具有姓名、城市和订单（Order）列表三个属性。</p><p>订单具有商品（Product）列表和是否已经发货两个属性。</p><p>商品具有名称和价格两个属性。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> customers: List&lt;Customer&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> city: City, <span class="keyword">val</span> orders: List&lt;Order&gt;) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;<span class="variable">$name</span> from <span class="subst">$&#123;city.name&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>(<span class="keyword">val</span> products: List&lt;Product&gt;, <span class="keyword">val</span> isDelivered: <span class="built_in">Boolean</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;&#x27;<span class="variable">$name</span>&#x27; for <span class="variable">$price</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Introduction-1">          <a href="#Introduction-1" class="heading-link"><i class="fas fa-link"></i></a>Introduction</h2>      <p>要求返回一个 <code>Set</code>，包含商店中所有的客户：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getSetOfCustomers</span><span class="params">()</span></span>: Set&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// Return a set containing all the customers of this shop</span></span><br><span class="line">    <span class="keyword">return</span> customers.toSet()</span><br><span class="line"><span class="comment">//    return this.customers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Filter-Map">          <a href="#Filter-Map" class="heading-link"><i class="fas fa-link"></i></a>Filter Map</h2>      <p><code>filter</code> 方法返回一个包含所有满足指定条件元素的列表。</p><p>任务第一个要求返回指定城市所有客户的列表。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getCustomersFrom</span><span class="params">(city: <span class="type">City</span>)</span></span>: List&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// Return a list of the customers who live in the given city</span></span><br><span class="line">    <span class="keyword">return</span> customers.filter &#123; it.city == city &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>map</code> 方法将指定的转换函数运用到原始集合的每一个元素，并返回一个转换后的集合。</p><p>任务第二个要求返回所有客户所在城市的 Set。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getCitiesCustomersAreFrom</span><span class="params">()</span></span>: Set&lt;City&gt; &#123;</span><br><span class="line">    <span class="comment">// Return the set of cities the customers are from</span></span><br><span class="line">    <span class="keyword">return</span> customers.map &#123; it.city &#125;.toSet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="All-Any-and-others-Predicates">          <a href="#All-Any-and-others-Predicates" class="heading-link"><i class="fas fa-link"></i></a>All Any and others Predicates</h2>      <p><code>all</code>：如果所有的元素都满足指定的条件返回 true。</p><p><code>any</code>：如果至少有一个元素满足指定的条件返回 ture。</p><p><code>count</code>：返回满足指定条件的元素数量。</p><p><code>firstOrAll</code>：返回第一个满足指定条件的元素，如果没有就返回 null。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Customer.<span class="title">isFrom</span><span class="params">(city: <span class="type">City</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// Return true if the customer is from the given city</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.city == city</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">checkAllCustomersAreFrom</span><span class="params">(city: <span class="type">City</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// Return true if all customers are from the given city</span></span><br><span class="line">    <span class="keyword">return</span> customers.all &#123; it.isFrom(city) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">hasCustomerFrom</span><span class="params">(city: <span class="type">City</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// Return true if there is at least one customer from the given city</span></span><br><span class="line">    <span class="keyword">return</span> customers.any &#123; it.isFrom(city) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">countCustomersFrom</span><span class="params">(city: <span class="type">City</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// Return the number of customers from the given city</span></span><br><span class="line">    <span class="keyword">return</span> customers.count &#123; it.isFrom(city) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">findFirstCustomerFrom</span><span class="params">(city: <span class="type">City</span>)</span></span>: Customer? &#123;</span><br><span class="line">    <span class="comment">// Return the first customer who lives in the given city, or null if there is none</span></span><br><span class="line">    <span class="keyword">return</span> customers.firstOrNull &#123; it.isFrom(city) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="FlatMap">          <a href="#FlatMap" class="heading-link"><i class="fas fa-link"></i></a>FlatMap</h2>      <p><code>flatmap</code>：针对列表中的每一项根据指定的方法生成一个列表，最后将所有的列表拼接成一个列表返回。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个客户所有已订购的产品</span></span><br><span class="line"><span class="keyword">val</span> Customer.orderedProducts: Set&lt;Product&gt;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// Return all products this customer has ordered</span></span><br><span class="line">        <span class="keyword">return</span> orders.flatMap &#123; it.products &#125;.toSet()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回所有至少被一个客户订购过的商品集合</span></span><br><span class="line"><span class="keyword">val</span> Shop.allOrderedProducts: Set&lt;Product&gt;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// Return all products that were ordered by at least one customer</span></span><br><span class="line">        <span class="keyword">return</span> customers.flatMap &#123; it.orderedProducts &#125;.toSet()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Max-Min">          <a href="#Max-Min" class="heading-link"><i class="fas fa-link"></i></a>Max Min</h2>      <p><code>max</code>：返回集合中最大的元素。如果没有元素则返回 null。</p><p><code>maxby</code>：使用函数参数计算的值作为比较对象。返回最大的元素中的值。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回商店中订单数目最多的一个客户。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getCustomerWithMaximumNumberOfOrders</span><span class="params">()</span></span>: Customer? &#123;</span><br><span class="line">    <span class="comment">// Return a customer whose order count is the highest among all customers</span></span><br><span class="line">    <span class="keyword">return</span> customers.maxBy &#123; it.orders.size &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个客户所订购商品中价格最高的一个商品</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Customer.<span class="title">getMostExpensiveOrderedProduct</span><span class="params">()</span></span>: Product? &#123;</span><br><span class="line">    <span class="comment">// Return the most expensive product which has been ordered</span></span><br><span class="line">    <span class="keyword">return</span> orders.flatMap &#123; it.products &#125;.maxBy &#123; it.price &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Sort">          <a href="#Sort" class="heading-link"><i class="fas fa-link"></i></a>Sort</h2>      <p>kotlin 中可以通过 <code>sortby</code>指定排序的标准。</p><p>任务要求返回一个客户列表，客户的顺序是根据订单的数量由低到高。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getCustomersSortedByNumberOfOrders</span><span class="params">()</span></span>: List&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// Return a list of customers, sorted by the ascending number of orders they made</span></span><br><span class="line">    <span class="keyword">return</span> customers.sortedBy &#123; it.orders.size &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Sum">          <a href="#Sum" class="heading-link"><i class="fas fa-link"></i></a>Sum</h2>      <p><code>sumby</code>：将集合中所有元素按照指定的函数变换以后的结果累加。</p><p>任务要求计算一个客户所有已订购商品的价格总和。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Customer.<span class="title">getTotalOrderPrice</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="comment">// Return the sum of prices of all products that a customer has ordered.</span></span><br><span class="line">    <span class="comment">// Note: a customer may order the same product several times.</span></span><br><span class="line">    <span class="keyword">return</span> orders.flatMap &#123; it.products &#125;.sumByDouble &#123; it.price &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="GroupBy">          <a href="#GroupBy" class="heading-link"><i class="fas fa-link"></i></a>GroupBy</h2>      <p><code>groupBy</code>方法返回一个根据指定条件分组好的 map。</p><p>任务要求返回来自每一个城市的客户的 map：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">groupCustomersByCity</span><span class="params">()</span></span>: Map&lt;City, List&lt;Customer&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Return a map of the customers living in each city</span></span><br><span class="line">    <span class="keyword">return</span> customers.groupBy &#123; it.city &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Partition">          <a href="#Partition" class="heading-link"><i class="fas fa-link"></i></a>Partition</h2>      <p><code>partition</code>：将原始的集合分为一对集合，这一对集合中第一个是满足指定条件的元素集合，第二个是不满足指定条件的集合。</p><p>任务要求返回所有未发货订单数目多于已发货订单的用户。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getCustomersWithMoreUndeliveredOrdersThanDelivered</span><span class="params">()</span></span>: Set&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// Return customers who have more undelivered orders than delivered</span></span><br><span class="line">    <span class="keyword">return</span> customers.filter &#123;</span><br><span class="line">        <span class="keyword">val</span> (delivered, undelivered) = it.orders.partition &#123; it.isDelivered &#125;</span><br><span class="line">        delivered.size &lt; undelivered.size</span><br><span class="line">    &#125;.toSet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Fold">          <a href="#Fold" class="heading-link"><i class="fas fa-link"></i></a>Fold</h2>      <p><code>fold</code>：给定一个初始值，然后通过迭代对集合中的每一个元素执行指定的操作并将操作的结果累加。</p><p>任务要求返回所有客户都订购过的商品。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getSetOfProductsOrderedByEachCustomer</span><span class="params">()</span></span>: Set&lt;Product&gt; &#123;</span><br><span class="line">    <span class="comment">// Return the set of products that were ordered by each of the customers</span></span><br><span class="line">    <span class="keyword">return</span> customers.fold(allOrderedProducts, &#123; orderedByAll, customer -&gt;</span><br><span class="line">        orderedByAll.intersect(customer.orderedProducts)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></div></figure>        <h2 id="CompoundTasks">          <a href="#CompoundTasks" class="heading-link"><i class="fas fa-link"></i></a>CompoundTasks</h2>      <p>上述方法的混合使用。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Customer.<span class="title">hasOrderedProduct</span><span class="params">(product: <span class="type">Product</span>)</span></span> = orders.any &#123; it.products.contains(product) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有购买了指定商品的客户列表</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getCustomersWhoOrderedProduct</span><span class="params">(product: <span class="type">Product</span>)</span></span>: Set&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// Return the set of customers who ordered the specified product</span></span><br><span class="line">    <span class="keyword">return</span> customers.filter &#123; it.hasOrderedProduct(product) &#125;.toSet()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个用户所有已发货的商品中最昂贵的商品</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Customer.<span class="title">getMostExpensiveDeliveredProduct</span><span class="params">()</span></span>: Product? &#123;</span><br><span class="line">    <span class="comment">// Return the most expensive product among all delivered products</span></span><br><span class="line">    <span class="comment">// (use the Order.isDelivered flag)</span></span><br><span class="line">    <span class="keyword">return</span> orders.filter &#123; it.isDelivered &#125;.flatMap &#123; it.products &#125;.maxBy &#123; it.price &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找指定商品被购买的次数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shop.<span class="title">getNumberOfTimesProductWasOrdered</span><span class="params">(product: <span class="type">Product</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// Return the number of times the given product was ordered.</span></span><br><span class="line">    <span class="comment">// Note: a customer may order the same product for several times.</span></span><br><span class="line">    <span class="keyword">return</span> customers.flatMap &#123; it.orders.flatMap &#123; it.products &#125; &#125;.count &#123; it == product &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Extensions-On-Collections-1">          <a href="#Extensions-On-Collections-1" class="heading-link"><i class="fas fa-link"></i></a>Extensions On Collections</h2>      <p>重写 Java 代码</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSomethingStrangeWithCollection</span><span class="params">(Collection&lt;String&gt; collection)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; groupsByLength = Maps.newHashMap();</span><br><span class="line">    <span class="keyword">for</span> (String s : collection) &#123;</span><br><span class="line">        List&lt;String&gt; strings = groupsByLength.get(s.length());</span><br><span class="line">        <span class="keyword">if</span> (strings == <span class="keyword">null</span>) &#123;</span><br><span class="line">            strings = Lists.newArrayList();</span><br><span class="line">            groupsByLength.put(s.length(), strings);</span><br><span class="line">        &#125;</span><br><span class="line">        strings.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maximumSizeOfGroup = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; group : groupsByLength.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (group.size() &gt; maximumSizeOfGroup) &#123;</span><br><span class="line">            maximumSizeOfGroup = group.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; group : groupsByLength.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (group.size() == maximumSizeOfGroup) &#123;</span><br><span class="line">            <span class="keyword">return</span> group;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>方法的目的是：</p><ul><li>将一个字符串集合按照长度分组，放入一个 map 中</li><li>求出 map 中所有元素 (String List) 的最大长度</li><li>根据步骤2的结果，返回 map 中字符串数目最多的那一组</li></ul><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomethingStrangeWithCollection</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span>: Collection&lt;String&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> groupsByLength = collection.groupBy &#123; s -&gt; s.length &#125;</span><br><span class="line">    <span class="keyword">return</span> groupsByLength.values.maxBy &#123; group -&gt; group.size &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Conventions">          <a href="#Conventions" class="heading-link"><i class="fas fa-link"></i></a>Conventions</h1>              <h2 id="Comparsion">          <a href="#Comparsion" class="heading-link"><i class="fas fa-link"></i></a>Comparsion</h2>      <p>实现日期对象大小的比较</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task25</span><span class="params">(date1: <span class="type">MyDate</span>, date2: <span class="type">MyDate</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> date1 &lt; date2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>其中类 <code>MyDate</code>需要实现 <code>Comparable</code>接口。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>(<span class="keyword">val</span> year: <span class="built_in">Int</span>, <span class="keyword">val</span> month: <span class="built_in">Int</span>, <span class="keyword">val</span> dayOfMonth: <span class="built_in">Int</span>) : Comparable&lt;MyDate&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">MyDate</span>)</span></span> =</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                other.year != year -&gt; year - other.year</span><br><span class="line">                other.month != month -&gt; month - other.month</span><br><span class="line">                <span class="keyword">else</span> -&gt; dayOfMonth - other.dayOfMonth</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="InRange">          <a href="#InRange" class="heading-link"><i class="fas fa-link"></i></a>InRange</h2>      <p>实现检查指定的日期是不是在某一个日期范围内。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkInRange</span><span class="params">(date: <span class="type">MyDate</span>, first: <span class="type">MyDate</span>, last: <span class="type">MyDate</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> date <span class="keyword">in</span> DateRange(first, last)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>DateRange 类已经定义好，需要添加 <code>contains</code>函数。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateRange</span></span>(<span class="keyword">val</span> start: MyDate, <span class="keyword">val</span> endInclusive: MyDate) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(value: <span class="type">MyDate</span>)</span></span>: <span class="built_in">Boolean</span> = start &lt;= value &amp;&amp; value &lt;= endInclusive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="RangeTo">          <a href="#RangeTo" class="heading-link"><i class="fas fa-link"></i></a>RangeTo</h2>      <p>这一个任务是要求实现<code>MyDate</code>类的<code>..</code>运算符。<code>..</code>运算符最终会翻译成<code>rangeTo()</code>函数，所以本任务就是实现<code>MyDate.rangeTo()</code>。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> MyDate.<span class="title">rangeTo</span><span class="params">(other: <span class="type">MyDate</span>)</span></span>: DateRange = DateRange(<span class="keyword">this</span>, other)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkInRange2</span><span class="params">(date: <span class="type">MyDate</span>, first: <span class="type">MyDate</span>, last: <span class="type">MyDate</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">//todoTask27()</span></span><br><span class="line">    <span class="keyword">return</span> date <span class="keyword">in</span> first..last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="ForLoop">          <a href="#ForLoop" class="heading-link"><i class="fas fa-link"></i></a>ForLoop</h2>      <p>任务要求对 DateRange 内的 MyDate 执行 for 循环，因此 DateRange 需要实现 Iterable 接口。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateRange</span></span>(<span class="keyword">val</span> start: MyDate, <span class="keyword">val</span> endInclusive: MyDate) : Iterable&lt;MyDate&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;MyDate&gt; = DateIterator(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(value: <span class="type">MyDate</span>)</span></span>: <span class="built_in">Boolean</span> = start &lt;= value &amp;&amp; value &lt;= endInclusive</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateIterator</span></span>(<span class="keyword">val</span> dateRange: DateRange) : Iterator&lt;MyDate&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> current: MyDate = dateRange.start</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = current &lt;= dateRange.endInclusive</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: MyDate &#123;</span><br><span class="line">        <span class="keyword">val</span> result = current</span><br><span class="line">        current = current.nextDay()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="OperatorOverloading">          <a href="#OperatorOverloading" class="heading-link"><i class="fas fa-link"></i></a>OperatorOverloading</h2>      <p>重载 <code>+</code>运算符：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> MyDate.<span class="title">plus</span><span class="params">(timeInterval: <span class="type">TimeInterval</span>)</span></span> = addTimeIntervals(timeInterval, <span class="number">1</span>)</span><br></pre></td></tr></table></div></figure><p>重载<code>*</code>运算符：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将TimeInterval的乘法结果定义成RepeatedTimeInterval</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepeatedTimeInterval</span></span>(<span class="keyword">val</span> timeInterval: TimeInterval, <span class="keyword">val</span> number: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> TimeInterval.<span class="title">times</span><span class="params">(number: <span class="type">Int</span>)</span></span> = RepeatedTimeInterval(<span class="keyword">this</span>, number)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> MyDate.<span class="title">plus</span><span class="params">(timeIntervals: <span class="type">RepeatedTimeInterval</span>)</span></span> = addTimeIntervals(timeIntervals.timeInterval, timeIntervals.number)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h2 id="Destructuring-Declaration">          <a href="#Destructuring-Declaration" class="heading-link"><i class="fas fa-link"></i></a>Destructuring Declaration</h2>      <p>kotlin 可以将一个对象的所有属性一次赋值给一堆变量</p><p>任务要求判断一个日期是否是闰年。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>(<span class="keyword">val</span> year: <span class="built_in">Int</span>, <span class="keyword">val</span> month: <span class="built_in">Int</span>, <span class="keyword">val</span> dayOfMonth: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLeapDay</span><span class="params">(date: <span class="type">MyDate</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (year, month, dayOfMonth) = date</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 29 February of a leap year</span></span><br><span class="line">    <span class="keyword">return</span> isLeapYear(year) &amp;&amp; month == <span class="number">1</span> &amp;&amp; dayOfMonth == <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Years which are multiples of four (with the exception of years divisible by 100 but not by 400)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLeapYear</span><span class="params">(year: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> = year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></div></figure>        <h2 id="Invoke">          <a href="#Invoke" class="heading-link"><i class="fas fa-link"></i></a>Invoke</h2>      <p>如果一个类实现了<code>invoke</code>函数，那么该类的实体对象在调用这个函数时可以省略函数名，<code>invoke</code>函数需要有<code>operator</code>修饰符。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task31</span><span class="params">(invokable: <span class="type">Invokable</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> invokable()()()().numberOfInvocations</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invokable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfInvocations: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: Invokable &#123;</span><br><span class="line">        numberOfInvocations++</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Properties">          <a href="#Properties" class="heading-link"><i class="fas fa-link"></i></a>Properties</h1>              <h2 id="Properties-1">          <a href="#Properties-1" class="heading-link"><i class="fas fa-link"></i></a>Properties</h2>      <p>kotlin 中可以为属性自定义 setter，格式如下：</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyExample</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> propertyWithCounter: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>每次为 <code>propertyWithCounter</code> 赋值时，都会调用 <code>set</code>，kotlin 中不能直接声明字段，然而，当一个属性需要一个幕后字段时，Kotlin 会自动提供。这个幕后字段可以使用<code>field</code>标识符在访问器中引用。</p>        <h2 id="LazyProperty">          <a href="#LazyProperty" class="heading-link"><i class="fas fa-link"></i></a>LazyProperty</h2>      <p><code>initializer</code>是一个<code>lambda </code>表达式，这个表达式会在<code>lazy</code>属性第一次被访问的时候执行，且仅执行一次</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyProperty</span></span>(<span class="keyword">val</span> initializer: () -&gt; <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> lazy: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            value = initializer()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="DelegatesExamples">          <a href="#DelegatesExamples" class="heading-link"><i class="fas fa-link"></i></a>DelegatesExamples</h2>      <p>用委托实现懒加载</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyPropertyUsingDelegates</span></span>(<span class="keyword">val</span> initializer: () -&gt; <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> lazyValue: <span class="built_in">Int</span> <span class="keyword">by</span> lazy(initializer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="HowDelegatesWork">          <a href="#HowDelegatesWork" class="heading-link"><i class="fas fa-link"></i></a>HowDelegatesWork</h2>      <figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDate</span>&lt;<span class="type">R</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">R, MyDate</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeInMillis: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: MyDate = timeInMillis!!.toDate()</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">MyDate</span>)</span></span> &#123; timeInMillis = value.toMillis() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Builders">          <a href="#Builders" class="heading-link"><i class="fas fa-link"></i></a>Builders</h1>              <h2 id="ExtensionFunctionLiterals">          <a href="#ExtensionFunctionLiterals" class="heading-link"><i class="fas fa-link"></i></a>ExtensionFunctionLiterals</h2>      <figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task36</span><span class="params">()</span></span>: List&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> isEven: <span class="built_in">Int</span>.() -&gt; <span class="built_in">Boolean</span> = &#123; <span class="keyword">this</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> isOdd: <span class="built_in">Int</span>.() -&gt; <span class="built_in">Boolean</span> = &#123; <span class="keyword">this</span> % <span class="number">2</span> != <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="number">42</span>.isOdd(), <span class="number">239</span>.isOdd(), <span class="number">294823098</span>.isEven())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="StringAndMapBuilders">          <a href="#StringAndMapBuilders" class="heading-link"><i class="fas fa-link"></i></a>StringAndMapBuilders</h2>      <p>类型扩展函数，仿照<code>buildString</code>实现<code>buildMap</code></p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> <span class="title">buildMap</span><span class="params">(build: <span class="type">MutableMap</span>&lt;<span class="type">K</span>, V&gt;.()</span></span> -&gt; <span class="built_in">Unit</span>): Map&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;K, V&gt;()</span><br><span class="line">    map.build()</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">task37</span><span class="params">()</span></span>: Map&lt;<span class="built_in">Int</span>, String&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> buildMap &#123;</span><br><span class="line">        put(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">            put(i, <span class="string">&quot;<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="TheFunctionApply">          <a href="#TheFunctionApply" class="heading-link"><i class="fas fa-link"></i></a>TheFunctionApply</h2>      <p>使用<code>apply</code>重写上一练习中的功能</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">myApply</span><span class="params">(f: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    f()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="HtmlBuilders">          <a href="#HtmlBuilders" class="heading-link"><i class="fas fa-link"></i></a>HtmlBuilders</h2>      <p>把<code>products</code>填充进表格，并设置好背景色，运行<code>htmlDemo.kt</code>可以预览内容</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">renderProductTable</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> html &#123;</span><br><span class="line">        table &#123;</span><br><span class="line">            tr &#123;</span><br><span class="line">                td &#123;</span><br><span class="line">                    text(<span class="string">&quot;Product&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                td &#123;</span><br><span class="line">                    text(<span class="string">&quot;Price&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                td &#123;</span><br><span class="line">                    text(<span class="string">&quot;Popularity&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> products = getProducts()</span><br><span class="line">            <span class="keyword">for</span> ((index, product) <span class="keyword">in</span> products.withIndex()) &#123;</span><br><span class="line">                tr &#123;</span><br><span class="line">                    td (color = getCellColor(index, <span class="number">0</span>)) &#123;</span><br><span class="line">                        text(product.description)</span><br><span class="line">                    &#125;</span><br><span class="line">                    td (color = getCellColor(index, <span class="number">1</span>)) &#123;</span><br><span class="line">                        text(product.price)</span><br><span class="line">                    &#125;</span><br><span class="line">                    td (color = getCellColor(index, <span class="number">2</span>)) &#123;</span><br><span class="line">                        text(product.popularity)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h2 id="BuildersHowItWorks">          <a href="#BuildersHowItWorks" class="heading-link"><i class="fas fa-link"></i></a>BuildersHowItWorks</h2>      <p>1：c，<code>td</code>是一个方法，这里的<code>td</code>显然是在调用<br>2：b，<code>color</code>是参数名，这里使用了命名参数<br>3：b，这里是个<code>lambda</code>表达式<br>4：c，<code>this</code>指向调用者</p>        <h1 id="Generics">          <a href="#Generics" class="heading-link"><i class="fas fa-link"></i></a>Generics</h1>              <h2 id="GenericsFunctions">          <a href="#GenericsFunctions" class="heading-link"><i class="fas fa-link"></i></a>GenericsFunctions</h2>      <p>根据条件将一个集合分为两个集合。</p><figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, C: MutableCollection&lt;T&gt;</span>&gt; Collection<span class="type">&lt;T&gt;</span>.<span class="title">partitionTo</span><span class="params">(first: <span class="type">C</span>, second: <span class="type">C</span>, predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: Pair&lt;C, C&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate(element)) &#123;</span><br><span class="line">            first.add(element)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            second.add(element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pair(first, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 图片预览库封装</title>
      <link href="2019/05/07/Android-PhotoViewEx/"/>
      <url>2019/05/07/Android-PhotoViewEx/</url>
      
        <content type="html"><![CDATA[<p>基于 <span class="exturl"><a class="exturl__link" href="https://github.com/chrisbanes/PhotoView">PhotoView</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，增加手势旋转、拖动退出预览功能。</p><p>GitHub：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/PhotoViewEx">PhotoViewEx</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="依赖">          <a href="#依赖" class="heading-link"><i class="fas fa-link"></i></a>依赖</h2>      <p>在项目 <code>build.gradle</code> 中添加依赖</p><figure class="highlight groovy"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>module 的 <code>build.gradle</code> 中添加依赖</p><figure class="highlight groovy"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.github.zywudev:PhotoViewEx:1.0.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="使用方法">          <a href="#使用方法" class="heading-link"><i class="fas fa-link"></i></a>使用方法</h2>      <p>使用下面的方式即可实现缩放、双指旋转功能。</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.wuzy.photoviewex.PhotoView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/iv_photo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhotoView photoView = (PhotoView) findViewById(R.id.iv_photo);</span><br><span class="line">photoView.setImageResource(R.drawable.image);</span><br></pre></td></tr></table></div></figure><p><strong>拖动关闭使用方法</strong>：</p><p>1、Activity 主题设为透明</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowIsTranslucent&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>2、初始化</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DragCloseHelper mDragCloseHelper = <span class="keyword">new</span> DragCloseHelper(<span class="keyword">this</span>);</span><br></pre></td></tr></table></div></figure><p>3、设置需要拖拽的 View 以及背景 ViewGroup</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDragCloseHelper.setDragCloseViews(mConstraintLayout,mPhotoView);</span><br></pre></td></tr></table></div></figure><p>4、设置监听</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mDragCloseHelper.setOnDragCloseListener(<span class="keyword">new</span> OnDragCloseListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDragBegin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDragging</span><span class="params">(<span class="keyword">float</span> percent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDragEnd</span><span class="params">(<span class="keyword">boolean</span> isShareElementMode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShareElementMode) &#123;</span><br><span class="line">            onBackPressed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDragCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">intercept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure><p>5、处理 Touch 事件</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDragCloseHelper.handleEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>更多使用方法参见 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/PhotoViewEx/tree/master/sample">sample</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><p><span class="exturl"><a class="exturl__link" href="https://github.com/chrisbanes/PhotoView">PhotoView</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="https://github.com/ChenSiLiang/RotatePhotoView">RotatePhotoView</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="https://github.com/bauer-bao/DragCloseHelper">DragCloseHelper</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 源码分析（三）：连接机制</title>
      <link href="2019/03/27/ok-analysis-3/"/>
      <url>2019/03/27/ok-analysis-3/</url>
      
        <content type="html"><![CDATA[<p>前面两篇文章分别介绍了 OkHttp 的请求流程和缓存机制，最后这篇文章介绍 OkHttp 的连接机制，作为 OkHttp 源码分析的收尾。</p><p>建议将 OkHttp 的源码下载下来，使用 IDEA 编辑器可以直接打开阅读。我这边也将最新版的源码下载下来，进行了注释说明，有需要的可以直接从 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/android-open-framework-analysis">Android open framework analysis</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 查看。</p>        <h2 id="创建连接">          <a href="#创建连接" class="heading-link"><i class="fas fa-link"></i></a>创建连接</h2>      <p>OkHttp 连接的创建是通过 StreamAllocation 对象统筹完成。</p><p>它主要用来管理两个角色：</p><ul><li>RealConnection：真正建立连接的对象，利用 Socket 建立连接。</li><li>ConnectionPool：连接池，用来管理和复用连接。</li></ul><p>StreamAllocation 是在 RetryAndFollowUpInterceptor 中被创建，此时并未发起连接。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RetryAndFollowUpInterceptor .intercept()</span></span><br><span class="line"></span><br><span class="line">StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br></pre></td></tr></table></div></figure><p>真正的连接是在处理完 Header 和缓存之后，调用 ConnectInterceptor 进行的。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConnectInterceptor.intercept()</span></span><br><span class="line">    </span><br><span class="line">StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line"><span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">RealConnection connection = streamAllocation.connection();</span><br></pre></td></tr></table></div></figure><p>这里创建了两个对象：</p><ul><li>HttpCodec：用来编码 http request 和解码 http response</li><li>RealConnection：上文介绍了。</li></ul><p>调用 streamAllocation 的 <code>newStream</code> 方法经过一系列判断最终会走到 <code>findConnection</code> 方法</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    Connection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;released&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;codec != null&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1、尝试使用已分配的连接</span></span><br><span class="line">      releasedConnection = <span class="keyword">this</span>.connection;</span><br><span class="line">      toClose = releaseIfNoNewStreams();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前连接可用.</span></span><br><span class="line">        result = <span class="keyword">this</span>.connection;</span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!reportedAcquired) &#123;</span><br><span class="line">        <span class="comment">// If the connection was never reported acquired, don&#x27;t report it as released!</span></span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2、尝试从连接池中获取一个连接</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">        Internal.instance.acquire(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          selectedRoute = route;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果从连接池中获取到了一个连接，就将其返回.</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">        <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">        <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">        <span class="comment">// 根据一系列的 IP地址从连接池中获取一个链接</span></span><br><span class="line">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">          Route route = routes.get(i);</span><br><span class="line">          <span class="comment">// 从连接池中获取一个连接</span></span><br><span class="line">          Internal.instance.acquire(connectionPool, address, <span class="keyword">this</span>, route);</span><br><span class="line">          <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">            result = connection;</span><br><span class="line">            <span class="keyword">this</span>.route = route;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3、如果连接池中没有可用连接，则创建一个</span></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">          selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">        <span class="comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span></span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we found a pooled connection on the 2nd time around, we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、 开始TCP以及TLS握手操作</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">    routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      reportedAcquired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5、将新创建的连接，放在连接池中.</span></span><br><span class="line">      Internal.instance.put(connectionPool, result);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class="line">      <span class="comment">// release this connection and acquire that one.</span></span><br><span class="line">      <span class="keyword">if</span> (result.isMultiplexed()) &#123;</span><br><span class="line">        socket = Internal.instance.deduplicate(connectionPool, address, <span class="keyword">this</span>);</span><br><span class="line">        result = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure><p>整个流程是：</p><ul><li>1、判断当前的连接是否可以使用：输入输出流没有关闭，Socket 未关闭等</li><li>2、如果当前连接不可用，尝试从连接池中获取一个可用连接</li><li>3、如果连接池中没有可用连接，则创建一个连接</li><li>4、开始 TCP 连接以及 TLS 握手操作</li><li>5、将新创建的连接加入到连接池中</li></ul>        <h2 id="连接池">          <a href="#连接池" class="heading-link"><i class="fas fa-link"></i></a>连接池</h2>      <p>网络请求时频繁地进行 Socket 连接和断开 Socket 非常消耗网络资源和浪费时间，连接复用可以提升网络访问的效率。这里就引入了连接池的概念。</p><p>OKHttp 的连接池由 ConnectionPool 实现。</p><p>ConnetionPool 内部维护了一个线程池，负责清理无效的连接。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">      Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">      cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 使用线程池执行清理任务</span></span><br><span class="line">      executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新建的连接插入到双端队列中</span></span><br><span class="line">    connections.add(connection);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 清理操作，返回下次需要清理的时间</span></span><br><span class="line">      <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">      <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">        waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>ConnectionPool 维护一个线程池用于清理无效的连接，清理任务由 <code>cleanup</code>方法完成，首先执行清理，返回下次需要清理的间隔时间，然后调用 <code>wait</code> 方法释放锁。等到了时间，再次进行清理操作，返回下一次清理的时间，循环往复下去。</p><p>具体看一下 <code>cleanup</code> 方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的连接</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、连接正在使用，即StreanAllocation的引用数量大于0</span></span><br><span class="line">            <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                inUseConnectionCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the connection is ready to be evicted, we&#x27;re done.</span></span><br><span class="line">            <span class="comment">// 2、如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放</span></span><br><span class="line">            <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// maxIdleConnections 表示最大允许的闲置的连接的数量,keepAliveDurationNs表示连接允许存活的最长的时间。</span></span><br><span class="line">        <span class="comment">// 默认空闲连接最大数目为5个，keepalive 时间最长为5分钟</span></span><br><span class="line">        <span class="comment">// 3、如果空闲连接超过5个或者keepalive时间大于5分钟，则将该连接清理</span></span><br><span class="line">        <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">            || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 4、闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候）</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span></span><br><span class="line">            <span class="comment">///5、所有的连接都在使用中，5分钟后再清理</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">            <span class="comment">//6、没有连接</span></span><br><span class="line">            cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup again immediately.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>整体流程如下：</p><ul><li>1、遍历所有连接，查询每个连接的内部的 StreamAllocation 的引用数量，如果大于 0，表示连接正在使用，无需清理，执行下一次循环。</li><li>2、如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放。</li><li>3、如果空闲连接超过 5 个或者 keepalive 时间大于 5 分钟，则将该连接清理。</li><li>4、闲置的连接的数量大于 0，返回该连接的到期时间（等会儿会将其清理掉，现在还不是时候）。</li><li>5、全部都是活跃连接，5 分钟后再进行清理。</li><li>6、没有任何连接，跳出循环。</li></ul><p>RealConnection 内有一个 SteamAllocation 虚引用列表，每次创建的 StreamAllocation，都会被添加到这个列表中，如果流关闭后就将 SteamAllocation 对象从该列表中移出去，也正是利用这种计数方式判定一个连接是否为空闲连接。</p><p>查询引用计数是在 <code>pruneAndGetAllocationCount</code> 方法中实现。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚引用列表</span></span><br><span class="line">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class="line">    <span class="comment">// 遍历虚引用列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">        Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class="line">        <span class="comment">//如果虚引用StreamAllocation正在被使用，则跳过进行下一次循环</span></span><br><span class="line">        <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;ve discovered a leaked allocation. This is an application bug.</span></span><br><span class="line">        StreamAllocation.StreamAllocationReference streamAllocRef =</span><br><span class="line">            (StreamAllocation.StreamAllocationReference) reference;</span><br><span class="line">        String message = <span class="string">&quot;A connection to &quot;</span> + connection.route().address().url()</span><br><span class="line">            + <span class="string">&quot; was leaked. Did you forget to close a response body?&quot;</span>;</span><br><span class="line">        Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除引用</span></span><br><span class="line">        references.remove(i);</span><br><span class="line">        connection.noNewStreams = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span></span><br><span class="line">        <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">            connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><p><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5a704ed05188255a8817f4c9">https://juejin.im/post/5a704ed05188255a8817f4c9</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/">https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 源码分析（二）：缓存机制</title>
      <link href="2019/03/11/ok-analysis-2/"/>
      <url>2019/03/11/ok-analysis-2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://wuzhangyang.com/2019/03/11/okhttp-source-code-analysis-1/">上一篇文章</a>我们主要介绍了 OkHttp 的请求流程，这篇文章讲解一下 OkHttp 的缓存机制。</p><p>建议将 OkHttp 的源码下载下来，使用 IDEA 编辑器可以直接打开阅读。我这边也将最新版的源码下载下来，进行了注释说明，有需要的可以直接从 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/android-open-framework-analysis">Android open framework analysis</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 查看。</p><p>在网络请求的过程中，一般都会使用到缓存，缓存的意义在于，对于客户端来说，使用缓存数据能够缩短页面展示数据的时间，优化用户体验，同时降低请求网络数据的频率，避免流量浪费。对于服务端来说，使用缓存能够分解一部分服务端的压力。</p><p>在讲解 OkHttp 的缓存机制之前，先了解下 Http  的缓存理论知识，这是实现 OkHttp 缓存的基础。</p>        <h2 id="Http-缓存">          <a href="#Http-缓存" class="heading-link"><i class="fas fa-link"></i></a>Http 缓存</h2>      <p>Http 的缓存机制如下图：</p><p><img src="/2019/03/11/ok-analysis-2/cache.png" alt="http-cache"></p><p>Http 的缓存分为两种：强制缓存和对比缓存。强制缓存优先于对比缓存。</p>        <h3 id="强制缓存">          <a href="#强制缓存" class="heading-link"><i class="fas fa-link"></i></a>强制缓存</h3>      <p>客户端第一次请求数据时，服务端返回缓存的过期时间（通过字段 Expires 与 Cache-Control 标识），后续如果缓存没有过期就直接使用缓存，无需请求服务端；否则向服务端请求数据。</p><p><strong>Expires</strong></p><p>服务端返回的到期时间。下一次请求时，请求时间小于 Expires 的值，直接使用缓存数据。</p><p>由于到期时间是服务端生成，客户端和服务端的时间可能存在误差，导致缓存命中的误差。</p><p><strong>Cache-Control</strong></p><p>Http1.1 中采用了 Cache-Control 代替了 Expires，常见 Cache-Control 的取值有：</p><ul><li>private: 客户端可以缓存 </li><li>public:  客户端和代理服务器都可缓存</li><li>max-age=xxx:  缓存的内容将在 xxx 秒后失效</li><li>no-cache:  需要使用对比缓存来验证缓存数据，并不是字面意思</li><li>no-store:  所有内容都不会缓存，强制缓存，对比缓存都不会触发</li></ul>        <h3 id="对比缓存">          <a href="#对比缓存" class="heading-link"><i class="fas fa-link"></i></a>对比缓存</h3>      <p>对比缓存每次请求都需要与服务器交互，由服务端判断是否可以使用缓存。</p><p>客户端第一次请求数据时,服务器会将缓存标识（Last-Modified/If-Modified-Since 与 Etag/If-None-Match）与数据一起返回给客户端，客户端将两者备份到缓存数据库中。</p><p>当再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，返回 304 状态码，通知客户端可以使用缓存数据，服务端不需要将报文主体返回给客户端。</p><p><strong>Last-Modified/If-Modified-Since</strong></p><p>Last-Modified 表示资源上次修改的时间，在第一次请求时服务端返回给客户端。</p><p>客户端再次请求时，会在 header 里携带 If-Modified-Since ，将资源修改时间传给服务端。</p><p>服务端发现有  If-Modified-Since 字段，则与被请求资源的最后修改时间对比，如果资源的最后修改时间大于  If-Modified-Since，说明资源被改动了，则响应所有资源内容，返回状态码 200；否则说明资源无更新修改，则响应状态码 304，告知客户端继续使用所保存的缓存。</p><p>**Etag/If-None-Match **</p><p>优先于 Last-Modified/If-Modified-Since。</p><p>Etag 是当前资源在服务器的唯一标识，生成规则由服务器决定。当客户端第一次请求时，服务端会返回该标识。</p><p>当客户端再次请求数据时，在 header 中添加 If-None-Match 标识。</p><p>服务端发现有 If-None-Match 标识，则会与被请求资源对比，如果不同，说明资源被修改，返回 200；如果相同，说明资源无更新，响应 304，告知客户端继续使用缓存。</p>        <h2 id="OkHttp-缓存">          <a href="#OkHttp-缓存" class="heading-link"><i class="fas fa-link"></i></a>OkHttp 缓存</h2>      <p>为了节省流量和提高响应速度，OkHttp 有自己的一套缓存机制，CacheInterceptor 就是用来负责读取缓存以及更新缓存的。</p><p>我们来看 CacheInterceptor 的关键代码：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、如果此次网络请求有缓存数据，取出缓存数据作为候选</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、根据cache获取缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    <span class="comment">// 通过缓存策略计算的网络请求</span></span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    <span class="comment">// 通过缓存策略处理得到的缓存响应数据</span></span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存数据不能使用，清理此缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、不进行网络请求，而且没有缓存数据，则返回网络请求错误的结果</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(<span class="number">504</span>)</span><br><span class="line">            .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、如果不进行网络请求，缓存数据可用，则直接返回缓存数据.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、缓存无效，则继续执行网络请求。</span></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6、通过服务端校验后，缓存数据可以使用（返回304），则直接返回缓存数据，并且更新缓存</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">            <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、读取网络结果，构造response</span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>整个方法的流程如下：</p><ul><li><p>1、读取候选缓存。</p></li><li><p>2、根据候选缓存创建缓存策略。</p></li><li><p>3、根据缓存策略，如果不进行网络请求，而且没有缓存数据时，报错返回错误码 504。</p></li><li><p>4、根据缓存策略，如果不进行网络请求，缓存数据可用，则直接返回缓存数据。</p></li><li><p>5、缓存无效，则继续执行网络请求。</p></li><li><p>6、通过服务端校验后，缓存数据可以使用（返回 304），则直接返回缓存数据，并且更新缓存。</p></li><li><p>7、读取网络结果，构造 response，对数据进行缓存。</p></li></ul><p>OkHttp 通过 CacheStrategy 获取缓存策略，CacheStrategy 根据之前缓存结果与当前将要发生的 request 的Header 计算缓存策略。规则如下：</p><div class="table-container"><table><thead><tr><th>networkRequest</th><th>cacheResponse</th><th>CacheStrategy</th></tr></thead><tbody><tr><td>null</td><td>null</td><td>only-if-cached(表明不进行网络请求，且缓存不存在或者过期，一定会返回 503 错误)</td></tr><tr><td>null</td><td>non-null</td><td>不进行网络请求，而且缓存可以使用，直接返回缓存，不用请求网络</td></tr><tr><td>non-null</td><td>null</td><td>需要进行网络请求，而且缓存不存在或者过期，直接访问网络。</td></tr><tr><td>non-null</td><td>not-null</td><td>Header 中含有 ETag/Last-Modified 标识，需要在条件请求下使用，还是需要访问网络。</td></tr></tbody></table></div><p>CacheStrategy 通过工厂模式构造，CacheStrategy.Factory 对象构建以后，调用它的 <code>get</code> 方法即可获得具体的CacheStrategy，CacheStrategy.Factory 的 <code>get</code>方法内部调用的是 CacheStrategy.Factory 的 <code>getCandidate</code> 方法，它是核心的实现。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、没有缓存，直接返回包含网络请求的策略结果</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、如果握手信息丢失，则返返回包含网络请求的策略结果</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、如果根据CacheControl参数有no-store，则不适用缓存，直接返回包含网络请求的策略结果</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、如果缓存数据的CacheControl有no-cache指令或者需要向服务器端校验后决定是否使用缓存，则返回只包含网络请求的策略结果</span></span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 如果缓存在过期时间内则可以直接使用，则直接返回上次缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 如果缓存过期，且有ETag等信息，则发送If-None-Match、If-Modified-Since等条件请求</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>整个函数的逻辑就是按照上面的 Http 缓存策略流程图来实现的，这里不再赘述。</p><p>我们再简单看下 OkHttp 是如何缓存数据的。</p><p>OkHttp 具体的缓存数据是利用 DiskLruCache 实现，用磁盘上的有限大小空间进行缓存，按照 LRU 算法进行缓存淘汰。</p><p> Cache 类封装了缓存的实现，缓存操作封装在  InternalCache 接口中。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InternalCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪一个满足缓存条件的GET请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪满足缓存策略CacheStrategy的响应</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Cache 类在其内部实现了 InternalCache 的匿名内部类，内部类的方法调用 Cache 对应的方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">final</span> InternalCache internalCache = <span class="keyword">new</span> InternalCache() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Cache.<span class="keyword">this</span>.get(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Cache.<span class="keyword">this</span>.put(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.remove(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span> </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.update(cached, network);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.trackConditionalCacheHit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span> </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.trackResponse(cacheStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <ul><li>OkHttp 的缓存机制是按照 Http 的缓存机制实现。</li><li>OkHttp 具体的数据缓存逻辑封装在 Cache 类中，它利用 DiskLruCache 实现。</li><li>默认情况下，OkHttp 不进行缓存数据。</li><li>可以在构造 OkHttpClient 时设置 Cache 对象，在其构造函数中指定缓存目录和缓存大小。</li></ul><ul><li>如果对 OkHttp 内置的 Cache  类不满意，可以自行实现  InternalCache 接口，在构造 OkHttpClient  时进行设置，这样就可以使用自定义的缓存策略了。</li></ul>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/chenqf/p/6386163.html">https://www.cnblogs.com/chenqf/p/6386163.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5a704ed05188255a8817f4c9">https://juejin.im/post/5a704ed05188255a8817f4c9</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 源码分析（一）：请求流程</title>
      <link href="2019/03/11/ok-analysis-1/"/>
      <url>2019/03/11/ok-analysis-1/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要梳理一下 OkHttp 的请求流程，对 OkHttp 的实现原理有个整体的把握，再深入细节的实现会更加容易。</p><p>建议将 OkHttp 的源码下载下来，使用 IDEA 编辑器可以直接打开阅读。我这边也将最新版的源码下载下来，进行了注释说明，有需要的可以直接从 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/android-open-framework-analysis">Android open framework analysis</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 查看。</p>        <h2 id="基本使用">          <a href="#基本使用" class="heading-link"><i class="fas fa-link"></i></a>基本使用</h2>      <p>我们先看一下 OkHttp 的基本使用。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建 Request</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .get()</span><br><span class="line">    .url(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .build(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 OKHttpClient</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、创建 Call</span></span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 4、同步请求</span></span><br><span class="line">    Response response = call.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、异步请求</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure><p>上面的代码中，首先构建一个请求 Request 和一个客户端 OkHttpClient，然后 OkHttpClient 对象根据 request 调用 <code>newCall</code> 方法创建 Call 对象，再调用  <code>execute</code> 或者 <code>enqueue</code> 方法进行同步或者异步请求。</p><p>接下来我们看一看关键类和关键流程的具体实现。</p>        <h2 id="Request">          <a href="#Request" class="heading-link"><i class="fas fa-link"></i></a>Request</h2>      <p>Request 类封装了一次请求需要传递给服务端的参数：请求 method 如 GET/POST 等、一些 header、RequestBody 等等。</p><p>Request 类未对外提供 public 的构造函数，所以构建一个 Request 实例需要使用构造者模式构建。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Request(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">    <span class="keyword">this</span>.method = builder.method;</span><br><span class="line">    <span class="keyword">this</span>.headers = builder.headers.build();</span><br><span class="line">    <span class="keyword">this</span>.body = builder.body;</span><br><span class="line">    <span class="keyword">this</span>.tags = Util.immutableMap(builder.tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="OkHttpClient">          <a href="#OkHttpClient" class="heading-link"><i class="fas fa-link"></i></a>OkHttpClient</h2>      <p>OkHttpClient 支持两种构造方式。</p><p>一种是默认的构造方式：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br></pre></td></tr></table></div></figure><p>看一下构造函数：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure><p>这里 OkHttpClient 内部默认配置了一些参数。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;...&#125;</span><br></pre></td></tr></table></div></figure><p>另一种是通过 Builder 配置参数，最后通过 <code>build</code> 方法构建一个 OkHttpClient 对象。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>); <span class="comment">// 这里的 this 是 Builder 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们看一下 OkHttpClient 可配置哪些参数：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Dispatcher dispatcher;    <span class="comment">// 调度器</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">Proxy proxy; <span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Protocol&gt; protocols;  <span class="comment">// 协议</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ConnectionSpec&gt; connectionSpecs;  <span class="comment">// 传输层版本和连接协议</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;  <span class="comment">// 拦截器</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors;  <span class="comment">// 网络拦截器</span></span><br><span class="line"><span class="keyword">final</span> EventListener.Factory eventListenerFactory;</span><br><span class="line"><span class="keyword">final</span> ProxySelector proxySelector; <span class="comment">// 代理选择器</span></span><br><span class="line"><span class="keyword">final</span> CookieJar cookieJar;  <span class="comment">// cookie</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">Cache cache;  <span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">InternalCache internalCache;  <span class="comment">// 内部缓存</span></span><br><span class="line"><span class="keyword">final</span> SocketFactory socketFactory;  <span class="comment">// socket 工厂</span></span><br><span class="line"><span class="keyword">final</span> SSLSocketFactory sslSocketFactory;  <span class="comment">// 安全套接层 socket 工厂，用于 https</span></span><br><span class="line"><span class="keyword">final</span> CertificateChainCleaner certificateChainCleaner; <span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名</span></span><br><span class="line"><span class="keyword">final</span> HostnameVerifier hostnameVerifier; <span class="comment">// 主机名字验证</span></span><br><span class="line"><span class="keyword">final</span> CertificatePinner certificatePinner; <span class="comment">// 证书链</span></span><br><span class="line"><span class="keyword">final</span> Authenticator proxyAuthenticator; <span class="comment">// 代理身份验证</span></span><br><span class="line"><span class="keyword">final</span> Authenticator authenticator; <span class="comment">// 本地身份验证</span></span><br><span class="line"><span class="keyword">final</span> ConnectionPool connectionPool;  <span class="comment">// 连接池</span></span><br><span class="line"><span class="keyword">final</span> Dns dns;  <span class="comment">// 域名</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> followSslRedirects;  <span class="comment">// 安全套接层重定向</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> followRedirects;  <span class="comment">// 本地重定向</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> retryOnConnectionFailure;  <span class="comment">// 重试连接失败</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> callTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> readTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> writeTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pingInterval;</span><br></pre></td></tr></table></div></figure>        <h2 id="Call">          <a href="#Call" class="heading-link"><i class="fas fa-link"></i></a>Call</h2>      <p>Call 是一个接口，是请求的抽象描述，具体实现类是 RealCall，通过Call.Factory 创建。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回当前请求</span></span><br><span class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步请求方法</span></span><br><span class="line">  <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消请求</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求是否在执行（当execute()或者enqueue(Callback responseCallback)执行后该方法返回true）</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求是否被取消</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的一模一样的请求</span></span><br><span class="line">  <span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>OkHttpClient 实现了 Call.Factory，负责根据 Request 创建新的 Call：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call call = client.newCall(request);</span><br></pre></td></tr></table></div></figure><p>看一下 <code>newCall</code> 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里我们发现实际上调用了 RealCall 的静态方法 <code>newRealCall</code>， 不难猜测 这个方法就是创建 Call 对象。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="同步请求">          <a href="#同步请求" class="heading-link"><i class="fas fa-link"></i></a>同步请求</h2>      <p>从上面的分析我们知道，同步请求调用的实际是 RealCall 的 <code>execute</code> 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 每个 call 只能执行一次</span></span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    timeout.enter();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 请求开始, 将自己加入到runningSyncCalls队列中</span></span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// 通过一系列拦截器请求处理和响应处理得到最终的返回结果</span></span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e = timeoutExit(e);</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 请求完成, 将其从runningSyncCalls队列中移除</span></span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure><p>这里主要做了这几件事：</p><ul><li>检测这个 call 是否已经执行了，保证每个 call 只能执行一次。</li><li>通知 dispatcher 已经进入执行状态，将 call 加入到 runningSyncCalls 队列中。</li><li>调用 <code>getResponseWithInterceptorChain()</code> 函数获取 HTTP 返回结果。</li><li>最后还要通知 <code>dispatcher</code> 自己已经执行完毕，将 call 从 runningSyncCalls 队列中移除。</li></ul><p>这里涉及到了 Dispatcher 这个类，我们在异步请求这一节中再介绍。</p><p>真正发出网络请求以及解析返回结果的是在 <code>getResponseWithInterceptorChain</code> 方法中进行的。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br></pre></td></tr></table></div></figure><p> <code>getResponseWithInterceptorChain</code> 方法的代码量并不多，但是却完成了所有的请求处理过程。</p><p>这里先是创建了一个 Interceptor 的集合，然后将各类 interceptor 全部加入到集合中，包含以下 interceptor：</p><ul><li><p>interceptors：配置 OkHttpClient 时设置的 inteceptors</p></li><li><p>RetryAndFollowUpInterceptor：负责失败重试以及重定向</p></li><li><p>BridgeInterceptor：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</p></li><li><p>CacheInterceptor：负责读取缓存直接返回、更新缓存</p></li><li><p>ConnectInterceptor：负责和服务器建立连接</p></li><li><p>networkInterceptors：配置 OkHttpClient 时设置的 networkInterceptors</p></li><li><p>CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应数据</p></li></ul><p>添加完拦截器后，创建了一个 RealInterceptorChain 对象，将集合 interceptors 和 index（<strong>数值0</strong>）传入。接着调用其 <code>proceed</code> 方法进行请求的处理，我们来看 <code>proceed</code>方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建下一个RealInterceptorChain，将index+1（下一个拦截器索引）传入</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    <span class="comment">// 获取当前的拦截器</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">// 通过Interceptor的intercept方法进行处理</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure><p>我们来看一些关键代码：</p><p>RealInterceptorChain 的 <code>proceed</code> 方法先创建 RealInterceptorChain 的对象，将集合 interceptors 和 index + 1 传入。从前面的分析知道，初始 index 为 0。</p><p>然后获取当前 index 位置上的 Interceptor，将创建的 RealInterceptorChain 对象 next 传入到当前拦截器的 <code>intercept</code> 方法中，<code>intercept</code> 方法内部会调用 next 的 proceed 方法，一直递归下去，最终完成一次网络请求。</p><p>所以每个 Interceptor 主要做两件事情：</p><ul><li>拦截上一层拦截器封装好的 Request，然后自身对这个 Request 进行处理，处理后向下传递。</li><li>接收下一层拦截器传递回来的 Response，然后自身对 Response 进行处理，返回给上一层。</li></ul>        <h2 id="异步请求">          <a href="#异步请求" class="heading-link"><i class="fas fa-link"></i></a>异步请求</h2>      <p>异步请求调用的是 RealCall 的 <code>enqueue</code> 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.executed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.captureCallStackTrace();</span><br><span class="line">    <span class="keyword">this</span>.eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.client.dispatcher().enqueue(<span class="keyword">new</span> RealCall.AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>与同步请求一样，异步请求也涉及了一个重要的参与者  Dispatcher，它的作用是：控制每一个 Call 的执行顺序和生命周期。它内部维护了三个队列：</p><ul><li>readyAsyncCalls：等待的异步请求队列</li><li>runningAsyncCalls：正在运行的异步请求队列</li><li>runningSyncCalls：正在运行的同步请求队列</li></ul><p>对于同步请求，由于它是即时运行的， Dispatcher 只需要运行前请求前存储到 runningSyncCalls，请求结束后从 runningSyncCalls 中移除即可。</p><p>对于异步请求，Dispatcher 是通过启动 ExcuteService 执行，线程池的最大并发量 64，异步请求先放置在 readyAsyncCalls，可以执行时放到 runningAsyncCalls 中，执行结束从runningAsyncCalls 中移除。</p><p>我们看一下具体实现细节，下面是 Dispatcher 的 <code>enqueue</code> 方法，先将 AsyncCall 添加到 readyAsyncCalls。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(AsyncCall call) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将AsyncCall加入到准备异步调用的队列中</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>再看 <code>promoteAndExecute</code> 方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">            <span class="keyword">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">            i.remove();</span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">        asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里主要的工作有：</p><ul><li>从准备异步请求的队列中取出可以执行的请求（正在运行的异步请求不得超过64，同一个host下的异步请求不得超过5个），加入到 <code>executableCalls</code> 列表中。</li><li>循环 <code>executableCalls</code> 取出请求 AsyncCall 对象，调用其 <code>executeOn</code> 方法。 </li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        eventListener.callFailed(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到 <code>executeOn</code> 方法的参数传递的是 ExecutorService 线程池对象，方法中调用了线程池的 <code>execute</code>方法，所以 AsyncCall 应该是实现了 Runnable 接口，我们看看它的 <code>run</code> 方法是怎样的。</p><p>AsyncCall 继承自 NamedRunnable 抽象类。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>所以当线程池执行 <code>execute</code> 方法会走到 NamedRunnable 的 <code>run</code> 方法，<code>run</code> 方法中又调用了 抽象方法 <code>execute</code>，我们直接看 AsyncCall 的 <code>execute</code> 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    timeout.enter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 请求网络获取结果</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 回调结果</span></span><br><span class="line">            responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e = timeoutExit(e);</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.get().log(INFO, <span class="string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 调度完成，移出队列</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里我们又看到了熟悉的 <code>getResponseWithInterceptorChain</code> 方法。</p><p>这样看来，同步请求和异步请求的原理是一样的，都是在 <code>getResponseWithInterceptorChain()</code> 函数中通过 Interceptor 链条来实现的网络请求逻辑。</p>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <p>以上便是 OkHttp 整个请求的具体流程，流程图如下。</p><p><img src="/2019/03/11/ok-analysis-1/ok.jpg" alt="okhttp"></p><p>简述 OkHttp 的请求流程：</p><ul><li><p>OkhttpClient 实现了 Call.Fctory，负责为 Request 创建 Call。</p></li><li><p>RealCall 是 Call 的具体实现，它的异步请求是通过 Dispatcher 调度器利用 ExcutorService 实现，而最终进行网络请求时和同步请求一样，都是通过 <code>getResponseWithInterceptorChain</code> 方法实现。</p></li><li><p><code>getResponseWithInterceptorChain</code>  方法中采用了责任链模式，每一个拦截器各司其职，主要做两件事。</p><ul><li>拦截上一层拦截器封装好的 Request，然后自身对这个 Request 进行处理，处理后向下传递。</li><li>接收下一层拦截器传递回来的 Response，然后自身对 Response 进行处理，返回给上一层。</li></ul></li></ul>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><p><span class="exturl"><a class="exturl__link" href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html">https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5a704ed05188255a8817f4c9">https://juejin.im/post/5a704ed05188255a8817f4c9</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/37e26f4ea57b">https://www.jianshu.com/p/37e26f4ea57b</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内部类总结</title>
      <link href="2019/02/27/java-innerclass/"/>
      <url>2019/02/27/java-innerclass/</url>
      
        <content type="html"><![CDATA[<p>Java 中，可以将一个类定义在另一个类或者一个方法里面，这样的类称为内部类。</p><p>一般包含四种内部类：成员内部类、匿名内部类、局部内部类和静态内部类。</p>        <h2 id="成员内部类">          <a href="#成员内部类" class="heading-link"><i class="fas fa-link"></i></a>成员内部类</h2>      <p>成员内部类的定义位于另一个类的内部，形式如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            name = <span class="string">&quot;wuzy&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.displayName();  <span class="comment">// wuzy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。具体是如何实现的呢？通过反编译字节码看个究竟。</p><p>先对 Outer 类进行编译 <code>javac Outer.java</code>  ，编译器在编译的时候，会将成员内部类 Inner 单独编译成一个字节码文件 <code>Outer$Inner.class</code> 。</p><p>反编译 <code>Outer$Inner.class</code>  文件得到下面的信息：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$Inner.class</span><br><span class="line">Compiled from <span class="string">&quot;Outer.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">innerclassexample</span>.<span class="title">Outer</span>$<span class="title">Inner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  innerclassexample.Outer$Inner(innerclassexample.Outer);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #2                  // Field this$0:Linnerclassexample/Outer;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       6: invokespecial #3                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">9</span>: aload_1</span><br><span class="line">      10: ldc           #4                  // String wuzy</span><br><span class="line">      12: invokestatic  #5                  // Method innerclassexample/Outer.access$002:(Linnerclassexample/Outer;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">      <span class="number">15</span>: pop</span><br><span class="line">      <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> access$<span class="number">100</span>(innerclassexample.Outer$Inner);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method displayName:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到这两行关键信息</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">innerclassexample.Outer$Inner(innerclassexample.Outer);</span><br></pre></td></tr></table></div></figure><p>这就很明显了，编译器会默认为成员内部类添加了一个指向外部类对象的引用，这个引用的赋值默认是在构造函数中进行。因此可以在成员内部类中任意的访问外部类的成员。</p><p>此外也说明了成员内部类是依赖于外部类的，如果没有创建外部类，则无法对 <code>Outer this$0</code> 引用赋值，也就无法创建内部类的对象了。</p>        <h2 id="匿名内部类">          <a href="#匿名内部类" class="heading-link"><i class="fas fa-link"></i></a>匿名内部类</h2>      <p>匿名内部类也就是没有名字的内部类，通常用来简化代码。</p><p>使用匿名内部类的前提条件：必须继承一个父类或者实现一个接口。形式如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                System.out.println(a);  </span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.test(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在 jdk 1.8 之前，匿名内部类访问方法局部变量或方法形参时，局部变量和形参必须以 <code>final</code> 修饰。</p><p>为什么？</p><p>以下是分析过程。</p><p>当 外部类的 <code>test</code> 方法执行完毕，局部变量 a 和 形参 b 的都会出栈，生命周期也就结束了，但此时 Thread 对象的生命周未必就结束了，那么 <code>run</code> 方法中访问 a 或者 b 就不可能了，但是又要实现这种效果，Java 采取了 <strong>复制</strong> 的手段解决了这个问题。</p><p>对以上代码进行编译，编译器会将匿名内部类编译成 <code>Outer$1.class</code> 文件，再对这个字节码文件进行反编译。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$<span class="number">1.</span>class</span><br><span class="line">Compiled from <span class="string">&quot;Outer.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">innerclassexample</span>.<span class="title">Outer</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Linnerclassexample/Outer;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       <span class="number">6</span>: iload_2</span><br><span class="line">       7: putfield      #2                  // Field val$b:I</span><br><span class="line">      <span class="number">10</span>: aload_0</span><br><span class="line">      11: invokespecial #3                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #4                  // Method java/lang/Thread.run:()V</span><br><span class="line">       4: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">7</span>: iconst_1</span><br><span class="line">       8: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      11: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">14</span>: aload_0</span><br><span class="line">      15: getfield      #2                  // Field val$b:I</span><br><span class="line">      18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">21</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在 <code>run</code> 方法中有一条指令：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br></pre></td></tr></table></div></figure><p>这条指令表示将操作数 1 压入栈中（当 int 取值-1~5 时，JVM 采用 <code>iconst</code> 指令将常量压入栈中），表示使用的是一个本地局部变量。</p><p>还有这三行信息：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>);</span><br></pre></td></tr></table></div></figure><p><code>this$0</code> 是指向外部类的引用，<code>val$b</code> 是形参 b 的拷贝，都是由编译器在构造函数中赋值初始化的。</p><p>从上面可以看出，如果局部变量的值在编译期间就可以确定，则直接在匿名类内部里面创建一个拷贝，如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p><p><strong>这就导致了一个新的问题，数据不一致</strong>。<code>run</code> 方法访问的 a 压根不是 <code>test</code> 方法的局部变量 a，当在 <code>run</code> 方法改变变量 a 时候，<code>test</code> 方法的局部变量 a 并没有改变。</p><p>为了解决这个问题，Java 采取了粗暴的方式，限定必须将变量 a 限制为 final 变量，不允许对变量 a 进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p><p>这也就解释了为什么匿名内部类只能访问局部 final 变量了。</p><p>在 JDK 1.8 以后，匿名内部类可以访问到非 final 变量了。以下这种写法完全没问题。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.test(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>对其反编译下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$<span class="number">1.</span>class</span><br><span class="line">Compiled from <span class="string">&quot;Outer.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">innerclassexample</span>.<span class="title">Outer</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Linnerclassexample/Outer;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       <span class="number">6</span>: iload_2</span><br><span class="line">       7: putfield      #2                  // Field val$a:I</span><br><span class="line">      <span class="number">10</span>: aload_0</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      12: putfield      #3                  // Field val$b:I</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      16: invokespecial #4                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #5                  // Method java/lang/Thread.run:()V</span><br><span class="line">       4: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">7</span>: aload_0</span><br><span class="line">       8: getfield      #2                  // Field val$a:I</span><br><span class="line">      11: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      14: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">17</span>: aload_0</span><br><span class="line">      18: getfield      #3                  // Field val$b:I</span><br><span class="line">      21: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到这四行</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></div></figure><p>JVM 编译器会在匿名内部类的构造函数中对局部变量 a 和 形参 b 进行拷贝赋值。而且， <code>run</code> 方法是无法修改变量 a 和 形参 b 的值的。</p>        <h2 id="局部内部类">          <a href="#局部内部类" class="heading-link"><i class="fas fa-link"></i></a>局部内部类</h2>      <p>定义在方法体或者代码块里的类称为局部内部类。形式如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(num1);</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>        <h2 id="静态内部类">          <a href="#静态内部类" class="heading-link"><i class="fas fa-link"></i></a>静态内部类</h2>      <p>静态内部类与成员内部类的定义方式类似，也是定义在另一个类的内部，只不过在类的前面多了一个 <code>static</code> 关键字。形式如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>静态内部类与类的静态属性类似，不依赖于对象，无法访问外部类的非静态成员，因为外部类的非静态成员依附于具体的对象。从下面的反编译结果也能看出，静态内部类是不持有外部类对象的引用的。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$Inner.class</span><br><span class="line">Compiled from &quot;Outer.java&quot;</span><br><span class="line">class innerclassexample.Outer$Inner &#123;</span><br><span class="line">  innerclassexample.Outer$Inner();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="内部类的使用场景和好处">          <a href="#内部类的使用场景和好处" class="heading-link"><i class="fas fa-link"></i></a>内部类的使用场景和好处</h2>      <p>1、内部类使得多继承的解决方案变得完整。内部类(除去用 static 修饰的 )可以直接使用其外部类的成员变量以及成员函数，达到一个继承的效果，再加上自身继承基类来达到一个多重继承的效果。</p><p>2、方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</p><p>3、方便编写事件驱动程序。比如 Android 里面的事件监听。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/dolphin0520/p/3811445.html">https://www.cnblogs.com/dolphin0520/p/3811445.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 类加载器</title>
      <link href="2019/02/25/java-classloader/"/>
      <url>2019/02/25/java-classloader/</url>
      
        <content type="html"><![CDATA[        <h2 id="类的生命周期">          <a href="#类的生命周期" class="heading-link"><i class="fas fa-link"></i></a>类的生命周期</h2>      <p><img src="/2019/02/25/java-classloader/classloader_lifecycle.png" alt="classloader_lifecycle"><br>包含七个阶段：</p><p>加载、验证、准备、解析、初始化、使用、卸载。</p><ul><li><p>验证、准备、解析三个阶段统称为连接。</p></li><li><p>加载、验证、准备、初始化和卸载的顺序是确定的，解析和初始化的前后顺序不一定，主要是为了实现动态绑定。</p></li></ul>        <h2 id="类加载过程">          <a href="#类加载过程" class="heading-link"><i class="fas fa-link"></i></a>类加载过程</h2>      <p>类加载过程主要包含加载、验证、准备、解析和初始化这 5 个阶段。</p>        <h3 id="加载">          <a href="#加载" class="heading-link"><i class="fas fa-link"></i></a>加载</h3>      <p>加载是类加载的第一个阶段，注意不要混淆。</p><p>加载过程要完成的三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>其中二进制字节流可以从以下方式获取：</p><ul><li>从 ZIP 包读取，称为 JAR、EAR、WAR 格式的基础。</li><li>从网络获取，最典型的应用是 Applet。</li><li>运行时计算，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li><li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的 Class 类。</li></ul>        <h3 id="验证">          <a href="#验证" class="heading-link"><i class="fas fa-link"></i></a>验证</h3>      <p>验证的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>验证阶段主要完成四个阶段的校验动作：</p><ul><li>文件格式验证。验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</li><li>元数据验证。对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li><li>字节码验证。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证。主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。确保解析动作能正常执行。</li></ul>        <h3 id="准备">          <a href="#准备" class="heading-link"><i class="fas fa-link"></i></a>准备</h3>      <p>为类变量分配内存并设置类变量初始值的阶段。类变量是指被 <code>static</code> 修饰的变量。</p><p> 这里的初始值一般是数据类型的零值。比如：</p> <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></div></figure><p>变量 value 在准备阶段的初始值是 0 而不是 123。</p><p>如果类变量是常量，初始值是所定义的值而不是零值。例如下面的常量 value 被初始化为 123 而不是 0。</p> <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></div></figure>        <h3 id="解析">          <a href="#解析" class="heading-link"><i class="fas fa-link"></i></a>解析</h3>      <p>将常量池的符号引用替换为直接引用的过程。</p><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><ul><li>符号引用：符号引用就是字符串，这个字符串包含足量的信息，以供实际使用时可以找到相应的位置。</li><li>直接引用：直接引用就是偏移量，通过便宜量虚拟机可以直接在该类的内存区域中找到方法字节码的起始位置。</li></ul>        <h3 id="初始化">          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a>初始化</h3>      <p>初始化是类加载过程中的最后一步，这个阶段才真正开始执行类中定义的 Java 程序代码。</p><p>初始化阶段是虚拟机执行类构造器 <code>&lt;clinit&gt;() </code>方法的过程。</p><p>在准备阶段，已经为类变量分配了系统所需的初始值，并且在初始化阶段，根据程序员通过程序进行的主观计划来初始化类变量和其他资源。<code>&lt;clinit&gt;()</code> 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</p><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>        <h2 id="类加载器">          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a>类加载器</h2>      <p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p><p>这里的相等，包括类的 Class 对象的 <code>equals()</code> 方法、<code>isAssignableFrom()</code> 方法、<code>isInstance()</code> 方法的返回结果为 true，也包括使用 <code>instanceof</code> 关键字做对象所属关系判定结果为 true。</p>        <h3 id="类加载器分类">          <a href="#类加载器分类" class="heading-link"><i class="fas fa-link"></i></a>类加载器分类</h3>      <p>从 Java 虚拟角度，只存在两种不同的类加载器：</p><ul><li>启动型类加载器（Bootstrap ClassLoader），C++ 语言实现，是虚拟机自身的一部分。</li><li>其他的类加载器：Java 语言实现，独立于虚拟机外部，全部继承自抽象类 java.lang.ClassLoader。</li></ul><p>从 Java 开发人员的角度，类加载器大致分为以下三类：</p><ul><li><p>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在 JDK\jre\lib 下，或被 -Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。</p></li><li><p>扩展类加载器：Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.* 开头的类），开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ul>        <h3 id="双亲委托模型">          <a href="#双亲委托模型" class="heading-link"><i class="fas fa-link"></i></a>双亲委托模型</h3>      <p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p><p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。类加载器之间的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。<br><img src="/2019/02/25/java-classloader/parents_delegation.png" alt="parents_delegation"></p>        <h4 id="工作过程">          <a href="#工作过程" class="heading-link"><i class="fas fa-link"></i></a>工作过程</h4>      <p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>        <h4 id="好处">          <a href="#好处" class="heading-link"><i class="fas fa-link"></i></a>好处</h4>      <p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>        <h4 id="实现方式">          <a href="#实现方式" class="heading-link"><i class="fas fa-link"></i></a>实现方式</h4>      <p>实现双亲委派的代码都集中在java.lang.ClassLoader的 <code>loadClass()</code> 方法之中。</p><p>先检查是否已经被加载过，若没有加载则调用父加载器的 <code>loadClass()</code> 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的 <code>findClass()</code> 方法进行加载。</p>        <h3 id="自定义-ClassLoader">          <a href="#自定义-ClassLoader" class="heading-link"><i class="fas fa-link"></i></a>自定义 ClassLoader</h3>      <p>继承 java.lang.ClassLoader 类，重写 <code>findClass</code> 方法。比如：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0">Java 虚拟机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 ThreadLocal</title>
      <link href="2019/02/19/threadlocal/"/>
      <url>2019/02/19/threadlocal/</url>
      
        <content type="html"><![CDATA[        <h2 id="ThreadLocal-是什么">          <a href="#ThreadLocal-是什么" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 是什么</h2>      <p>ThreadLocal 提供了线程局部变量。它和普通变量的区别在于，普通变量可以被任何一个线程访问并修改，而使用 ThreadLocal 创建的变量只能被当前线程访问，也就是线程私有，其他线程无法访问和修改。</p>        <h2 id="ThreadLocal-用法">          <a href="#ThreadLocal-用法" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 用法</h2>      <p>创建：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Boolean&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></div></figure><p>set 方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="keyword">false</span>);</span><br></pre></td></tr></table></div></figure><p>get 方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.get()</span><br></pre></td></tr></table></div></figure><p>我们来看一个完整的示例：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 ThreadLocal 对象</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别在主线程、子线程1和子线程2中设置和访问它的值</span></span><br><span class="line">threadLocal.set(<span class="keyword">true</span>);</span><br><span class="line">Log.e(TAG, <span class="string">&quot;[Thread#main]threadLocal=&quot;</span> + threadLocal.get() );</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">&quot;Thread#1&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="keyword">false</span>);</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[Thread#1]threadLocal=&quot;</span> + threadLocal.get() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">&quot;Thread#2&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[Thread#2]threadLocal=&quot;</span> + threadLocal.get() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></div></figure><p>在上面的代码中，在主线程中设置 threadLocal 的值为 true，子线程1中设置 threadLocal 的值为 false，子线程2中未设置 threadLocal 的值。</p><p>输出结果如下，可以看到，虽然在不同线程中访问的是同一个 ThreadLocal 对象，但是它们通过 ThreadLocal 获取的值却是不一样的。</p><figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Thread#main]threadLocal=true</span><br><span class="line">[Thread#1]threadLocal=false</span><br><span class="line">[Thread#2]threadLocal=null</span><br></pre></td></tr></table></div></figure>        <h2 id="Android-中应用">          <a href="#Android-中应用" class="heading-link"><i class="fas fa-link"></i></a>Android 中应用</h2>      <p>在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证了每个线程只存在一个 Looper 对象。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="ThreadLocal-原理">          <a href="#ThreadLocal-原理" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 原理</h2>      <p>ThreadLocal 内部是如何实现的，我们从源码中一探究竟。</p><p>从 <code>set</code> 方法开始，主要工作是</p><ul><li>获取当前线程</li><li>获取或当前线程的 ThreadLocalMap 对象</li><li>如果 ThreadLocalMap 不为空，设置值；否则创建 ThreadLocalMap 对象并设置值</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>getMap</code> 方法中获取 ThreadLocalMap 的方法</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个方法获取得实际是 Thread 对象的 threadLocals 变量</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></div></figure><p>如果是初次调用 <code>set</code> 方法，则 ThreadLocalMap 对象为空，会去创建 ThreadLocalMap，并设置初始值。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>所以可以总结下 ThreadLocal 的设计思路：</p><p>每个 Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 TreadLocal 实例本身，value 是真正存储的值，ThreadLocalMap 只被持有它的线程访问，其他线程也就无法访问和修改。</p><p>我们具体看一下 ThreadLocalMap。</p><p>构造 ThreadLocalMap 的主要过程：</p><ul><li>初始化存放 Entry 对象的数组</li><li>通过 key（ThreadLocal 类型）的 hashcode 计算存储的索引位置</li><li>在指定索引位置存放 Entry 对象</li><li>记录数组中 Entry 对象的个数</li><li>设定数组扩展阈值</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY]; </span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue); </span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>下面来看一下 Entry 的结构：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Entry 是 ThreadLocalMap 的静态内部类，继承自 <code>WeakReference&lt;ThreadLocal&gt;</code>，从<code>super(k)</code> 可以看出 Entry 是一个对 ThreadLocal 的弱引用。另外，Entry 包含了对 value 的强引用。</p>        <h2 id="ThreadLocal-内存泄漏的问题">          <a href="#ThreadLocal-内存泄漏的问题" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 内存泄漏的问题</h2>      <p>首先绘制了 ThreadLocal 相关的对象引用内存图（实线代表强引用，虚线代表弱引用）：</p><p><img src="/2019/02/19/threadlocal/threadlocal.png" alt="threadlocal"></p><p>图中我们看到 Entry 中的  value 一直有一条从 ThreadRef 连接过来的强引用，只有当前 Thread 结束时，ThreadRef 不在栈中，强引用断开， Thread、ThreadLocalMap、value 都会被 GC 回收。</p><p>但是，如果使用的是线程池，那么之前的线程实例处理完之后出于复用的目的依然存活，这就发生了真正意义上的内存泄漏了。</p><p>为了最小化减少内存泄露的可能性和影响，ThreadLocal 的设计中加入了一些防护措施。</p><p><code>getEntry</code> 方法：</p><p>首先从索引位置获取 Entry，如果 Entry 不为空且 key 相同则返回 Entry，否则调用 <code>getEntryAfterMiss</code> 方法向下一个位置查询。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>getEntryAfterMiss</code> 方法：</p><p>整个过程中，如果遇到 key 为空的情况，会调用 <code>expungeStaleEntry</code> 方法进行擦除 Entry（Entry 中的 value 对象没有了强引用，自然会被回收）。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果key值为null，则擦除该位置的Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>expungeStaleEntry</code> 方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置value为null</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 设置entry为null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    </span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>set</code> 方法：</p><p>set 方法也有同样的操作，通过 <code>replaceStaleEntry</code> 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 <code>rehash</code> 方法中通过 <code>expungeStaleEntry</code> 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。通过这种方式，ThreadLocal 可防止内存泄漏。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>replaceStaleEntry</code> 方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = prevIndex(i, len))</span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure><p>但是，以上的设计思路依赖一个前提条件：<strong>必须调用 ThreadLocalMap  的 <code>getEntry</code> 或者 <code>set</code> 方法。</strong></p><p>如果这个前提条件不成立，还是会发生内存泄漏。所以，很多情况下需要手动去调用 ThreadLocal 的 <code>remove</code> 方法，手动删除不再需要的 ThreadLocal，进而释放 Entry，避免内存泄漏。此外，JDK 推荐 ThreadLocal 变量定义为 <code>private static</code> ，这样 ThreadLocal 的生命周期会更长，ThreadLocal 在线程运行中不会被回收，也就能保证任何时候都能够通过 ThreadLocal 的弱引用访问到 Entry 的 value 值，然后执行 remove 操作，防止内存泄漏。</p>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <p>1、ThreadLocal 通过隐式在不同的线程中创建实例副本，避免了实例线程安全的问题。</p><p>2、ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收问题。</p><p>3、如果使用的是线程池，那么之前的线程实例处理完之后出于复用的目的依然存活，这时可能会出现内存泄漏。</p><p>4、ThreadLocal 为避免上述的内存泄漏，在 get 和 set 方法中都做了防护措施，但前提是这两个方法得到了执行。因此很多情况下还需要手动调用 ThreadLocal 的 <code>remove</code> 方法，避免内存泄漏。</p><p>5、当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存分配和回收策略</title>
      <link href="2019/01/29/java-memory-allocation-and-collect-strategy/"/>
      <url>2019/01/29/java-memory-allocation-and-collect-strategy/</url>
      
        <content type="html"><![CDATA[<p>Java 的内存分配主要是在程序运行时给对象在堆上分配内存。通常将堆内存结构按新生代和老年代进行划分，堆内存结构图如下：</p><p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_heap_allocation.png" alt="jvm_heap_allocation"></p>        <h2 id="新生代">          <a href="#新生代" class="heading-link"><i class="fas fa-link"></i></a>新生代</h2>      <p>大部分对象创建和销毁的区域。</p><p>内部包含 Eden 区域，作为对象初始分配的区域；两个 Survivor，也叫 from、to 区域，用来放置从 Minor GC 中生存下来的对象。</p><p><strong>TLAB</strong></p><p>对 Eden 区域再进行划分， Hotspot JVM 还有一个概念叫着 Thread Local Allocation（TLAB），这是 JVM 为每个线程分配的一个私有缓存区域。多线程同时分配内存时，为了避免操作同一地址，可能需要使用加锁机制，进而影响分配速度。TLAB 能够解决这个问题。</p><p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_tlab.png" alt="jvm_tlab"></p><p>start、end 就是每个 TLAB 的起始结束指针，top 则表示已经分配到哪里。所以在分配新对象时，移动 top，当 top 与 end 相遇，表示该缓存已经满了， JVM 会试图再从 Eden 里分配一块。</p>        <h2 id="老年代">          <a href="#老年代" class="heading-link"><i class="fas fa-link"></i></a>老年代</h2>      <p><strong>大对象直接进入老年代</strong></p><p>对象先在 TLAB 上分配内存，如果 TLAB 空间不足，会在 Eden 区域给对象分配空间，但是如果对象太大，无法在新生代找到足够长的连续空闲空间， JVM 会直接将对象分配到老年代。</p><p>这里的大对象比如是较大的字符串或者数组，因此在写程序时避免分配“朝生夕死”的大对象。</p><p><strong>长期存活的对象直接进入老年代</strong></p><p>在经历了多次 Minor GC 后仍然存活的对象，如果对象的年龄达到老年代阈值，会直接进入老年代。下文会阐述。</p><p><strong>动态对象年龄判定</strong></p><p>为了适应不同程序的内存情况，虚拟机不是永远只在对象的年龄达到老年代阈值时才将对象晋升到老年代。</p><p>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</p>        <h2 id="永久代">          <a href="#永久代" class="heading-link"><i class="fas fa-link"></i></a>永久代</h2>      <p>早期 JVM 的方法区实现，储存 Java 常量池、类元数据等，在 JDK 8 之后取消了永久代。</p>        <h2 id="堆内存参数">          <a href="#堆内存参数" class="heading-link"><i class="fas fa-link"></i></a>堆内存参数</h2>      <p>最大堆体积</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx:value</span><br></pre></td></tr></table></div></figure><p>最小堆体积</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms:value</span><br></pre></td></tr></table></div></figure><p> 老年代和新生代的比例。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：NewRatio=value</span><br></pre></td></tr></table></div></figure><p>默认情况，老年代是新生代的 2 倍。即 新生代是堆大小的 1/3。也可以直接调整新生代的大小。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=value</span><br></pre></td></tr></table></div></figure><p>Eden 和 Survivor 的大小比例。YoungGen = Eden + 2 * Survivor。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：SurvivorRatio=value</span><br></pre></td></tr></table></div></figure><p>堆内存结构中每一代中都存在Reserved 区域，当 Xms 小于 Xmx 时，堆的大小不会直接扩展到上限。当内存需求不断增长， JVM 会逐渐扩展区域大小，所以 Reserved 区域表示保留区域，暂时不可用的空间。</p>        <h2 id="Minor-GC">          <a href="#Minor-GC" class="heading-link"><i class="fas fa-link"></i></a>Minor GC</h2>      <p>新生代 GC。</p><p>Java 应用不断创建对象，优先分配在 Eden 区域，当空间占用达到一定阈值时，触发 Minor GC。没有被引用的对象被回收，仍然存活的对象被复制到 JVM 选择的 Survivor 区域。如下图，数字 1 表示对象的存活年龄计数。</p><p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_minor_gc_1.png" alt="jvm_minor_gc_1"></p><p>在下一次 Minor GC 时，另外一个 Survivor 区域会成为 to 区域， Eden 区域存活的对象和 from 区域对象都会被复制到 to 区域，存活的年龄计会被加 1。</p><p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_minor_gc_2.png" alt="jvm_minor_gc_2"></p><p>上述过程会发生很多次，直到有对象年龄计数达到阈值，这些对象会被晋升到老年代。</p><p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_minor_gc_3.png" alt="jvm_minor_gc_3"></p>        <h2 id="Full-GC">          <a href="#Full-GC" class="heading-link"><i class="fas fa-link"></i></a>Full GC</h2>      <p>新生代、老年代和永久代都进行 GC 操作。</p><p><strong>调用System.gc()</strong></p><p>代码中 <code>System.gc()</code> 方法的调用是建议 JVM 进行 Full GC，多数情况下会触发 Full GC。</p><p><strong>老年代空间不足</strong></p><p>老年代的对象主要是大对象、长期存活的对象。如果老年代空间不足时，会触发 Full GC。</p><p><strong>空间分配担保失败</strong></p><p>当准备要触发一次 Minor GC 时，如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。</p><p><strong>JDK 1.7 及以前永久代空间不足</strong></p><p>在JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。</p><p>在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。</p><p><strong>Concurrent Mode Failure</strong></p><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报 <code>Concurrent Mode Failure</code> 错误，并触发 Full GC。</p>        <h2 id="参考资料">          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>Java 核心技术 36 讲（极客时间）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 安全点介绍</title>
      <link href="2019/01/18/understand-safe-point/"/>
      <url>2019/01/18/understand-safe-point/</url>
      
        <content type="html"><![CDATA[        <h2 id="什么是安全点？">          <a href="#什么是安全点？" class="heading-link"><i class="fas fa-link"></i></a>什么是安全点？</h2>      <p>在 <a href="http://wuzhangyang.com/2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/">JVM 中如何判断对象可以被回收</a> 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。</p><p>那么，首先要找到哪些是 GC Roots。</p><p>有两种查找 GC Roots 的方法：</p><p>一种是遍历方法区和栈区查找（保守式 GC）。</p><p>一种是通过 OopMap 数据结构来记录 GC Roots 的位置（准确式 GC）。</p><p>很明显，保守式 GC 的成本太高。准确式 GC 的优点就是能够让虚拟机快速定位到 GC Roots。</p><p>对应 OopMap 的位置即可作为一个安全点（Safe Point）。</p><p>在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的”Stop-The-World”。</p><p>为什么呢？</p><p>因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。</p><p>安全点意味着在这个点时，所有工作线程的状态是确定的，JVM 就可以安全地执行 GC 。</p>        <h2 id="如何选定安全点？">          <a href="#如何选定安全点？" class="heading-link"><i class="fas fa-link"></i></a>如何选定安全点？</h2>      <p>安全点太多，GC 过于频繁，增大运行时负荷；安全点太少，GC 等待时间太长。</p><p>一般会在如下几个位置选择安全点：</p><p>1、循环的末尾</p><p>2、方法临返回前</p><p>3、调用方法之后</p><p>4、抛异常的位置</p><p>为什么选定这些位置作为安全点：</p><p>主要的目的就是避免程序长时间无法进入 Safe Point。比如 JVM 在做 GC 之前要等所有的应用线程进入安全点，如果有一个线程一直没有进入安全点，就会导致 GC 时 JVM 停顿时间延长。比如<span class="exturl"><a class="exturl__link" href="https://hllvm-group.iteye.com/group/topic/38232">这里</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，超大的循环导致执行 GC 等待时间过长。</p>        <h2 id="如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？">          <a href="#如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？" class="heading-link"><i class="fas fa-link"></i></a>如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？</h2>      <p>主要有两种方式：</p><p><strong>抢断式中断</strong>：在 GC 发生时，首先中断所有线程，如果发现线程未执行到 Safe Point，就恢复线程让其运行到 Safe Point 上。</p><p><strong>主动式中断</strong>：在 GC 发生时，不直接操作线程中断，而是简单地设置一个标志，让各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起。</p><p>JVM 采取的就是主动式中断。轮询标志的地方和安全点是重合的。</p>        <h2 id="安全区域又是什么？">          <a href="#安全区域又是什么？" class="heading-link"><i class="fas fa-link"></i></a>安全区域又是什么？</h2>      <p>Safe Point 是对正在执行的线程设定的。</p><p>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p><p>因此 JVM 引入了 Safe Region。</p><p>Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p><p>线程在进入 Safe Region 的时候先标记自己已进入了 Safe Region，等到被唤醒时准备离开 Safe Region 时，先检查能否离开，如果 GC 完成了，那么线程可以离开，否则它必须等待直到收到安全离开的信号为止。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 七种垃圾收集器</title>
      <link href="2019/01/17/java-garbage-collector/"/>
      <url>2019/01/17/java-garbage-collector/</url>
      
        <content type="html"><![CDATA[<p>Java 垃圾收集器是 <a href="http://wuzhangyang.com/2019/01/15/garbage-collection-algorithm/">垃圾收集算法</a> 的具体实现。</p><p>下图展示的是 7 种作用于不同分代的收集器，如果两种收集器之前有连接，表示它们可以配合使用。收集器所在的位置表示它是属于新生代收集器还是老年代收集器。</p><p><img src="/2019/01/17/java-garbage-collector/seven_garbage_collector.png" alt="seven_garbage_collector"></p>        <h2 id="Serial-收集器">          <a href="#Serial-收集器" class="heading-link"><i class="fas fa-link"></i></a>Serial 收集器</h2>      <p><strong>单线程</strong>、<strong>串行</strong>收集器。即在垃圾清理时，必须暂停其他所有工作线程。</p><p>它是采用<strong>复制算法</strong>的<strong>新生代收集器</strong>。</p><p>下图是 Serial 收集器的运行过程。</p><p><img src="/2019/01/17/java-garbage-collector/serial_collector.png" alt="serial_collector"></p>        <h2 id="ParNew-收集器">          <a href="#ParNew-收集器" class="heading-link"><i class="fas fa-link"></i></a>ParNew 收集器</h2>      <p>ParNew 收集器是 Serial 收集器的<strong>多线程</strong>版本。除了使用多线程收集，其他与 Serial 收集相比并无太多创新之处。</p><p>默认开启的线程数量与 CPU 数量相同。</p><p>在单 CPU 的环境，ParNew 收集器不会比 Serial 收集器更优秀。</p><p><img src="/2019/01/17/java-garbage-collector/parnew_collector.png" alt="parnew_collector"></p>        <h2 id="Parallel-Scavenge-收集器">          <a href="#Parallel-Scavenge-收集器" class="heading-link"><i class="fas fa-link"></i></a>Parallel Scavenge 收集器</h2>      <p>Parallel Scavenge 收集器也是一个 <strong>并行的多线程</strong>新生代收集器，使用的是<strong>复制算法</strong>。</p><p>特点在于它的目标是达到一个可控制的吞吐量（Throughput）。</p><p>吞吐量就是 CPU 用于运行用户代码得时间与 CPU 消耗时间的比值。</p><p><strong>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</strong></p><p>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序地运行任务，适合在后台运行不需要太多交互的任务。</p><p>-XX:GCTimeRatio : 设置吞吐量大小。</p><p>-XX:MaxGCPauseMillis : 设置最大垃圾收集停顿时间。</p>        <h2 id="Serial-Old-收集器">          <a href="#Serial-Old-收集器" class="heading-link"><i class="fas fa-link"></i></a>Serial Old 收集器</h2>      <p>Serial 收集器的老年代产品。同样是<strong>单线程</strong>，使用标<strong>记整理算法</strong>。</p><p><img src="/2019/01/17/java-garbage-collector/serial_collector.png" alt="serial_collector"></p>        <h2 id="Parallel-Old-收集器">          <a href="#Parallel-Old-收集器" class="heading-link"><i class="fas fa-link"></i></a>Parallel Old 收集器</h2>      <p>Parallel Old 是 Parallel Scanvenge 的老年代版本，使用<strong>多线程</strong>和<strong>标记整理算法</strong>。</p><p><img src="/2019/01/17/java-garbage-collector/parallel_old_collector.png" alt="parallel_old_collector"></p>        <h2 id="CMS-收集器">          <a href="#CMS-收集器" class="heading-link"><i class="fas fa-link"></i></a>CMS 收集器</h2>      <p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>从名称是上看出 CMS 采用的是标记清除算法。整个过程有四个步骤：</p><ul><li>初始标记（CMS initial mark）：仅仅标记一下 GC Roots 能关联到的对象，速度很快。</li><li>并发标记（CMS concurrent mark）：GC Roots Tracing 过程。</li><li>重新标记（CMS remark）：修正并发标记期间引用变化那一部分对象</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中，初始标记、重新标记需要“Stop The World”。并发标记和并发清除时收集器线程可以与用户线程一起工作。</p><p><img src="/2019/01/17/java-garbage-collector/cms_collector.png" alt="cms_collector"></p><p><strong>优势</strong>：</p><p>并发收集、低停顿。</p><p><strong>缺陷</strong>：</p><ul><li>对 CPU 资源敏感。多线程导致占用一部分 CPU 资源而导致应用程序变慢。</li><li>无法处理<strong>浮动垃圾</strong>。并发清理过程中用户线程还在运行，会产生新的垃圾，CMS 无法在当次收集中处理它们，只好等待下一次 GC 时再清理掉。这一部分垃圾称为浮动垃圾。</li><li>CMS 采取的标记清除算法会产生大量空间碎片。往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul>        <h2 id="G1收集器">          <a href="#G1收集器" class="heading-link"><i class="fas fa-link"></i></a>G1收集器</h2>      <p><strong>Region</strong></p><p>上述的 GC 收集器将连续的内存空间划分为新生代、老生代和永久代（JDK 8 去除了永久代，引入了元空间 Metaspace），这种划分的特点是各代的存储地址（逻辑地址）是连续的。</p><p>G1 (Garbage First) 的各代存储地址是不连续的，每一代都使用了 n 个不连续的大小相同的 region， 每个 region 占有一块连续的虚拟内存地址。</p><p><img src="/2019/01/17/java-garbage-collector/g1_region.png" alt="g1_region"></p><p>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p><strong>避免全堆扫描</strong></p><p>多个 Region 之前的对象可能会有引用关系，在做可达性分析时需要扫描整个堆才能保证准确性，这显然降低了 GC 效率。</p><p>为避免全堆扫描，虚拟机为 G1 中每个 Region 维护了一个与之对应的 Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable <strong>把相关引用信息记录到被引用对象所属的Region的 Remembered Set 之中</strong>。当进行内存回收时，在GC根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p><p><strong>G1 的运作步骤</strong>：</p><ul><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ul><p><img src="/2019/01/17/java-garbage-collector/g1_collector.png" alt="g1_collector"></p><p><strong>特点：</strong></p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <div class="table-container"><table><thead><tr><th>收集器</th><th>串行、并行or并发</th><th>新生代/老年代</th><th>算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单CPU环境下的Client模式</td></tr><tr><td><strong>Serial Old</strong></td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td><strong>ParNew</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境时在Server模式下与CMS配合</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>Parallel Old</strong></td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网站或B/S系统服务端上的Java应用</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>both</td><td>标记-整理+复制算法</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table></div>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://crowhawk.github.io/2017/08/15/jvm_3/">深入理解JVM(3)——7种垃圾收集器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 垃圾收集算法有哪些？</title>
      <link href="2019/01/15/garbage-collection-algorithm/"/>
      <url>2019/01/15/garbage-collection-algorithm/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍几种 Java 垃圾收集算法的原理及其优缺点。</p>        <h2 id="标记清除（Mark-Sweep）算法">          <a href="#标记清除（Mark-Sweep）算法" class="heading-link"><i class="fas fa-link"></i></a>标记清除（Mark-Sweep）算法</h2>      <p>首先进行标记工作，标识出所有要回收的对象，然后进行统一回收被标记的对象。</p><p>对象标记的过程在 <a href="http://wuzhangyang.com/2019/01/14/java-object-self-redemption/">Java 对象的自我救赎</a> 一文中有介绍。执行过程如下图：</p><p><img src="/2019/01/15/garbage-collection-algorithm/mark_sweep.png" alt="mark_sweep"></p><p><strong>它的不足之处在于</strong>：</p><p>1、标记、清除的效率都不高。</p><p>2、清除后产生大量的内存碎片，空间碎片太多会导致在分配大对象时无法找到足够大的连续内存，从而不得不触发另一次垃圾回收动作。</p>        <h2 id="复制（Copying）算法">          <a href="#复制（Copying）算法" class="heading-link"><i class="fas fa-link"></i></a>复制（Copying）算法</h2>      <p>将可用内存按容量分成大小相等的两块，每次只使用其中的一块。</p><p>当这一块内存用完了，就将还存活的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉。</p><p><strong>商用虚拟机都采用这种算法回收新生代的对象</strong>。因为新生代的对象每次回收都基本上只有 10% 左右的对象存活，需要复制的对象少，效率高。执行过程如下图：</p><p><img src="/2019/01/15/garbage-collection-algorithm/copying.png" alt="copying"></p><p><strong>优点：</strong></p><p>因为是对整个半区进行内存回收，内存分配时不用考虑内存碎片等情况。实现简单，效率较高。</p><p><strong>不足之处：</strong></p><p>既然要复制，需要提前预留内存空间，有一定的浪费。</p><p>在对象存活率较高时，需要复制的对象较多，效率将会变低。</p>        <h2 id="标记整理（Mark-Compact）算法">          <a href="#标记整理（Mark-Compact）算法" class="heading-link"><i class="fas fa-link"></i></a>标记整理（Mark-Compact）算法</h2>      <p>与标记清除算法类似，但不是在标记完成后对可回收对象进行清理，而是将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。执行过程如下图：</p><p><img src="/2019/01/15/garbage-collection-algorithm/mark_compact.png" alt="mark_compact"></p><p><strong>优点：</strong></p><p>消除了标记清除导致的内存分散问题，也消除了复制算法中内存减半的高额代价。</p><p><strong>不足之处：</strong></p><p>效率低下，需要标记所有存活对象，还要标记所有存活对象的引用地址。效率上低于复制算法。</p>        <h2 id="分代收集（Generational-Collection）算法">          <a href="#分代收集（Generational-Collection）算法" class="heading-link"><i class="fas fa-link"></i></a>分代收集（Generational Collection）算法</h2>      <p>根据对象存活周期的不同将内存划分为几块。对不同周期的对象采取不同的收集算法。</p><p>新生代：每次垃圾收集会有大批对象回收，所以采取复制算法。</p><p>老年代：对象存活率高，采取标记清理或者标记整理算法。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 对象的自我救赎</title>
      <link href="2019/01/14/java-object-self-redemption/"/>
      <url>2019/01/14/java-object-self-redemption/</url>
      
        <content type="html"><![CDATA[<p>JVM 通过<a href="http://wuzhangyang.com/2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/">可达性分析算法判断一个对象是否可以被回收</a> ，但并不是一个对象不可达时，就宣告“死刑”的，此时只是暂时处于”缓刑“阶段。要宣告一个对象“死刑”，至少还要经历两次标记过程。</p><p><img src="/2019/01/14/java-object-self-redemption/java_object_self_redemption.png" alt="java_object_self_redemption"></p><p>没有必要执行 <code>finalize()</code> 方法的筛选条件取决于：</p><p>1、 <code>finalize()</code> 方法已经被执行过（finalize()`只会执行一次）。</p><p>2、对象没有重写 <code>finalize()</code>方法。 </p><p>如果一个对象有必要执行  <code>finalize()</code> 方法，会进入 F-Queue 队列，等待 Finalizer 线程执行。</p><p><strong>因此如果想要完成对象自救， <code>finalize()</code>是逃脱死亡的最后一次机会，重新与引用链上的任何一个对象关联起来就可以，在第二次标记时，对象会被移出回收队列，完成自救。</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我挂了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我还活着&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 finalize 方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 把当前对象( this )赋值给某个类变量, 重新与引用链建立引用</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>扩展：</p><p> <code>finalize()</code> 方法的执行线程 Finalizer 优先级级别低，无法保证  <code>finalize()</code> 方法什么时候执行，执行是否符合预期，使用不当会影响性能。</p><p>Java 9 中已经将  <code>finalize()</code> 方法标记为废弃了，如果没有特别的原因，不要重写  <code>finalize()</code> 方法，也别指望它能回收资源。相反，尽量使用 <code>try-finally</code> 、 <code>try-with-resources</code> 等机制是非常好的资源回收方法。</p>        <h2 id="参考资料">          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 中如何判断对象可以被回收?</title>
      <link href="2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/"/>
      <url>2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/</url>
      
        <content type="html"><![CDATA[<p>JVM 的垃圾回收器主要关注的是堆上创建的实例对象，在每次对这些对象进行回收前，需要确定哪些对象是可以去进行回收的。</p><p>主要有下面两种方法。</p>        <h2 id="引用计数算法">          <a href="#引用计数算法" class="heading-link"><i class="fas fa-link"></i></a>引用计数算法</h2>      <p>给对象添加一个引用计数器，当有一个地方引用它，计数器值加 1；当引用失效时，计数器值减 1。任何时刻计数器值为 0 表示这个对象可以被回收了。</p><p><strong>优点</strong>：</p><p>判断效率高，实现简单。</p><p><strong>不足之处</strong>：</p><p>难以解决对象之间相互循环引用的问题。</p><p>比如：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCDemo</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GCObject objA = <span class="keyword">new</span> GCObject();  <span class="comment">// step 1</span></span><br><span class="line">        GCObject objB = <span class="keyword">new</span> GCObject();  <span class="comment">// step 2</span></span><br><span class="line">        </span><br><span class="line">        objA.instance = objB;  <span class="comment">// step 3</span></span><br><span class="line">        objB.instance = objA;  <span class="comment">// step 4</span></span><br><span class="line">        </span><br><span class="line">        objA = <span class="keyword">null</span>;  <span class="comment">// step 5</span></span><br><span class="line">        objB = <span class="keyword">null</span>;  <span class="comment">// step 6</span></span><br><span class="line">        </span><br><span class="line">        System.gc();   <span class="comment">// 执行 GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>堆栈结构如下图：</p><p><img src="/2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/jvm_judge_object_recycle_1.png" alt="jvm_judge_object_recycle_1"></p><p><code>main</code> 方法中执行的 6 个步骤对应的引用计数结果：</p><p>step 1、实例A 引用计数加 1，引用计数 = 1；</p><p>step 2、实例B 引用计数加 1，引用计数 = 1；</p><p>step 3、实例B 引用计数加 1，引用计数 = 2；</p><p>step 4、实例A引用计数加 1，引用计数 = 2；</p><p>step 5、objA 引用不再指向实例 A，实例 A 的引用计数减为 1；</p><p>step 6、objB 引用计数不再指向实例 B，实例B的引用计数减为 1。</p><p>到此，GCObject 的实例 A 和 实例 B 的引用计数都不为 0， 此时如果执行垃圾回收，实例 A 和实例 B 是不会被回收的，也就出现内存泄漏了。</p><p>上述代码中，假设在 <code>main</code> 方法的最后执行 GC 操作，GC 日志如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">2668</span>K-&gt;<span class="number">776</span>K(<span class="number">38400</span>K)] <span class="number">2668</span>K-&gt;<span class="number">784</span>K(<span class="number">125952</span>K), <span class="number">0.0095289</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 776K-&gt;0<span class="title">K</span><span class="params">(<span class="number">38400</span>K)</span>] [ParOldGen: 8K-&gt;624<span class="title">K</span><span class="params">(<span class="number">87552</span>K)</span>] 784K-&gt;624<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, [Metaspace: 3395K-&gt;3395<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0057008 secs] [Times: user</span>=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">38400</span>K, used <span class="number">998</span>K [<span class="number">0x00000000d5f80000</span>, <span class="number">0x00000000d8a00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">33280</span>K, <span class="number">3</span>% used [<span class="number">0x00000000d5f80000</span>,<span class="number">0x00000000d6079b20</span>,<span class="number">0x00000000d8000000</span>)</span><br><span class="line">  from space <span class="number">5120</span>K, <span class="number">0</span>% used [<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8500000</span>)</span><br><span class="line">  to   space <span class="number">5120</span>K, <span class="number">0</span>% used [<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8a00000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">87552</span>K, used <span class="number">624</span>K [<span class="number">0x0000000081e00000</span>, <span class="number">0x0000000087380000</span>, <span class="number">0x00000000d5f80000</span>)</span><br><span class="line">  object space <span class="number">87552</span>K, <span class="number">0</span>% used [<span class="number">0x0000000081e00000</span>,<span class="number">0x0000000081e9c068</span>,<span class="number">0x0000000087380000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3415</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 371<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></div></figure><p>实例 A、实例 B 都被放在新生代， <code>Full GC</code> 表示垃圾收集发生了 <code>Stop-The-World   </code>。所以直接看这一行，<code>[PSYoungGen: 776K-&gt;0K(38400K)]</code> ，JVM 并没有因为实例 A 和 实例 B 相互引用就没有去回收它们。表明了 JVM 并没有采用引用计数算法判定对象是否可以被回收。</p><p>JVM 中采用的是可达性分析算法判断对象是否可以被回收的。</p>        <h2 id="可达性分析算法">          <a href="#可达性分析算法" class="heading-link"><i class="fas fa-link"></i></a>可达性分析算法</h2>      <p>基本思路：</p><p>通过一系列称为 “GC Roots” 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。</p><p><strong>可作为 GC Roots 的对象有</strong>：</p><ul><li>虚拟机栈中的引用的对象</li><li>方法区的静态变量和常量引用的对象</li><li>本地方法栈中 JNI 引用的对象</li></ul><p>在上面的例子中，当执行第 5、6 步后，内存堆栈结构如下图。虽然实例 A 和实例 B 相互引用，但是它们到 GC Roots 都是不可达的了，所以它们都会被判定成可回收对象。</p><p><img src="/2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/jvm_judge_object_recycle_2.png" alt="jvm_judge_object_recycle_2"></p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 中的内存溢出</title>
      <link href="2019/01/11/OutOfMemoryError-in-JVM/"/>
      <url>2019/01/11/OutOfMemoryError-in-JVM/</url>
      
        <content type="html"><![CDATA[<p>内存溢出，通俗一点，就是 JVM 内存不足了，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>这里的意思是说，通常在抛出 OutOfMemoryError 之前，垃圾收集器会被触发，尽其所能去清理空间。</p><p>但也不是在所有情况下垃圾回收器都会被触发，比如分配了一个大对象，超过了堆的最大值，JVM 可能判断出垃圾收集并不能解决这个问题，直接抛出 OutOfMemoryError 。</p><p>在 <a href="http://wuzhangyang.com/2019/01/10/JVM-memory-structure/">JVM内存结构</a> 中，除了程序计数器，其他区域都有可能发生 OutOfMemoryError 。</p>        <h2 id="堆溢出">          <a href="#堆溢出" class="heading-link"><i class="fas fa-link"></i></a>堆溢出</h2>      <p>通过<code>-Xms</code> 和<code>Xmx</code>分别设定堆最小值和最大值。</p><p>错误信息：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></div></figure><p>可能原因：</p><ul><li>内存泄漏</li><li>堆的大小不合理，比如处理可观的数据量，但是没有显示指定 JVM 堆大小或者指定数值太小</li><li>JVM 处理引用不及时，导致堆积起来，内存无法释放</li></ul>        <h2 id="栈溢出">          <a href="#栈溢出" class="heading-link"><i class="fas fa-link"></i></a>栈溢出</h2>      <p>通过 <code>--Xss</code> 设置栈容量大小。</p><p>这里的栈包括虚拟机栈和本地方法栈。</p><p>比如递归操作，没有退出条件，会导致不断的压栈，JVM 就会抛出 StackOverFlowError。</p><p>如果 JVM 试图去扩展栈空间的时候失败，则会抛出 OutOfMemoryError。</p>        <h2 id="方法区溢出">          <a href="#方法区溢出" class="heading-link"><i class="fas fa-link"></i></a>方法区溢出</h2>      <p>通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 限制方法区的大小。</p><p><code>String.intern()</code> 的作用是：如果字符串常量池中已经包含一个等于此 String对象的字符串，则返回代表池中这个字符串的 String 对象，否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。所以，当字符串缓存占用太多空间，也会导致 OOM 问题。</p><p>错误信息：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></div></figure><p>JDK 1.7 后，方法区引入元数据区，元数据区默认自增，方法区内存不再那么窘迫。</p><p>元数据区错误信息：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Metaspace</span><br></pre></td></tr></table></div></figure>        <h2 id="直接内存溢出">          <a href="#直接内存溢出" class="heading-link"><i class="fas fa-link"></i></a>直接内存溢出</h2>      <p>通过 <code>-XX：MaxDirectMemorySize</code> 指定直接直接内存容量大小。</p><p>特征：</p><p>Heap Dump 文件中不会看见明显的异常，如果 Dump 文件很小，程序中有使用 NIO，可以考虑检查是否是直接内存溢出。</p>        <h2 id="参考资料">          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="2019/01/10/JVM-memory-structure/"/>
      <url>2019/01/10/JVM-memory-structure/</url>
      
        <content type="html"><![CDATA[<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。</p><p><img src="/2019/01/10/JVM-memory-structure/java_memory_structure.png" alt="java_memory_structure"></p><p>这些区域中，一些是线程私有的，一些是线程共享的。</p><p><strong>线程私有的</strong>：程序计数器、虚拟机栈、本地方法栈</p><p><strong>线程共享的</strong>：堆、方法区、直接内存</p>        <h2 id="程序计数器">          <a href="#程序计数器" class="heading-link"><i class="fas fa-link"></i></a>程序计数器</h2>      <p>一块较小的内存空间，用于标记当前线程所执行字节码的行号。</p><p>Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现，所以确定的时刻一个处理器只会执行一个线程中的指令。</p><p>为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器，用于记录线程所执行字节码指令的地址。</p>        <h2 id="虚拟机栈">          <a href="#虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a>虚拟机栈</h2>      <p>Java 虚拟机栈是由一个个帧栈组成。</p><p>每个方法执行时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>当方法调用时，栈帧入栈，方法结束时，栈帧出栈。</p><p>局部变量表的所需的内存空间在编译期间完成分配，运行时不会改变大小。</p><p>虚拟机栈定义了两种异常状况：StackOverFlowError  和  OutOfMemoryError 。</p><ul><li>StackOverFlowError：线程请求的栈深度大于虚拟机所允许的深度。</li><li>OutOfMemoryError ：大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出 OutOfMemoryError。</li></ul>        <h2 id="本地方法栈">          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a>本地方法栈</h2>      <p>本地方法栈为虚拟机使用到的 native 方法服务。</p><p>HotSpot 虚拟机直接把虚拟机栈与本地方法栈合二为一。与虚拟机栈一样，也会抛出 StackOverFlowError 和 OutOfMememoryError 异常。</p>        <h2 id="堆">          <a href="#堆" class="heading-link"><i class="fas fa-link"></i></a>堆</h2>      <p>Java 堆是垃圾收集器管理的主要区域，也称为 GC 堆。所有实例和数组都在这里分配内存，也是线程共享的内存区域。</p><p>-Xms 设置最小值；-Xmx 设置最大值。</p><p>堆内存分配会另写一篇文章介绍。</p>        <h2 id="方法区">          <a href="#方法区" class="heading-link"><i class="fas fa-link"></i></a>方法区</h2>      <p>与 Java 堆一样，也是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><p>在 HotSpot 虚拟机中，这块区域对应永久代，不易被回收。</p><p><strong>运行时常量池</strong>：属于方法区一部分。用于存放编译期生成的常量和引用。</p><p>JDK 1.7 之后已经将运行时常量池从移出，在堆上开辟了一块区域存放运行时常量池。</p>        <h2 id="直接内存">          <a href="#直接内存" class="heading-link"><i class="fas fa-link"></i></a>直接内存</h2>      <p>直接内存并不是虚拟机内存的一部分，也不是 Java 虚拟机规范中定义的内存区域。</p><p>jdk1.4 中新加入的 NIO，引入了通道与缓冲区的 IO 方式，它可以调用 Native 方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p>        <h2 id="参考资料">          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>      <p><span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 byte 的范围是 -128 ~ 127?</title>
      <link href="2019/01/06/byte-range/"/>
      <url>2019/01/06/byte-range/</url>
      
        <content type="html"><![CDATA[<p>这是一个很基础的问题。但是在昨天之前，我都是只知其然，不知其所以然。</p><p>于是我搜索了大量网络资料。说实话，看完大部分文章，我还是没有弄明白为什么。直到我看到了知乎上面的一个回答：</p><p><span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/20458542">在8位二进制中，-128 没有原码、反码形式，那么它的补码是怎么计算出来的？还是约定的？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，醍醐灌顶。</p><p>这里尝试自己阐述一遍，如果你没有看懂，那是我的问题，还是直接看参考链接。</p><p>首先，忘记原码、补码、反码的概念。</p><p>从 「<strong>模</strong>」开始。什么是模?</p><p>想象日常见到的时钟，它可以表示 0 - 12 点的时间。假设当前时针指向 8 点，而准确时间是 5 点。那么调整方法有两种：</p><p>一种方法是将逆时针拨 3 小时，8 - 3 = 5。</p><p>另一种方法是顺时针拨 9 小时，8 + 9 = 12 + 5 = 5。</p><p>可以看出，减 3 和加 9 的效果是一样的，这里的 12 就是模，3 和 9 在模 12 中互为补数，也就是相加等于模的大小。</p><p>所以，在模的范围内做减法，可以将 X - Y 的减法等价于 X + Y 的补数。</p><p>但是新的问题又出现了，这种算法的结果永远是正数。</p><p>比如 3 - 8 = 3 + (12 - 8) = 7，实际上 3 - 8 = -5。很明显，7 不等于 -5 的。</p><p>怎么办呢，当初那些先贤想出来很简单的方法，就是把两个数直接划等号，正好解决了负数的表达方式。-5 的绝对值的补数正好是 7。</p><p>但是，又出现了新的问题，7 已经用来表示正数 7 了，现在又来表示 -5，当 7  出现时就很难辨别它到底代表谁了。</p><p>为了保留这套规则，只能牺牲 7 了，确定 7 只代表 -5。所以给这套规则划定一个范围，原来 0 - 11 的正数，拆分为两部分，0 - 5 这个区间代表正数，6 - 11 这个区间就用来代表各自的补数的负值。</p><p>回到二进制的计算机世界。</p><p>我们知道 byte 占用 8 位，一共可以表示 2 的 8 次方，256 个数，即 0 ~ 255。模是 256。</p><p>按照上面的规则， 0 - 127 代表其正数本身，128 - 255 代表其补数的负值，也就是 “-1 ~ - 128”。</p><p>所以，byte 的表示范围就是 -128 ~ 127 了。</p><p>总结下：</p><p>1、计算机中负值的表达方式就是它绝对值的补数。</p><p>2、这样表达的方式是为了实现数值运算而决定的。</p><p>3、几乎所有的课本和老师都只给出结论，没有给出解释原理的做法真是简直了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 年过去了，我很怀念它</title>
      <link href="2018/12/31/my-2018/"/>
      <url>2018/12/31/my-2018/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&id=454489&auto=1&height=66"></iframe>每到年底，大家都会总结过去的一年里的得与失，收获与不足，也会为新的一年立下新的 Flag。<p>有时候在想为什么要有新年的感念，也许就是希望吧。每个人都需要一个时间周期去不断给自己寄予新的希望，而这个周期不能太长，以便可以安慰自己的平庸，这个周期不能太短，至少可以笃定的注视前方。</p><p>回望这一年，也是有几件值得纪念的事情。</p><p>1、3 月 8 日，老鲍回国，大学兄弟们聚得最齐的一次。</p><p>2、5 月 20 日和女友去第一次去看了朴树的演唱会。</p><p>3、6 月 19 日和女朋友领了证。</p><p>4、11 月 09 日进新房，双方父母第一次见面。</p><p>5、12 月 15 日，看了许巍的演出，第一次与许巍合影。</p><p>其实每一件事情对于个人来说都算挺有意义的，都值得细说。</p><p>这一年里认知能力提升不少，如 <a href="http://wuzhangyang.com/2018/12/05/d-k-effect/">这篇文章</a>，我目前处在知道自己不知道这一阶段，其实处在这个阶段挺痛苦的，经常性会心情失落，因为短时间很难做出巨大的改变。但幸好我愿意去做出改变。</p><p>这一年的技术能力有提升，但不是很满意，反省下，自己的执行力、坚持能力还是不够，其实可以做到更好些，为后面的改变、选择做更充分的准备。但时间过去了，只能安慰下平庸的自己。</p><p>编程、写作、英语是最重要的三大能力，无论是现在还是未来。所以，新的一年里，在此立下几个 Flag。</p><p>1、看准机会，增加收入。</p><p>2、做一个像样点的开源软件，向郭霖大神学习。</p><p>3、每周不低于一篇技术博客，逼着自己学习技术。</p><p>4、每周不低于一篇公众号文章，技术、思考、认知、感悟都可以。</p><p>5、报一个英语班，坚持下去。</p><p>6、主动一些，多接触一些段位比我高的人。</p><p>7、多出去走走，见见外面的世界，多接触些有趣的人和事。</p><p>8、保持身心健康。</p><p>最后，感谢这一年帮助我的亲人朋友，祝愿你们 2019 年健康平安，万事如意。</p><p>也谢谢你的观看，愿你如意平安。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频学习资源汇总</title>
      <link href="2018/12/12/android-media-learn-resource/"/>
      <url>2018/12/12/android-media-learn-resource/</url>
      
        <content type="html"><![CDATA[<p>1、<span class="exturl"><a class="exturl__link" href="http://blog.51cto.com/ticktick/1956269">Android 音视频开发入门指南</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ：音视频学习思路，一系列学习任务。</p><p>2、<span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/renhui/p/7452572.html">Android 音视频开发学习思路</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：音视频学习路径，教程。</p><p>3、《雷霄骅的专栏》：<span class="exturl"><a class="exturl__link" href="http://blog.csdn.net/leixiaohua1020">http://blog.csdn.net/leixiaohua1020</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>4、《Jhuster的专栏》：<span class="exturl"><a class="exturl__link" href="http://blog.51cto.com/ticktick">http://blog.51cto.com/ticktick</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>5、《FFMPEG Tips》：<span class="exturl"><a class="exturl__link" href="http://ticktick.blog.51cto.com/823160/d-17">http://ticktick.blog.51cto.com/823160/d-17</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>6、《Learn OpenGL 中文》：<span class="exturl"><a class="exturl__link" href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>7、《Android Graphic 架构》：<span class="exturl"><a class="exturl__link" href="https://source.android.com/devices/graphics/">https://source.android.com/devices/graphics/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>8、《ywl5320的专栏》：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/ywl5320">https://blog.csdn.net/ywl5320</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>9、《灰色飘零》：<span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/renhui/">https://www.cnblogs.com/renhui/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>达克效应</title>
      <link href="2018/12/05/d-k-effect/"/>
      <url>2018/12/05/d-k-effect/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>达克效应</strong>（英语：D-K effect），全称为<strong>邓宁-克鲁格效应</strong>（英语：Dunning–Kruger effect），是一种<span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/wiki/%E8%AE%A4%E7%9F%A5%E5%81%8F%E5%B7%AE">认知偏差</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，能力欠缺的人有一种虚幻的自我优越感，错误地认为自己比真实情况更加优秀。简言之即：庸人容易因欠缺自知之明而自我膨胀。</p><p><span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/w/index.php?title=Kruger&action=edit&redlink=1">Kruger</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和<span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/w/index.php?title=Dunning&action=edit&redlink=1">Dunning</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>将其归咎于<span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/wiki/%E5%85%83%E8%AE%A4%E7%9F%A5">元认知</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上的缺陷，能力欠缺的人无法认识到自身的无能，不能准确评估自身的能力。他们的研究还表明，反之，非常能干的人会低估自己的能力，错误地假定他们自己能够很容易完成的任务，别人也能够很容易地完成。</p></blockquote><p>参考网上，动手绘制了下面这张图，更为清晰。</p><p><img src="/2018/12/05/d-k-effect/d-k-effect.png" alt="d-k-effect"></p><p>从左往右，智慧从低到高，从下往上，是自信程度从低到高。</p><p>不是所有人都能完整的经历这条曲线。</p><p>大多数人都是在攀爬愚昧山峰，到顶之后可能就不动了。不动的原因是什么 ？<strong>认知停滞</strong>。认知停滞，会导致个人对世界的看法难以发生改变。对待新事物，只会用自己的思维框架强行套用，自信心爆棚，根本没有耐心去了解未知的领域。</p><p>当掌握的领域知识越来越多，认知逐渐提高后，一些人会进入「自信崩溃区」，因为这个时候知道了自己未知的领域太多太多，自信心备受打击，不知道如何是好。</p><p>到达「绝望之谷」后不一定马上就能反弹，有时需要经历很多波折，才能对新的领域有正确的认识，而新的开悟之坡非常漫长，有些人终其一生都不能进入「平稳高原」。</p><p>人与人之间的差异，真的是认知的差异。</p><p>身处「愚昧之巅」的人，更有倾向会去攻击辱骂更加智慧的人。主要原因就是认知差距，无知无畏。</p><p>认知层次高的人，对未知领域会更有敬畏心。</p><p>这张图值得时不时拿出来看看，就某件事情，对号入座，反思，避免成为达克效应描述的对象。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零一八年农历十月二十一</title>
      <link href="2018/11/28/2018-lunar-10-21/"/>
      <url>2018/11/28/2018-lunar-10-21/</url>
      
        <content type="html"><![CDATA[<p>昨天同事喊我去参加面试，公司的其他部门技术岗。想来很久没面试了，于是就去试下水。</p><p>有几点感受。</p><p>首先，发现原来自己真的还差得远呢。随便一个 Http 的知识点就难倒我了。工作中只知道使用，压根没深入学习原理。这也提醒了我多去钻研技术，不要只停留在表面。</p><p>其次，技术面试官的更关注的是学历、职级、绩效，这是我很诧异的。因为我发现有时候学历、职级、绩效真得不见得和个人能力成正比，如果是 HR 问这些还情有可原，技术面试官问这些就感觉挺 Low 比的。因为他问我今年绩效拿了几个 D，这个时候我就挺毛躁的了。</p><p>上个月的绩效领导给我打了个 D，如果真是如他所说是轮流来，不会这么快就轮到我，我其实知道是什么原因的，我也没有多问多说了。</p><p>说不在乎那是假话，但是能怪谁呢，还不是自己不够强大。</p><p>我很感谢工作上的一些不顺利和不公平，因为它们很好地折射了自己的工作确实做得还不够好，同时也敦促我更加积极努力，更加快速地成长。</p><p>今天是我的生日，说点感动的。</p><p>早上坐车听了个电台节目，讲述者是导演张涛，讲述的是他和他的姥姥和奶奶的故事，听的过程中，眼泪一直在眼眶中打转。想起了我的奶奶，想起她给我过生日的场景，想起她带我们堂兄弟四个孩子在一起生活的过往，真的太不容易了。如今她老人家已经走了好几年了，我时常会怀念她。</p><p>昨晚母亲给我打电话，专门提醒我今天过生日要买些好吃的，心里头真是温暖感动极了。父母对子女的爱，真的是太无私了，真的是可以倾尽所有。我想我能做的，就是尽快成长，成为他们的依靠。</p><p>很感谢老丈人和丈母娘的生日祝福，感谢你们的帮助，我定好好回报。</p><p>女朋友今天专门给我买了蛋糕，我们在温暖的家里过生日，非常感谢她一路陪伴。</p><p>群里的小伙伴送来了真挚的祝福，很是感动。</p><p>爱你们。愿你们健康平安。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 8.0 应用保活实践</title>
      <link href="2018/11/27/android-keep-alive/"/>
      <url>2018/11/27/android-keep-alive/</url>
      
        <content type="html"><![CDATA[<p>虽然我也觉得强行保活应用挺不厚道的，但是没办法，为了完成需求。</p><p>一开始尝试的方案是 Android 5.0 后系统提供的 JobScheduler，能够预先设置条件，达到条件时自动启动 JobService，在 Android 8.0 以下都能很愉快的使用。但是在华为的 Android 8.0 上，当应用被杀后，JobService 就不能被系统调用了。</p><p>于是采取了双进程服务绑定方式，实现了应用保活功能。</p><p>直接看原理图：</p><p><img src="/2018/11/27/android-keep-alive/aidl_keep_alive.png" alt="aidl_keep_alive"></p><p>原理就是利用 Binder 的讣告机制，如果 Service Binder 实体的进程被杀，系统会向 Client 发送讣告，这个时机就是保活的空子了。所以可以通过两个进程启动两个 Binder 服务，互为 C/S，一旦一个进程挂掉，另一个进程就会收到 Binder 讣告，这时可以拉起另一个进程。</p><p>那么图中两个进程中的 TransferActivity 是干什么用的 ，这个在后面再说。</p><p>这里我写了两个应用，一个是 AIDLServer，相当于服务端；一个是 AIDLClient，相当于客户端。而两个进程之间的通信采用 AIDL 方式。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.wuzy.aidlserver;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">bindSuccess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意两个应用的 AIDL 文件必须一致，包括包名。</p><p>然后，编写两个 binder 实体服务 RemoteService 、LocalService，主要代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;RemoteService&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate: 创建 RemoteService&quot;</span>);</span><br><span class="line">        bindLocalService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stub;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface.Stub stub = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindSuccess</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;bindSuccess: LocalService 绑定 RemoteService 成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;unbind: 此处解除 RemoteService 与 LocalService 的绑定&quot;</span>);</span><br><span class="line">            getApplicationContext().unbindService(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定 LocalService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindLocalService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">&quot;com.wuzy.aidlclient&quot;</span>, <span class="string">&quot;com.wuzy.aidlclient.LocalService&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!getApplicationContext().bindService(intent, connection, Context.BIND_AUTO_CREATE)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;bindLocalService: 绑定 LocalService 失败&quot;</span>);</span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// bindRemoteService();</span></span><br><span class="line">            createTransferActivity();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTransferActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TransferActivity.class);</span><br><span class="line">        intent.setAction(TransferActivity.ACTION_FROM_SELF);</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;LocalService&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate: 创建 LocalService&quot;</span>);</span><br><span class="line">        bindRemoteService();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onBind: 绑定 LocalService&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface.Stub stub = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindSuccess</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;bindSuccess: RemoteService 绑定 LocalService 成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            getApplicationContext().unbindService(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// bindRemoteService();</span></span><br><span class="line">            createTransferActivity();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTransferActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TransferActivity.class);</span><br><span class="line">        intent.setAction(TransferActivity.ACTION_FROM_SELF);</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindRemoteService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">&quot;com.wuzy.aidlserver&quot;</span>, <span class="string">&quot;com.wuzy.aidlserver.RemoteService&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!getApplicationContext().bindService(intent, connection, Context.BIND_AUTO_CREATE)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;bindRemoteService: 绑定 RemoteService 失败&quot;</span>);</span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>在 onCreate 的时候相互绑定，并在 onServiceDisconnected 收到讣告的时候，重新启动服务绑定彼此即可。</p><p>但是我在系统是 8.0 的华为机器上是无效的，也就是当 LocalService 所在进程被杀后，RemoteService 无法启动LocalService，反过来也是如此。</p><p>所以，这里只能采取 “曲线救国” 的方式。通过 TransferActivity 中转下，先启动守护进程的 TransferActivity，再从守护进程的 TransferActivity 中启动保活进程的 TransferActivity，这是没有问题的，再从保活进程的 TransferActivity 中启动 LocalService，重新绑定服务即可，反过来也是一样的。当然，TransferActivity 要用户无感知，不然会很突兀，所以这里的 TransferActivity 都是 1 个像素，做完任务及时销毁即可。</p><p>TransferActivity 的代码就不贴了，具体可以去 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidKeepAlive">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 了解。</p><p>这种方式用来保活一般是没有问题的，因为 Binder 讣告是系统中 Binder 框架自带的，除非一次性杀了两个进程，那就没辙了。</p><p>最后，一般保活的目的是为了做某项任务，所以，任务完成后应该结束保活功能，不然老是占着内存确实挺不厚道的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 保活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频基础知识</title>
      <link href="2018/11/14/Android-media-foundation/"/>
      <url>2018/11/14/Android-media-foundation/</url>
      
        <content type="html"><![CDATA[        <h2 id="视频编码">          <a href="#视频编码" class="heading-link"><i class="fas fa-link"></i></a>视频编码</h2>      <p>通过特定的压缩技术，将某个视频格式文件转换成另一种视频格式文件的方式。编解码标准有国际电联的 H.261、H.263、H.264，运动静止图像专家组的 M-JPEG 和国际标准化组织运动图像专家组的 MPEG 系列标准，此外，互联网上还有 Real-Networks 的 RealVideo，微软公司的 WMV 以及 Apple 公司的 QuickTime 等。</p><ul><li>MPEG：主要有 MPEG1(VCD)，MPEG2(DVD)、MPEG4(DivX、XviD)、MPEG4 AVC。</li><li>H.26X ：侧重网络传输，包括 H.261、H.263、H.263、H.263+、H.263++、H.264。</li></ul>        <h2 id="音频编码">          <a href="#音频编码" class="heading-link"><i class="fas fa-link"></i></a>音频编码</h2>      <ul><li>MP3：将声音以 1:    10 甚至 1:12 的压缩率进行压缩。对高频信号使用大压缩率，低频信号使用小压缩率，保证信号不失真。</li><li>AAC：与 MP3 相比，优点是音质更佳、文件更小。缺点是属于有损压缩，与时下流行的 APE、FLAC 等无损压缩格式相比音质差距较大。</li><li>AC3：Dobly 实验室所发展的有损音频编码方式，广泛应用于激光唱片和 DVD。AC3提供的环绕声系统由五个全频域声道（左前、中央、右前、左后、右后）和一个超低音声道，广泛用于电影院。</li></ul>        <h2 id="相关知识点">          <a href="#相关知识点" class="heading-link"><i class="fas fa-link"></i></a>相关知识点</h2>              <h3 id="1、帧率">          <a href="#1、帧率" class="heading-link"><i class="fas fa-link"></i></a>1、帧率</h3>      <p>测量显示帧数的量度。fps：每秒显示帧数。</p>        <h3 id="2、">          <a href="#2、" class="heading-link"><i class="fas fa-link"></i></a>2、</h3>      ]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 单元测试 Junit</title>
      <link href="2018/10/24/android-junit-test/"/>
      <url>2018/10/24/android-junit-test/</url>
      
        <content type="html"><![CDATA[<blockquote><p>示例代码：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/AndroidUnitTest">https://github.com/zywudev/AndroidUnitTest</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></blockquote><p>Anroid Studio 在新建项目中自动将 Junit 框架集成，无需额外导入依赖。</p>        <h2 id="Junit-Assert">          <a href="#Junit-Assert" class="heading-link"><i class="fas fa-link"></i></a>Junit Assert</h2>      <p>Assert 就是断言，判断假设与实际是否一致，一致则测试通过。</p><p>常用断言：</p><ul><li>assertTrue                                  假设为真</li><li>assertFalse                                 假设为假</li><li>assertEquals                              假设相同（基本数据类型或者对象）</li><li>assertNotEquals                       假设不相同（基本数据类型或者对象）</li><li>assertNull                                  假设为空</li><li>assertNotNull                           假设不为空</li><li>assertSame                               假设相同（只能是对象）</li><li>assertNotSame                        假设不相同（只能是对象）</li><li>assertArrayEquals                   假设数组相同</li><li>assertThat                                断言实际值是否满足指定的条件</li></ul><p>期望值是前一个参数，实际值是后一个参数。</p><p><strong>assertThat</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assertThat(T actual, Matcher&lt;? <span class="keyword">super</span> T&gt; matcher);</span><br><span class="line"></span><br><span class="line">assertThat(String reason, T actual, Matcher&lt;? <span class="keyword">super</span> T&gt; matcher); </span><br></pre></td></tr></table></div></figure><p>其中，reason 为断言失败的输出信息，actual 为实际值，matcher 为匹配器。</p><p>常用的匹配器整理：</p><ul><li>is    断言参数等于后面给出的匹配表达式    </li><li>not    断言参数不等于后面给出的匹配表达式    </li><li>equalTo    断言参数相等    </li><li>equalToIgnoringCase    断言字符串相等忽略大小写</li><li>containsString    断言字符串包含某字符串    </li><li>startsWith    断言字符串以某字符串开始</li><li>endsWith    断言字符串以某字符串结束</li><li>nullValue    断言参数的值为null</li><li>notNullValue    断言参数的值不为null    </li><li>greaterThan    断言参数大于    </li><li>lessThan    断言参数小于</li><li>greaterThanOrEqualTo    断言参数大于等于</li><li>lessThanOrEqualTo    断言参数小于等于</li><li>closeTo    断言浮点型数在某一范围内</li><li>allOf    断言符合所有条件，相当于&amp;&amp;    </li><li>anyOf    断言符合某一条件，相当于或</li><li>hasKey    断言Map集合含有此键    </li><li>hasValue    断言Map集合含有此值    </li><li>hasItem    断言迭代对象含有此元素</li></ul><p>自定义匹配器：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzy on 2018/10/26.</span></span><br><span class="line"><span class="comment"> * 自定义匹配器，判断数字是否在范围内</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsNumberRangeMatcher</span> <span class="keyword">extends</span> <span class="title">BaseMatcher</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IsNumberRangeMatcher</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer i = (Integer) item;</span><br><span class="line">        <span class="keyword">return</span> start &lt;= i &amp;&amp; i &lt;= end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeTo</span><span class="params">(Description description)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p><span class="exturl"><a class="exturl__link" href="http://www.vogella.com/tutorials/Hamcrest/article.html">http://www.vogella.com/tutorials/Hamcrest/article.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="Junit-Annotation">          <a href="#Junit-Annotation" class="heading-link"><i class="fas fa-link"></i></a>Junit Annotation</h2>      <p>常用注解：</p><ul><li>@Test    表示此方法为测试方法<br>   @Before    在每个测试方法前执行，可做初始化操作<pre><code>@After    在每个测试方法后执行，可做释放资源操作</code></pre>   @Ignore    忽略的测试方法<br>   @BeforeClass    在类中所有方法前运行。此注解修饰的方法必须是static void<br>   @AfterClass    在类中最后运行。此注解修饰的方法必须是static void<br>   @RunWith    指定该测试类使用某个运行器<br>   @Parameters    指定测试类的测试数据集合<br>   @Rule    重新制定测试类中方法的行为<br>   @FixMethodOrder    指定测试类中方法的执行顺序</li></ul><p>执行顺序：</p><p>@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass</p><p><strong>@Test</strong></p><p>它可以接受两个参数，一个是预期异常，一个是超时时间。</p><p>即不出现预期异常则测试不通过；超过超时时间则测试不通过。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = ParseException.class)</span>   <span class="comment">// 日期解析错误，预期异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateToStamp1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DateUtil.dateToStamp(time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test(timeout = 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateToStamp2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DateUtil.dateToStamp(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>@Parameters</strong></p><p>参数化测试，用于测试数据集合。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(Parameterized.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtilTest</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">primeNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;2018-10-24&quot;</span>, <span class="string">&quot;2018-10-24 16:18:28&quot;</span>,<span class="string">&quot;2018年10月24日 16点18分28秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>@Rule</strong></p><p>Junit 提供自定义规则。</p><ul><li>实现 TestRule 接口，实现 apply 方法。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzy on 2018/10/26.</span></span><br><span class="line"><span class="comment"> * 自定义 Rule，单元测试方法执行前后打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRule</span> <span class="keyword">implements</span> <span class="title">TestRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Statement base, <span class="keyword">final</span> Description description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Statement() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// evaluate前执行方法相当于@Before</span></span><br><span class="line">                String methodName = description.getMethodName(); <span class="comment">// 获取测试方法的名字</span></span><br><span class="line">                System.out.println(methodName + <span class="string">&quot;测试开始！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                base.evaluate();  <span class="comment">// 运行的测试方法</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// evaluate后执行方法相当于@After</span></span><br><span class="line">                System.out.println(methodName + <span class="string">&quot;测试结束！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>在测试类中添加自定义 Rule 。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 添加自定义 Rule</span></span><br><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> MyRule myRule = <span class="keyword">new</span> MyRule();</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Junit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济机器是怎样运行的？</title>
      <link href="2018/10/16/how-the-economic-machine-works/"/>
      <url>2018/10/16/how-the-economic-machine-works/</url>
      
        <content type="html"><![CDATA[<p>最近看到的一个视频，是大师级人物瑞达利欧自己的宏观经济框架，三十分钟解释了经济机器是怎样运行的，通俗易懂。</p><p>视频地址：<span class="exturl"><a class="exturl__link" href="https://www.youtube.com/watch?v=rFV7wdEX-Mo">https://www.youtube.com/watch?v=rFV7wdEX-Mo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>以下是个人总结的要点，结合视频看，效果更佳。</p><p>经济是由几个简单的零部件和无数次重复的简单交易组成，这些交易首先由人的天性所驱动，因而形成了三股主要的经济动力。</p><p>1、生产率的提高</p><p>2、短期债务周期</p><p>3、长期债务周期</p><p>把三股动力结合在起来，就是一个简单有效的宏观经济分析模型。</p><p><img src="/2018/10/16/how-the-economic-machine-works/image_1.png" alt="image_1"></p>        <h2 id="交易">          <a href="#交易" class="heading-link"><i class="fas fa-link"></i></a>交易</h2>      <p>交易时刻在发生，你每次买东西都是进行一笔交易。</p><p><img src="/2018/10/16/how-the-economic-machine-works/image_2.png" alt="image_2"></p><p>在一次交易中，买方可以使用「货币、信用」向卖方交换「商品、服务、金融资产」。</p><p>信用在使用时和货币是一样的，经济社会中同时存在着货币和信用，把两者相加，就是支出总额—这是经济的驱动力。 </p><p>支出之所以是经济的驱动力，是因为一个人的支出是另一个人的收入。</p><p>在经济体中，有四种交易主体：个人、企业、银行和政府。</p><p><img src="/2018/10/16/how-the-economic-machine-works/image_3.png" alt="image_3"></p><p>其中政府是最大的买方和卖方。政府包括中央政府和中央银行。</p><p>中央银行控制经济中的货币和信贷数量，主要通过利率和发行货币来控制。</p><p><img src="/2018/10/16/how-the-economic-machine-works/image_4.png" alt="image_4"></p>        <h2 id="信贷">          <a href="#信贷" class="heading-link"><i class="fas fa-link"></i></a>信贷</h2>      <p>人们在交易过程中除了使用货币还会使用「信用」。</p><p>一旦使用信用，则会同时产生「信贷」和「债务」，债务是贷款人的资产，是借款人的负债，借款人一旦获得信贷，便可以增加自己的支出，而一个人的支出是另一个人的收入，这就导致借贷在不断增加循环。这一驱动模式导致经济增长，也就形成了长短债务周期。</p><p><img src="/2018/10/16/how-the-economic-machine-works/image_5.png" alt="image_5"></p>        <h2 id="经济周期">          <a href="#经济周期" class="heading-link"><i class="fas fa-link"></i></a>经济周期</h2>      <p>生产率的提高是经济发展的根本动力，如果抛开其它动力的影响，生产率提高会使得经济长期缓慢线性发展。</p><p>但信贷是导致经济周期的根本原因。为什么呢？</p><p>因为债务本质上是向未来的自己借钱，提前消费。你给自己设定了一个未来的时间，到那个时候你的支出必须少于收入，以便偿还债务，这样马上就产生了一个短期债务周期。</p><p><img src="/2018/10/16/how-the-economic-machine-works/image_6.png" alt="image_6"></p>        <h3 id="短期债务周期">          <a href="#短期债务周期" class="heading-link"><i class="fas fa-link"></i></a>短期债务周期</h3>      <p>如果支出和收入的增长速度超过所售商品的生产速度，价格就会上涨，我们把价格的上涨称为通货膨胀。</p><p>央行会通过利率调节债务成本，从而把短期负债控制在合理范围内。</p><p>通货膨胀－&gt; 价格上涨 －&gt; 提高利率－&gt;  借贷人减少、现有债务成本上升－&gt; 支出资金减少－&gt; 收入下降－&gt; 商品价格下跌－&gt; 经济衰退 －&gt; 降低利率 －&gt; 经济增长</p><p>短期债务周期通常持续5-8年，在几十年里不断重复。</p><p>但是请注意在每个周期的低谷和高峰后，经济增长和债务都超过前一个周期。为什么会这样，这是人促成的，人具有借更多钱和花更多钱的倾向，而不喜欢偿还债务。这是人的天性，因此在长期内债务增加的速度超过收入，从而形成长期债务周期。</p>        <h3 id="长期债务周期">          <a href="#长期债务周期" class="heading-link"><i class="fas fa-link"></i></a>长期债务周期</h3>      <p>长期债务周期通常持续大约75-100年。</p><p>当债务负担过大，亦或者短期债务周期使得某个时间段内收入过少，长期债务的压力可能就会快速释放，从而形成经济危机，政府随之开始去杠杆。</p>        <h2 id="去杠杆化">          <a href="#去杠杆化" class="heading-link"><i class="fas fa-link"></i></a>去杠杆化</h2>      <p><img src="/2018/10/16/how-the-economic-machine-works/image_7.png" alt="image_7"></p><p>主要通过四种办法：</p><p>1、个人、企业和政府削减支出</p><p>2、通过债务违约和重组来减少债务</p><p>3、财富再分配将从富人转给穷人</p><p>4、最后央行发行更多货币</p>        <h3 id="削减支出">          <a href="#削减支出" class="heading-link"><i class="fas fa-link"></i></a>削减支出</h3>      <p>削减支出会导致支出减少，而一个人的支出是另一个人收入，这就导致收入减少。收入下降速度超过还债速度，债务负担会更为严重。企业不得不削减成本，意味着工作机会减少，失业率上升。</p>        <h3 id="债务重组">          <a href="#债务重组" class="heading-link"><i class="fas fa-link"></i></a>债务重组</h3>      <p>如果借款人不偿还债务，出现违约，存款人纷纷取出存款，这种严重的经济收缩就是萧条。</p><p>债务重组让债务消失，但它导致收入和资产价值消失，和削减支出一样会导致通货紧缩。这些会对中央政府产生影响，因为收入降低和就业减少意味着税收减少，失业率上升，政府需要增加支出。如果政府的支出超过税收，就会导致财政赤字。</p>        <h3 id="财务再分配">          <a href="#财务再分配" class="heading-link"><i class="fas fa-link"></i></a>财务再分配</h3>      <p>由于政府需要更多的钱，而大量财富集中在少数人手中，政府自然而然地增加对富人的征税，将财富从富人那里转给穷人。但是这会导致穷人富人相互怨恨，容易造成社会动荡。</p>        <h3 id="发行货币">          <a href="#发行货币" class="heading-link"><i class="fas fa-link"></i></a>发行货币</h3>      <p>当利率接近零的水平，央行就不得不发行更多货币，发行货币与前三种方式不同，会引起通货膨胀和刺激经济。</p><p>央行一方面通过货币购买金融资产，帮助推升资产价格从而提高人们的信用，但这仅仅有助于那些有金融资产的人。另一方面，央行通过购买政府债券，其实就是把钱借给政府使其能够运行赤字预算，并通过刺激计划和失业救济金来增加购买商品和服务的支出，这就增加了人们的收入。</p>        <h2 id="和谐的去杠杆化">          <a href="#和谐的去杠杆化" class="heading-link"><i class="fas fa-link"></i></a>和谐的去杠杆化</h2>      <p>如果决策层取得适当的平衡，推动收入比债务增长得快，债务负担下降，这就是和谐的去杠杆化。</p>        <h2 id="三条经验法则">          <a href="#三条经验法则" class="heading-link"><i class="fas fa-link"></i></a>三条经验法则</h2>      <p>1、不要让债务的增长速度超过收入。因为债务负担最终将把你压垮。</p><p>2、不要让收入的增长速度超过生产率。因为这最终将使你失去竞争力。 </p><p>3、尽一切努力提高生产率。因为生产率在长期内起着最关键的作用。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View 的绘制过程</title>
      <link href="2018/10/16/the-drawing-process-of-android-view/"/>
      <url>2018/10/16/the-drawing-process-of-android-view/</url>
      
        <content type="html"><![CDATA[        <h2 id="View-整体结构">          <a href="#View-整体结构" class="heading-link"><i class="fas fa-link"></i></a>View 整体结构</h2>      <p>Activity、Window、DecorView 之间的关系：</p><p><img src="/2018/10/16/the-drawing-process-of-android-view/view_1.png" alt="view_1"></p><p><strong>Activity</strong>: 类似控制器，统筹视图的添加与显示，以及通过回调来与 Window、View 进行交互。</p><p><strong>Window</strong>：视图承载器，抽象类，PhoneWindow 是其唯一实现类。</p><p><strong>DecorView</strong>：顶级 View，包含 StatusBar、TitleBar + ContentView 和 NavigationBar。</p><p>StatusBar 是状态栏； </p><p>TitleBar 对应各种 ActionBar； </p><p>ContentView 对应 R.id.content，setContentView 设置的 View 被添加到 R.id.content 对应的 View 上。</p><p>NavigationBar是虚拟按键。</p><p><strong>ViewRoot</strong>: 实现类是 ViewRootImpl，它是连接 WidowManager 和 DecorView 的纽带。View 的三大流程(测量（measure），布局（layout），绘制（draw）)均通过 ViewRoot 来完成。ViewRoot 继承了 Handler 类，可以接收事件并分发，Android 的所有触屏事件、按键事件、界面刷新等事件都是通过 ViewRoot 进行分发的。</p>        <h2 id="View-的工作流程">          <a href="#View-的工作流程" class="heading-link"><i class="fas fa-link"></i></a>View 的工作流程</h2>      <p><img src="/2018/10/16/the-drawing-process-of-android-view/view_2.png" alt="view_2"></p><p>View 的绘制是从上往下一层层迭代，DecorView –&gt; ViewGroup（—&gt;ViewGroup）–&gt; View ，依次 measure、layout 、draw。</p>        <h3 id="measure">          <a href="#measure" class="heading-link"><i class="fas fa-link"></i></a>measure</h3>      <p><strong>ViewGroup.LayoutParams</strong></p><p>布局参数类，指定视图 View 的高度和宽度等参数。</p><p><strong>MeasureSpec</strong></p><p>测量规格类，决定一个视图的大小。</p><p><strong>measureSpec</strong>：32 位 int 值，高 2 位代表 mode，低 30 位代表 size。</p><p><strong>mode</strong>：测量模式，包括：</p><ul><li>UNSPECIFIED：父 View 不约束当前 View 的大小。</li><li>EXACTLY：对应 LayoutParams 中的 match_parent 和具体数值这两种模式。父 View 决定当前 View 的精确大小。</li><li>AT_MOST：对应 LayoutParams 中的 wrap_content，View 的大小不能大于父容器的大小。</li></ul><p><strong>size</strong>：某种测量模式下的规格大小。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>measure 流程</strong></p><p>1、ViewRootImpl.performMeasure -&gt; performMeasure()</p><p>根据手机屏幕的宽高和 DecorView 的 LayoutParams 生成 DecorView 的 MeasureSpec，然后调用 DecorView 的 measure() 开始 DecorView 的测量。</p><p>2、DecorView.measure() -&gt; onMeasure()</p><p>DecorView 继承自 FrameLayout，所以会走到 FrameLayout 的 onMeasure() 方法，onMeasure() 里面会调用 measureChild() 为 ViewGroup 生成 MeasureSpec，通过 ViewGroup 的 measure()  开始 ViewGroup 的测量。</p><p>3、ViewGroup.measure() -&gt; onMeasure()</p><p>如果自定义的 ViewGroup 没有重写 onMeasure() 方法，默认会调用 View.onMeasure() 方法，则不会继续对子 view 进行测量。</p><p>因此，自定义 ViewGroup，需要重写 onMeasure() 方法，里面调用 measureChild() 为子 View 生成 MeasureSpec 并测量 child。最后调用 setMeasuredDimension 来设置自己的宽高。</p><p>4、View.measure() -&gt; onMeasure()</p><p>根据父 View 的 MeasureSpec 和自身的 LayoutParams 参数进行测量。</p><p><img src="/2018/10/16/the-drawing-process-of-android-view/view_3.png" alt="view_3"></p><p><strong>细节：</strong></p><p><strong>父 View 的测量方法</strong>：</p><p>根据子 View 的布局样式，调用 setMeasuredDimension 来设置自己的宽高。</p><p><strong>子 View 的测量方法</strong>：</p><p>根据父 View 的 MeasureSpec 和 自身的 LayoutParams 参数进行测量。</p><p>先计算子 View 的MeasureSpec，即 childMeasureSpec；</p><p>再调用 child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 测量子 View 的大小。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                                                          mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                                                           mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>childMeasureSpec 的计算：</p><p>由 parentMeasureSpec 和 childDimension 确定。childDimension 为 LayoutParams 的 width 和 height。</p><p><strong>规律</strong>：</p><ul><li>当子 View 采用具体数值<ul><li>mode: EXACTLY</li><li>size: 自身设置的具体数值</li></ul></li><li>当子 View 采用 match_parent<ul><li>mode: 父容器的测量模式</li><li>size: 若父容器为EXACTLY，则大小为父容器的剩余大小；若父容器为 AT_MOST，则大小为不超过父容器的剩余大小。</li></ul></li><li>当子 View采用 wrap_content<ul><li>mode：AT_MOST</li><li>size：不超过父容器的剩余空间</li></ul></li></ul>        <h3 id="layout">          <a href="#layout" class="heading-link"><i class="fas fa-link"></i></a>layout</h3>      <p>计算视图的位置，也就是 left、top、right、bottom。这些坐标都是相对于父布局的坐标。</p><p>布局也是自上而下，不同的是 ViewGroup 先在 layout() 中确定自己的布局，然后在 onLayout() 方法中再调用子View 的 layout() 方法，让子 View 布局。</p><p><img src="/2018/10/16/the-drawing-process-of-android-view/view_4.png" alt="view_4"></p>        <h3 id="draw">          <a href="#draw" class="heading-link"><i class="fas fa-link"></i></a>draw</h3>      <p>draw 主要流程：</p><ul><li>绘制背景 background.draw(canvas)</li><li>绘制自己（onDraw）</li><li>绘制Children(dispatchDraw)</li><li>绘制装饰（onDrawScrollBars）</li></ul><p><img src="/2018/10/16/the-drawing-process-of-android-view/view_5.png" alt="view_5"></p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://love2.io/@funkkiid/doc/android_interview//android/basis/decorview.md">Window、Activity、DecorView以及ViewRoot之间的关系</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>  </p><p><span class="exturl"><a class="exturl__link" href="https://love2.io/@funkkiid/doc/android_interview//android/basis/custom_view.md">View测量、布局及绘制原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Clean 架构</title>
      <link href="2018/10/16/android-clean-architecture/"/>
      <url>2018/10/16/android-clean-architecture/</url>
      
        <content type="html"><![CDATA[<p> Clean 一般是指，代码以洋葱的形状依据一定的依赖规则被划分为多层：内层对于外层一无所知。这就意味着<strong>依赖只能由外向内</strong>。</p><p><img src="/2018/10/16/android-clean-architecture/clean_1.png" alt="clean_1"></p><ul><li>架构独立。架构不依赖于一些满载功能的软件库。</li><li>可测试性。业务规则可以在没有 UI、数据库等外部元素的情况下完成测试。</li><li>UI的独立性。在不改变系统其余部分的情况下完成UI的简易修改。</li><li>数据库的独立性。业务规则不绑定数据库，可以随意更换数据库的实现。</li><li>外部机制独立。业务规则不知道外层的事情。</li></ul>        <h3 id="Framework-and-Drivers">          <a href="#Framework-and-Drivers" class="heading-link"><i class="fas fa-link"></i></a>Framework and Drivers</h3>      <p>框架或者驱动，包括 UI、框架、数据库实现、网络实现细节等。</p>        <h3 id="Interface-Adapter">          <a href="#Interface-Adapter" class="heading-link"><i class="fas fa-link"></i></a>Interface Adapter</h3>      <p>接口适配层，负责将实现细节和业务逻辑连接起来的粘合层。</p>        <h3 id="Business-rules-Interactors">          <a href="#Business-rules-Interactors" class="heading-link"><i class="fas fa-link"></i></a>Business rules(Interactors)</h3>      <p>业务规则，整合了实现系统需要的所有实例。</p>        <h3 id="Domain-logic">          <a href="#Domain-logic" class="heading-link"><i class="fas fa-link"></i></a>Domain logic</h3>      <p>封装了业务实体。实体可以是包含有方法的对象，或者一系列的数据结构、函数。</p><p>依据这些规则将工程分为三层：</p><p><img src="/2018/10/16/android-clean-architecture/clean_2.png" alt="clean_2"></p>        <h3 id="Presentation-Layer">          <a href="#Presentation-Layer" class="heading-link"><i class="fas fa-link"></i></a>Presentation Layer</h3>      <p>MVC 或者 MVP 对应的地方，不处理 UI 以外的任何逻辑。 </p>        <h3 id="Domain-Layer">          <a href="#Domain-Layer" class="heading-link"><i class="fas fa-link"></i></a>Domain Layer</h3>      <p>业务逻辑 Use Case 实现的地方。属于系统最内层。</p><p>这一层为纯 Java 代码，不牵扯任何 Android 相关依赖，规定了要做什么，具体实现细节交给外层。</p>        <h3 id="Data-Layer">          <a href="#Data-Layer" class="heading-link"><i class="fas fa-link"></i></a>Data Layer</h3>      <p><img src="/2018/10/16/android-clean-architecture/clean_3.png" alt="clean_3"></p><p>所有系统需要的数据通过这一层的 Repository 获取， 这是一种 Repository 模式，具体看<span class="exturl"><a class="exturl__link" href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff649690(v=pandp.10)">这里</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。Repository 接口定义是在 Domain 层，接口表示怎么去存储或者访问数据，这些是业务逻辑，但是具体的实现与业务逻辑无关，应该交给 Data 层。</p>        <h3 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>      <p>1、Clean 架构中内层意味着抽象，外层意味着细节，同样一个抽象可能有多个子类，这种一对多的方式更具灵活性。</p><p>2、细节依赖抽象，业务逻辑制定规则，外层实现接口，这样能保证在内层能够调用外层组件去实现需要的逻辑，这里依据的是 DIP。</p><p>3、Clean 架构较为繁琐，如果是简单项目，完全没必要使用。</p>        <h3 id="测试方法">          <a href="#测试方法" class="heading-link"><i class="fas fa-link"></i></a>测试方法</h3>      <ul><li>Presentation Layer： 使用 AndroidInstruction 和 espresso 做集成测试和功能测试</li><li>Domain Layer：使用 JUnit 和 mockito 做单元测试</li><li>Data Layer：使用 Robolectric（这层有Android依赖）和 junit、mockito 做集成和单元测试。</li></ul>        <h3 id="学习项目">          <a href="#学习项目" class="heading-link"><i class="fas fa-link"></i></a>学习项目</h3>      <ul><li><span class="exturl"><a class="exturl__link" href="https://github.com/android10/Android-CleanArchitecture">https://github.com/android10/Android-CleanArchitecture</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://github.com/crazysunj/CrazyDaily">https://github.com/crazysunj/CrazyDaily</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 事件分发机制</title>
      <link href="2018/10/10/Android-touch-event-dispatch-theory/"/>
      <url>2018/10/10/Android-touch-event-dispatch-theory/</url>
      
        <content type="html"><![CDATA[        <h2 id="MotionEvent">          <a href="#MotionEvent" class="heading-link"><i class="fas fa-link"></i></a>MotionEvent</h2>      <p>根据面向对象思想，事件被封装成 MotionEvent 对象，以下是几个与手指触摸相关的常见事件:</p><ul><li>ACTION_DOWN : 手指初次触摸到屏幕时触发。</li><li>ACTION_MOVE：手指在屏幕上滑动时触发，会触发多次。</li><li>ACTION_UP：手指离开屏幕时触发。</li><li>ACTION_CANCEL：事件被上层拦截时触发。</li></ul><p>对于单指操作，一次触摸事件流程是这样的：</p><p>按下（ACTION_DOWN）–&gt; 滑动（ACTION_MOVE）–&gt; 离开（ACTION_UP)。如果只是简单的点击，则没有 ACTION_MOVE 事件产生。</p>        <h2 id="事件分发、拦截与消费">          <a href="#事件分发、拦截与消费" class="heading-link"><i class="fas fa-link"></i></a>事件分发、拦截与消费</h2>      <p>与事件分发相关的三个重要方法：</p><ul><li>dispatchTouchEvent：事件分发机制中的核心，所有的事件调度都归它管。</li><li>onInterceptTouchEvent：事件拦截。</li><li>onTouchEvent：事件消费处理。</li></ul>        <h2 id="事件分发流程">          <a href="#事件分发流程" class="heading-link"><i class="fas fa-link"></i></a>事件分发流程</h2>      <p>事件分发流程示意图：</p><p><img src="/2018/10/10/Android-touch-event-dispatch-theory/android_touch.png" alt="android_touch"></p><p>大致解释一下：</p><ul><li><p>图中 ViewGroup 与 View 之间省略了若干层 ViewGroup。</p></li><li><p>触摸事件都是先交由 Activity 的 <code>dispatchTouchEvent</code> 方法（在此之间还有一系列的操作，在此省略了），再一层层往下分发。当中间的 ViewGroup 不进行拦截时，事件会分发给最底层的 View，由 View 的 <code>onTouchEvent</code> 方法进行处理，如果事件一直未被处理，最后会返回到 Activity 的 <code>onTouchEvent</code>。</p></li><li><p>图中 View/ViewGroup 的 <code>onTouchEvent</code> 返回 false，并不是直接调用上层的 <code>onTouchEvent</code> 方法。而是上层的 <code>dispatchTouchEvent</code> 方法接收到下层的 false 返回值时，再将事件分发给自己的 <code>onTouchEvent</code> 处理。</p></li><li><p><code>onInterceptTouchEvent</code> 只存在于 ViewGroup 中。ViewGroup 是根据 <code>onInterceptTouchEvent</code> 的返回值来确定是调用子 View 的 <code>dispatchTouchEvent</code> 还是自身的 <code>onTouchEvent</code>， 并没有将调用交给 <code>onInterceptTouchEvent</code>。</p></li></ul>        <h2 id="源码分析">          <a href="#源码分析" class="heading-link"><i class="fas fa-link"></i></a>源码分析</h2>      <p>事件是从 Activity 开始分发，Activity 的 <code>dispatchTouchEvent</code> 是如何接受到触摸事件，还有一系列的前期工作，后面会单独写一篇文章总结。</p>        <h3 id="Activity-对事件的分发流程">          <a href="#Activity-对事件的分发流程" class="heading-link"><i class="fas fa-link"></i></a>Activity 对事件的分发流程</h3>              <h4 id="Activity-dispatchTouchEvent">          <a href="#Activity-dispatchTouchEvent" class="heading-link"><i class="fas fa-link"></i></a>Activity.dispatchTouchEvent</h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// 第一次按下时，用户希望与设备进行交互时，可以重写该方法实现</span></span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取PhoneWindow, 传递事件</span></span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有任何View处理事件时，交给Activity的onTouchEvent处理</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>其中 <code>getWindow</code> 返回的是 Activity 的 mWindow 成员变量，而 Window 类是一个抽象类，唯一实现类是 PhoneWindow，所以该方法获取到的是 PhoneWindow 对象。</p>        <h4 id="getWindow-superDispatchTouchEvent">          <a href="#getWindow-superDispatchTouchEvent" class="heading-link"><i class="fas fa-link"></i></a>getWindow().superDispatchTouchEvent</h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到，PhoneWindow 中直接将事件交给了 DecorView 处理，DecorView 的 <code>superDispatchTouchEvent</code> 方法如下。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>DecorView 调用的是父类的 <code>dispatchTouchEvent</code> 方法，而 DecorView 的父类是 ViewGroup，所以接着会调用 <code>ViewGroup.dispatchTouchEvent</code>。</p>        <h4 id="Activity-onTouchEvent">          <a href="#Activity-onTouchEvent" class="heading-link"><i class="fas fa-link"></i></a>Activity.onTouchEvent</h4>      <p>如果没有任何 View 处理事件，最后会交给 Activity 的 <code>onTouchEvent</code> 处理。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当窗口需要关闭时，消费掉当前事件</span></span><br><span class="line">    <span class="keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">        finish();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="ViewGroup-对事件的分发流程">          <a href="#ViewGroup-对事件的分发流程" class="heading-link"><i class="fas fa-link"></i></a>ViewGroup 对事件的分发流程</h3>              <h4 id="ViewGroup-dispatchTouchEvent">          <a href="#ViewGroup-dispatchTouchEvent" class="heading-link"><i class="fas fa-link"></i></a>ViewGroup.dispatchTouchEvent</h4>      <p>ViewGroup 的 <code>dispatchTouchEvent</code> 方法内容较多，这里拆分为检测拦截、寻找子 View、分发事件。</p><p><strong>1、 检测拦截</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测拦截</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以通过调用 requestDisallowInterceptTouchEvent,不让父 View 拦截事件</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;  <span class="comment">// 允许父 View 拦截</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);  </span><br><span class="line">        ev.setAction(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当前不是 ACTION_DOWN 事件，且没有触摸目标</span></span><br><span class="line">    <span class="comment">// 即子视图如果不消费 ACTION_DOWN，那么后续事件也不会分发到，当前父视图拦截处理</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这一段代码的目的是检测 ViewGroup 是否拦截事件。</p><p>mFirstTouchTarget 用来记录已经消费事件的子 View，目的是为了后续其他事件分发时直接将事件分发给 mFirstTouchTarget  指向的 View。</p><p><code>FLAG_DISALLOW_INTERCEPT</code> 这个标志位可以影响到 ViewGroup 是否拦截事件，可以通过调用 <code>requestDisallowInterceptTouchEvent</code> 方法来设置，一般用于子 View 当中，禁止父 View 拦截事件，处理滑动冲突。但要注意，**<code>requestDisallowInterceptTouchEvent</code> 方法对 ACTION_DOWN 事件是无效的<strong>，为什么呢？因为 **ViewGroup 的 <code>dispatchTouchEvent</code> 方法每次接收到 ACTION_DOWN 事件时，都会初始化状态</strong>。代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理一个初始按下事件 ACTION_DOWN</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// 发生 Action_DOWN 事件，取消清除之前所有的触摸目标</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    <span class="comment">// 重置触摸状态，清除 FLAG_DISALLOW_INTERCEPT；设置 mFirstTouchTarget = null</span></span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>2、寻找子 View</strong></p><p>如果 ViewGroup 没有拦截事件，事件没有被取消，并且是 ACTION_DOWN 事件时，首先会去寻找可以接收事件的子 View。代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不取消事件，同时不拦截事件, 并且是Down事件才进入该区域</span></span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    <span class="comment">// 寻找可以获取焦点的视图</span></span><br><span class="line">    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">        ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空早先的触摸对象</span></span><br><span class="line">        removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="comment">// 第一次 down 事件，同时子视图不为空时</span></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">            <span class="comment">// 从视图最上层到最下层，获取所有能接收该事件的子视图</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="comment">// 从最底层的父视图开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                    childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                    preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果子view无法获取用户焦点，跳过本次循环</span></span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                    i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 子view可见，并且没有播放动画；触摸事件的坐标落在子view的范围内</span></span><br><span class="line">                <span class="comment">// 如果这两个条件有一项不满足，则跳过此次循环</span></span><br><span class="line">                <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                newTouchTarget = getTouchTarget(child);</span><br><span class="line">                <span class="comment">// 子 view 已经接受触摸事件，将新指针id赋值给它，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                resetCancelNextUpFlag(child);</span><br><span class="line">                <span class="comment">// 如果触摸位置在子view的区域内，把事件分发给子view或者ViewGroup</span></span><br><span class="line">                <span class="comment">// 实际调用的是chlid的dispatchTouchEvent方法</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    <span class="comment">// 子view消费了事件</span></span><br><span class="line">                    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                mLastTouchDownIndex = j;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mLastTouchDownIndex = childIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mLastTouchDownX = ev.getX();</span><br><span class="line">                    mLastTouchDownY = ev.getY();</span><br><span class="line">                    <span class="comment">// 设置接收事件的子view为新的触摸目标，设置为触摸目标链表的头</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 子view处理了事件，就跳出for循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 mFirstTouchTarget 的链表最后的 TouchTarget 赋给 newToughTarget</span></span><br><span class="line">            newTouchTarget = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newTouchTarget = newTouchTarget.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>寻找子 View 进行分发事件的方法就是遍历子 View，有这样两个条件：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、子view可见，并且没有播放动画；2、触摸事件的坐标落在子view的范围内</span></span><br><span class="line"><span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这两个条件如果同时满足，则将事件分发给子 View。</p><p>接着会调用 <code>dispatchTransformedTouchEvent</code> 方法，可以猜到这个方法中肯定做了事件分发的操作。</p><p>如果这个方法返回 true，表示子 View 消费了事件，则会在 <code>addTouchTarget</code> 方法中设置 mFirstTouchTarget ，后续事件（ACTION_MOVE、ACTION_UP）分发时会直接将事件分发给 mFirstTouchTarget 指向的 View。</p><p>换句话说，如果子 View 没有消费 ACTION_DOWN 事件，mFirstTouchTarget 就会为 null，也就不会接收其他 ACTION_MOVE、ACTION_UP 等事件，如下代码：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有触摸target,则由当前ViewGroup来处理（第三个参数child为null）</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                                            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果View消费ACTION_DOWN事件，那么ACTION_MOVE、ACTION_UP等事件相继开始执行</span></span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                              target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mFirstTouchTarget = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    predecessor.next = next;</span><br><span class="line">                &#125;</span><br><span class="line">                target.recycle();</span><br><span class="line">                target = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>3、事件分发</strong></p><p><code>dispatchTransformedTouchEvent</code> 的伪代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果不存在子 View，ViewGroup 会调用父类 View 的 <code>dispatchTouchEvent</code> 方法，再调用 onTouchEvent 方法处理事件。</p><p>如果存在子 View ,将事件分发给子 View 的 <code>dispatchTouchEvent</code>，子 View 如果是 ViewGroup，则会调用 <code>ViewGroup.dispatchTouchEvent</code>，进行拦截检测、寻找子 View、分发事件操作。</p>        <h3 id="View-对事件的分发流程">          <a href="#View-对事件的分发流程" class="heading-link"><i class="fas fa-link"></i></a>View 对事件的分发流程</h3>              <h4 id="View-dispatchTouchEvent">          <a href="#View-dispatchTouchEvent" class="heading-link"><i class="fas fa-link"></i></a>View.dispatchTouchEvent</h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// 在ACION_DOWN事件之前，如果存在滚动操作则停止。不存在则不进行操作</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">// 当存在OnTouchListener，且视图状态为ENABLED时，调用onTouch方法</span></span><br><span class="line">        <span class="comment">// mOnTouchListener.onTouch优先于onTouchEvent执行</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>; <span class="comment">// 如果已经消费事件，则返回True</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果OnTouch没有消费Touch事件则调用OnTouchEvent</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123; </span><br><span class="line">            result = <span class="keyword">true</span>; <span class="comment">//如果已经消费事件，则返回True</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理取消或抬起操作</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果存在 OnTouchListener，且视图状态为 ENABLED 时，调用<code>onTouch</code> 方法，<code>onTouch</code> 方法会优先处理事件。</p><p>如果 <code>onTouch</code> 方法返回 true，表示已经消费了事件，也就不再执行 <code>onTouchEvent</code> 。否则， <code>onTouchEvent</code> 处理事件，返回 true，消费事件，否则不处理事件。</p>        <h4 id="View-onTouchEvent">          <a href="#View-onTouchEvent" class="heading-link"><i class="fas fa-link"></i></a>View.onTouchEvent</h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当View状态为DISABLED，如果可点击或可长按，则返回True，即消费事件</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当View状态为ENABLED，如果可点击或可长按，则返回True，即消费事件;</span></span><br><span class="line">    <span class="comment">//与前面的的结合，可得出结论:只要view是可点击或可长按，则消费该事件.</span></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                        focusTaken = requestFocus();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</span><br><span class="line">                        <span class="comment">//这是Tap操作，移除长按回调方法</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//调用View.OnClickListener</span></span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        postDelayed(mUnsetPressedState,</span><br><span class="line">                                ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                        mUnsetPressedState.run();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取是否处于可滚动的视图内</span></span><br><span class="line">                <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingCheckForTap.x = event.getX();</span><br><span class="line">                    mPendingCheckForTap.y = event.getY();</span><br><span class="line">                    <span class="comment">//当处于可滚动视图内，则延迟TAP_TIMEOUT，再反馈按压状态</span></span><br><span class="line">                    <span class="comment">// 用来判断用户是否想要滚动。默认延时为100ms</span></span><br><span class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当不再滚动视图内，则立刻反馈按压状态</span></span><br><span class="line">                    setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                    checkForLongClick(<span class="number">0</span>); <span class="comment">//检测是否是长按</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">                removeTapCallback();</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                drawableHotspotChanged(x, y);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        setPressed(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>只要 view 是可点击或可长按，则消费该事件。</p><p>长按事件是在 ACTION_DOWN 事件中检测，单击事件需要两个事件 ACTION_DOWN、ACTION_UP 才能触发。</p><p>与 View 相关的各个方法调用顺序应该是这样的：</p><p>onTouchListener &gt; onTouchEvent &gt; onLongClickListener &gt; onClickListener</p>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <p>结合源码和事件分发示意图，对事件分发机制总结一下：</p><p>1、事件在从 Activity 的 <code>dispatchTouchEvent</code> 往下分发，如果没有 View 消费事件，事件最后会回到 Activity 的 <code>onTouchEvent</code> 方法处理。</p><p>2、ViewGroup 可以对事件进行拦截，拦截后事件不再往子 View 分发，交由发生拦截操作的 ViewGroup 的 <code>onTouchEvent</code> 处理。</p><p>3、子 View 可以调用 <code>requestDisallowInterceptTouchEvent</code> 方法进行设置，从而阻止父 ViewGroup 的 <code>onInterceptTouchEvent</code> 拦截事件。</p><p>4、如果 View 没有消费 ACTION_DOWN 事件，则之后的 ACTION_MOVE 等事件都不会再接收。</p><p>5、只要 View 是可点击或者可长按的，则消费该事件。</p><p>6、如果当前正在处理的事件被上层拦截，会收到一个 ACTION_CANCEL，后续事件不会再传递过来。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><span class="exturl"><a class="exturl__link" href="http://gityuan.com/2015/09/19/android-touch/">Android事件分发机制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B12%5DDispatch-TouchEvent-Theory.md">事件分发机制原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 加固技术调研</title>
      <link href="2018/10/09/Android-Reinforce/"/>
      <url>2018/10/09/Android-Reinforce/</url>
      
        <content type="html"><![CDATA[        <h2 id="第一代加固">          <a href="#第一代加固" class="heading-link"><i class="fas fa-link"></i></a>第一代加固</h2>      <p>第一代加固原理是基于 Dex 加载器的加固技术。</p>        <h3 id="基本步骤">          <a href="#基本步骤" class="heading-link"><i class="fas fa-link"></i></a>基本步骤</h3>      <p>1、从 Apk 文件中获取原始的 dex 文件。</p><p>2、对原始的 dex 文件进行加密，并将加密后的 dex 文件存放在 asset 目录。</p><p>3、用脱壳 dex 文件替换原始 apk 文件的 dex 文件。脱壳  dex 文件的作用主要有两个：一是解密加密后的 dex 文件，二是动态加载解密后的 dex 文件。</p><p>4、修改清单文件，将程序入口改为壳程序。</p><p>5、打包签名。</p>        <h3 id="缺陷">          <a href="#缺陷" class="heading-link"><i class="fas fa-link"></i></a>缺陷</h3>      <p>依赖 Java 的动态加载机制，解密后的 dex 文件必须解压到文件系统，即使是应用的私有目录，攻击者很容易获取文件。</p>        <h2 id="第二代加固–不落地加载">          <a href="#第二代加固–不落地加载" class="heading-link"><i class="fas fa-link"></i></a>第二代加固–不落地加载</h2>      <p>相对于第一代加固，第二代加固在加载原始 dex 文件时采用的是内存加载方案。</p><p>即在解密原始 dex 文件后，不需要将 dex 写入文件系统，系统直接读取 dex 字节进行加载。</p><p>Android 底层支持内存加载 dex，但是 java 层未实现内存夹杂的接口，可以通过 jni 层调用底层的内存加载 dex 的函数。</p><p>市面上绝大多数第三方加固厂商的加密方案都是基于第二代加固技术。</p>        <h3 id="缺陷-1">          <a href="#缺陷-1" class="heading-link"><i class="fas fa-link"></i></a>缺陷</h3>      <p>第二代加固方案能够防止第一代加固技术文件必须落地易被复制的缺陷，但是解密后的 dex 文件加载到内存后，在内存中是连续的 ，利用 gdb 等调试工具 dump 内存后可以直接找到原始 dex。</p>        <h2 id="第三代加固–指令抽离">          <a href="#第三代加固–指令抽离" class="heading-link"><i class="fas fa-link"></i></a>第三代加固–指令抽离</h2>      <p>由于第二代加固技术仅仅对文件级别进行加密，其带来的问题是内存中的 Payload 是连续的，可以被攻击者轻易获取。第三代加固技术对这部分进行了改进，将保护级别降到了函数级别。</p>        <h3 id="基本步骤-1">          <a href="#基本步骤-1" class="heading-link"><i class="fas fa-link"></i></a>基本步骤</h3>      <p>1、打包阶段将 Dex 文件中要保护的核心函数抽离出来生成另外一个文件。</p><p>2、运行阶段将函数内容重新恢复到对应的函数体。恢复的时间点有如下几种方式。</p><ul><li>加载之后恢复函数内容到 dex 壳所在的内存区域</li><li>加载之后将函数内容恢复到虚拟机内部的结构体上：虚拟机读取 dex 文件后内部对每一个函数有一个结构体，这个结构体上有一个指针指向函数内容，可以通过修改这个指针修改对应的函数内容。</li><li>拦截虚拟机与查找执行代码相关的函数，返回函数内容。</li></ul>        <h3 id="缺陷-2">          <a href="#缺陷-2" class="heading-link"><i class="fas fa-link"></i></a>缺陷</h3>      <p>攻击者可以通过自定义 Android 虚拟机，在解释器的代码上做记录一个函数的内容。接下来遍历所有函数，从而获取全部的函数内容。最终重组成一个完整的 dex 文件。</p>        <h2 id="第四代加固–指令转换-VMP">          <a href="#第四代加固–指令转换-VMP" class="heading-link"><i class="fas fa-link"></i></a>第四代加固–指令转换/VMP</h2>      <p>第三代加固技术是函数级别的保护，使用 Android 虚拟机内的解释器执行代码，带来可能被记录的缺陷。</p><p>第四代加固技术使用自己的解释器来避免第三代的缺陷。</p><p>在编译打包的时候将 dex 的核心函数抽离，抽离后，翻译成一种自己定义的指令，用自己的一种编译指令进行翻译，把这个指令变一个种，变成其他的指令，这个时候运行的时候通过自己的解释器来解释执行，是自己定义的相关指令。在内存中运行的指令，在某些保护的函数里面就一定不是谷歌的标准指令了，这点能够很有效的防止内存直接拷贝等破解方案。</p>        <h3 id="缺陷-3">          <a href="#缺陷-3" class="heading-link"><i class="fas fa-link"></i></a>缺陷</h3>      <p>其必须通过虚拟机提供的JNI接口与虚拟机进行交互，攻击者可以直接将指令转换/VMP 加固方案当作黑盒，通过自定义的 JNI 接口对象，对黑盒内部进行探测、记录和分析，进而得到完整 dex程序。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <p><span class="exturl"><a class="exturl__link" href="https://juejin.im/entry/5a16915e51882575d144a692">APP加固技术历程及未来级别方案：虚机源码保护</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 加固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《刷新》书摘</title>
      <link href="2018/10/06/hit-refresh/"/>
      <url>2018/10/06/hit-refresh/</url>
      
        <content type="html"><![CDATA[<p>1、</p><p>在首堂正念训练课上，热尔韦博士问我们是否愿意先尝试一次特别的个人体验，大家全都点头表示同意。然后他要求我们中一人站出来当志愿者。结果没有人站出来，一时间房间里非常安静，气氛也非常尴尬。然后，我们的首席财务官埃米·胡德站了出来，她被要求背诵字母表，而且每个字母后面都要加入一个数字，即A1B2C3……让热尔韦博士感到奇怪的是：为什么不是每个人都站出来呢？这是一个高绩效团队吗？不是刚才每个人都说要尝试一下特别的体验吗？由于没有手机也没有电脑可看，所以我们低头看自己的鞋子，或看着同事紧张地微笑。这些问题的答案着实让人难以说出口，虽然它们就在嘴边。或是出于担心：担心被嘲笑，担心失败，担心被认为不是这个屋子里最聪明的人。或是出于傲慢：我的位置太重要了，不屑于玩这种游戏。“这是多么愚蠢的问题”，我们习惯于倾听。</p><p>2、</p><p>我们花太多的时间在工作上，所以工作应该有更深刻的意义。如果我们能够把个人的相信的价值与公司的长处结合起来，那么我们几乎就可以攻无不克了。</p><p>3、</p><p>只有经历过人生起伏，才能培养起同理心；要想不受苦受难，或者少受苦受难，就必须接纳无常。</p><p>4、</p><p>每一个人、每一个组织乃至每一个社会，在到达某一个点时，都应点击刷新——重新注入活力、重新激发生命力、重新组织并重新思考自己存在的意义。</p><p>5、</p><p>人要依照自己的意愿去做事，并遵循自己的节奏。当你依照自己的意愿做事时，节奏就上来了。只要是你喜欢的事，用心去做，把它做好，而且保持正当的目标，生活就不会辜负你。</p><p>6、</p><p>我再一次在对的时间出现在了对的地方。</p><p>7、</p><p>第一个原则是不遗余力地进行竞争，在面对不确定性和威胁时要充满激情。</p><p>第二个原则是要把团队放在优于个人地位和个人荣誉的位置上。</p><p>第三个原则是领导力的重要性。</p><p>8、</p><p>领导意味着做选择，然后将团队团结在这些选择周围。</p><p>9、</p><p>对领导而言，通过命令达成的共识并不是真正的共识。任何机构建设都源于清晰的、既能自上而下也能自下而上推动进步的愿景与文化。</p><p>10、</p><p>技术无非就是那些开发它的人的共同灵魂。</p><p>11、</p><p>史蒂夫·乔布斯（Steve Jobs）懂得什么是公司的灵魂。他曾经说过：“人类创作最根本的灵魂就是设计，而这个灵魂最终通过产品或服务的外在连续表现出来。”我同意他的观点。只要它内心的声音、动机是设计伟大的消费产品，那么苹果就会一直忠于它的灵魂。</p><p>12、</p><p>我们每天都要问一问自己：今天我在哪些方面保持着固化型思维？在哪些方面保持着成长型思维？</p><p>13、</p><p>抗拒变革的根本原因是对未知的恐惧。</p><p>14、</p><p>如果高层管理者都拿不出时间来发掘员工潜力，那么大多数公司团队成员的成长路径将会是静态的。</p><p>15、</p><p>各公司积极推动转型，确保自身的相关性和竞争力。而我们希望微软能够成为它们的合作伙伴。在这方面，每家公司都必须优先考虑四个方面。第一，利用数据提升客户体验，密切客户沟通。第二，在新的数字工作世界中，通过支持更大规模的、更多的移动生产力和移动协作，予力赋能员工。第三，优化运营，在销售、运营和财务等方面简化业务流程，并推动自动化。第四，转型产品模式、服务模式和业务模式。</p><p>16、</p><p>言论自由、隐私、安全和主权是永恒的、不容置疑的价值观。</p><p>17、</p><p>狂热支持一种或另一种价值观很容易，但这并不代表它就是对的。</p><p>18、</p><p>信任就像手里握着一只小鸟。握得太紧，会伤到小鸟；握得太松，小鸟就飞走了。</p><p>19、</p><p>预测未来的最好方法就是创造未来。</p><p>20、</p><p>多么不平等，经济学家们使用了意大利经济学家科拉多·基尼（CorradoGini）的一项研究成果。他在1912年发表了一个公式，可以用于计算如今被人称作“基尼系数”的指标，用于衡量一个社会的收入分配状况与绝对平等的收入分配状况之间存在多大差距。计算方法很简单。在特定人群中，如果100%的人都能每天赚1美元，那就是绝对平等。如果100%的人年收入达到100万美元，那也是绝对平等。但如果只有1%的人赚到100万美元，而其他人赚不到钱，那就接近绝对不平等。基尼的研究提供了一种方法，让我们可以衡量一个特定社会的收入分配接近或偏离绝对平等的程度。</p><p>21、</p><p>特定人群的基尼系数通常表示为分数。绝对平等表示为0，绝对不平等表示为1。在现实世界中，任何一个国家或地区的基尼系数都以这两个极端值之间的分数来表达。德国等欧洲发达国家的基尼系数几十年来一直徘徊在0.3左右。而美国的基尼系数已经上升了好几年，现在与中国和墨西哥差不多，都超过了0.4。</p><p>22、</p><p>Σ（教育+创新）×科技使用强度=经济增长</p><p>教育加创新，广泛应用于整个经济，尤其是那些具备比较优势的国家或地区，再乘以科技使用强度，久而久之，就会产生经济增长和生产力。</p><p>23、</p><p>“我为什么存在？”</p><p>“我们的机构为什么存在？”“跨国公司在这个世界上的角色是什么？”</p><p>“数字技术领导者的角色是什么，特别是在当今世界把科技作为推动增长的一个关键因素的时候？”</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射基础</title>
      <link href="2018/09/13/java-reflection/"/>
      <url>2018/09/13/java-reflection/</url>
      
        <content type="html"><![CDATA[<p>最近在调研 Android 应用加固方案，涉及大量反射技术，因此趁这个机会总结下 Java 反射的一些知识。</p>        <h2 id="什么是反射？">          <a href="#什么是反射？" class="heading-link"><i class="fas fa-link"></i></a>什么是反射？</h2>      <p>反射是 Java 语言提供的一种基本功能。通过反射我们可以在运行时动态地操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造函数，甚至可以在运行时修改类定义。</p>        <h2 id="基本使用方法">          <a href="#基本使用方法" class="heading-link"><i class="fas fa-link"></i></a>基本使用方法</h2>      <p>反射的主要步骤包括：</p><ul><li>获取目标类型的 Class 对象</li><li>通过 Class 对象分别获取 Constructor 类对象、Method 类对象 和 Field 类对象。</li><li>通过 Constructor 、Method 和 Field 分别获取目标类的构造函数、方法和属性的具体信息，并进行后续操作。</li></ul>        <h3 id="获取目标类型的-Class-对象">          <a href="#获取目标类型的-Class-对象" class="heading-link"><i class="fas fa-link"></i></a>获取目标类型的 Class 对象</h3>      <p><strong>1、Object.getClass()</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Class&lt;?&gt; classType = stringBuilder.getClass();</span><br><span class="line">System.out.println(classType);   <span class="comment">// class java.lang.StringBuilder</span></span><br></pre></td></tr></table></div></figure><p><strong>2、T.class</strong> </p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = <span class="keyword">int</span>.class;</span><br><span class="line">System.out.println(classType);   <span class="comment">// int</span></span><br></pre></td></tr></table></div></figure><p>T 代表任意 Java 类型。</p><p><strong>3、Class.forName()</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    classType = Class.forName(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(classType);   <span class="comment">// class java.lang.Integer</span></span><br></pre></td></tr></table></div></figure>        <h3 id="通过-Class-对象分别获取-Constructor-类对象、Method-类对象-和-Field-类对象">          <a href="#通过-Class-对象分别获取-Constructor-类对象、Method-类对象-和-Field-类对象" class="heading-link"><i class="fas fa-link"></i></a>通过 Class 对象分别获取 Constructor 类对象、Method 类对象 和 Field 类对象</h3>      <p><strong>1、获取 Constructor 类对象</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a. 获取指定的构造函数 （公共 / 继承）</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"><span class="comment">// b. 获取所有的构造函数（公共 / 继承） </span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// c. 获取指定的构造函数 （不包括继承）</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// d. 获取所有的构造函数（不包括继承）</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></div></figure><p><strong>2、获取 Method 类对象</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a. 获取指定的方法（公共 / 继承）</span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> ；</span></span><br><span class="line"><span class="function"><span class="comment">// b. 获取所有的方法（公共 / 继承）</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> ；</span></span><br><span class="line"><span class="function"><span class="comment">// c. 获取指定的方法 （ 不包括继承）</span></span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> ；</span></span><br><span class="line"><span class="function"><span class="comment">// d. 获取所有的方法（ 不包括继承）</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> ；</span></span><br></pre></td></tr></table></div></figure><p><strong>3、获取 Field 类对象</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a. 获取指定的属性（公共 / 继承）</span></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> </span>;</span><br><span class="line"><span class="comment">// b. 获取所有的属性（公共 / 继承）</span></span><br><span class="line">Field[] getFields() ;</span><br><span class="line"><span class="comment">// c. 获取指定的所有属性 （不包括继承）</span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> ；</span></span><br><span class="line"><span class="function"><span class="comment">// d. 获取所有的所有属性 （不包括继承）</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span> ；</span></span><br></pre></td></tr></table></div></figure><p>以上方法中，不带 “Declared” 的方法返回某个类的公共方法或属性，继承的方法或属性；带 “Declared” 的方法返回公共、保护、默认（包）访问和私有方法或属性，但不包括继承的方法或属性。</p>        <h3 id="通过-Constructor-、Method-和-Field-分别获取目标类的构造函数、方法和属性的具体信息，并进行后续操作">          <a href="#通过-Constructor-、Method-和-Field-分别获取目标类的构造函数、方法和属性的具体信息，并进行后续操作" class="heading-link"><i class="fas fa-link"></i></a>通过 Constructor 、Method 和 Field 分别获取目标类的构造函数、方法和属性的具体信息，并进行后续操作</h3>      <p><strong>1、利用反射调用类的构造函数</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 ConstructorClass 类的 Class 对象</span></span><br><span class="line">Class clazz = ConstructorClass.class;</span><br><span class="line">Object obj1 = clazz.getConstructor().newInstance(); <span class="comment">// 输出：无参数构造函数</span></span><br><span class="line">Object obj2 = clazz.getConstructor(String.class).newInstance(&quot;wuzy&quot;); // 输出：有参数构造函数</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstructorClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>newInstance() 调用默认构造函数，若目标类无构造函数，则抛出异常 NoSuchMethodException。</p><p><strong>2、利用反射调用类对象的方法</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取 MethodClass 类的 Class 对象</span></span><br><span class="line">Class&lt;?&gt; clazz = MethodClass.class;</span><br><span class="line"><span class="comment">// 2、通过 Class 创建 MethodClass 对象</span></span><br><span class="line">Object object = clazz.newInstance();</span><br><span class="line"><span class="comment">// 3、通过 Class 对象获取 add 方法</span></span><br><span class="line">Method method = clazz.getMethod(<span class="string">&quot;add&quot;</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 4、通过 Method 调用 add 方法</span></span><br><span class="line">Object result = method.invoke(object,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(result);   <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>3、利用反射获取类的属性</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = FieldClass.class;</span><br><span class="line">Object object = clazz.newInstance();</span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(object, <span class="string">&quot;wuzy&quot;</span>);</span><br><span class="line">System.out.println(field.get(object));   <span class="comment">// 输出： wuzy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FieldClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>其中， setAccessible 用于屏蔽 Java 语言的访问检查，设为 true 可以访问类的私有属性、方法。</p>        <h2 id="反射的使用场景">          <a href="#反射的使用场景" class="heading-link"><i class="fas fa-link"></i></a>反射的使用场景</h2>      <p>1、工厂模式：Factory 类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类 Factory 了</p><p>2、数据库 JDBC 中通过 Class.forName(Driver) 来获得数据库连接驱动</p><p>3、访问一些不能访问的变量或属性：破解别人代码。</p><p>4、实现动态代理。</p><p>以上就是反射的基本知识点，需要注意的是由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。通过反射实现动态代理和工厂模式会在后续文章中专门撰写。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuilder 和 StringBuffer</title>
      <link href="2018/09/09/String-StringBuffer-StringBuilder/"/>
      <url>2018/09/09/String-StringBuffer-StringBuilder/</url>
      
        <content type="html"><![CDATA[<p>在之前的文章 <a href="http://wuzhangyang.com/2018/09/01/why-string-is-immutable/">Java 中 String 类为什么要设计成不可变的？</a> 中对 String 的特性已经作了总结。这篇文章主要介绍另外两个常用的类 StringBuilder 和 StringBuffer 的特性。</p><p>我们知道 String 是不可变的 (Immutable)，字符串的操作会产生新对象，消耗内存。为此，JDK 提供了 StringBuffer 和 StringBuilder 两个类。</p><p>StringBuffer 和 StringBuilder 都实现了 AbstractStringBuilder 抽象类，拥有几乎一致对外提供的接口；它们底层在内存中的存储方式与 String 相同， 都是以一个有序的字符序列进行存储，不同点在于 StringBuffer 和 StringBuilder 对象的值是可以改变的，并且值改变以后，对象的引用不会发生改变。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>两者对象在构造时初始字符串长度为16，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组，比较消耗内存。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先估计指定大小，可以提升性能。</p><p><strong>两者之间的不同点在于： StringBuffer 是线程安全的，StringBuilder 是线程不安全的 。</strong>其中，StringBuffer 的线程安全是通过在 <strong>synchronize</strong> 关键字实现，为此，StringBuffer 的性能远低于 StringBuilder。</p><p>在无线程安全问题的情况下，字符串拼接操作有以下两种写法，到底哪一种写法更合理呢？</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;bb&quot;</span>).append(<span class="string">&quot;cc&quot;</span>).append(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">String myStr = <span class="string">&quot;aa&quot;</span> + <span class="string">&quot;bb&quot;</span> + <span class="string">&quot;cc&quot;</span> + <span class="string">&quot;dd&quot;</span>;</span><br></pre></td></tr></table></div></figure><p>做个实验，对以下代码进行反编译。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String myStr = <span class="string">&quot;aa&quot;</span> + <span class="string">&quot;bb&quot;</span> + <span class="string">&quot;cc&quot;</span> + <span class="string">&quot;dd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;myStr:&quot;</span> + myStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用 JDK 8 先编译再反编译：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">javap -v Main.class</span><br></pre></td></tr></table></div></figure><p>输出片段为：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2         // String aabbccdd</span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line">3: getstatic     #3         // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">6: new           #4         // class java/lang/StringBuilder</span><br><span class="line"><span class="number">9</span>: dup</span><br><span class="line">10: invokespecial #5        // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">13: ldc           #6        // String myStr:</span><br><span class="line">15: invokevirtual #7        // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line"><span class="number">18</span>: aload_1</span><br><span class="line">19: invokevirtual #7        // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">22: invokevirtual #8        // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">25: invokevirtual #9        // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"><span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></div></figure><p>可以看出来，字符串拼接操作会自动被 javac 转化为 StringBuilder 操作，这是 Java 内部作出的优化。所以在普通清况下，不用过分纠结字符串拼接一定要使用 StringBuilder 实现，毕竟其写法可读性差，需要敲更多代码。</p><p>最后简单总结下各自的<strong>应用场景</strong>：</p><p>1、在字符串内容不经常发生变化的业务场景优先使用 String 类。</p><p>2、在频繁进行字符串的操作，并且需要考虑线程安全的情况下，建议使用 StringBuffer。</p><p>3、在频繁进行字符串的操作，无需考虑线程安全的情况下，建议使用 StringBuilder。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中 String 类为什么要设计成不可变的？</title>
      <link href="2018/09/01/why-string-is-immutable/"/>
      <url>2018/09/01/why-string-is-immutable/</url>
      
        <content type="html"><![CDATA[<p>String 是 Java 中不可变的类，所以一旦被实例化就无法修改。不可变类的实例一旦创建，其成员变量的值就不能被修改。本文总结下 String 类设计成不可变的原因及好处，以及 String 类是如何设计成不可变的。</p>        <h2 id="String-类设计成不可变的原因及好处？">          <a href="#String-类设计成不可变的原因及好处？" class="heading-link"><i class="fas fa-link"></i></a>String 类设计成不可变的原因及好处？</h2>      <p>其实好处就是原因，String 设计成不可变，主要是从性能和安全两方面考虑。</p>        <h4 id="1、常量池的需要">          <a href="#1、常量池的需要" class="heading-link"><i class="fas fa-link"></i></a>1、常量池的需要</h4>      <p>这个方面很好理解，Java 中的字符串常量池的存在就是为了性能优化。</p><p>字符串常量池（String pool）是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串已经存在于常量池中，则不会创建新的对象，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p><p>比如引用 s1和 s2 都是指向常量池的同一个对象 “abc”，如果 String 是可变类，引用 s1 对 String 对象的修改，会直接导致引用 s2 获取错误的值。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></div></figure><p><img src="/2018/09/01/why-string-is-immutable/string.png" alt="string"></p><p>所以，如果字符串是可变的，那么常量池就没有存在的意义了。</p>        <h4 id="2、hashcode-缓存的需要">          <a href="#2、hashcode-缓存的需要" class="heading-link"><i class="fas fa-link"></i></a>2、hashcode 缓存的需要</h4>      <p>因为字符串不可变，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就使得字符串很适合作为 HashMap 中的 key，效率大大提高。</p>        <h4 id="3、多线程安全">          <a href="#3、多线程安全" class="heading-link"><i class="fas fa-link"></i></a>3、多线程安全</h4>      <p>多线程中，可变对象的值很可能被其他线程改变，造成不可预期的结果。而不可变的 String 可以自由在多个线程之间共享，不需要同步处理。</p>        <h2 id="String-类是如何实现不可变的？">          <a href="#String-类是如何实现不可变的？" class="heading-link"><i class="fas fa-link"></i></a>String 类是如何实现不可变的？</h2>              <h4 id="1、私有成员变量">          <a href="#1、私有成员变量" class="heading-link"><i class="fas fa-link"></i></a>1、私有成员变量</h4>      <p>String 的内部很简单，有两个私有成员变量</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></div></figure><p>而并没有对外提供可以修改这两个属性的方法。</p>        <h4 id="2、Public-的方法都是复制一份数据">          <a href="#2、Public-的方法都是复制一份数据" class="heading-link"><i class="fas fa-link"></i></a>2、Public 的方法都是复制一份数据</h4>      <p>String 有很多 public 方法，每个方法都将创建新的 String 对象，比如 substring 方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3、String-是-final-的">          <a href="#3、String-是-final-的" class="heading-link"><i class="fas fa-link"></i></a>3、String 是 final 的</h4>      <p>String 被 final 修饰，因此我们不可以继承 String，因此就不能通过继承来重写一些方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="4、构造函数深拷贝">          <a href="#4、构造函数深拷贝" class="heading-link"><i class="fas fa-link"></i></a>4、构造函数深拷贝</h4>      <p>当传入可变数组 value[] 时，进行 copy 而不是直接将 value[] 复制给内部变量。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从 String 类的设计方式，我们可以总结出实现不可变类的方法：</p><ul><li>将 class 自身声明为 final，这样别人就不能通过扩展来绕过限制了。</li><li>将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。</li><li>通过构造对象时，成员变量使用深拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</li><li>如果确实需要 getter 方法，或者其他可能返回内部状态的方法，使用 copy-on-write 原则，创建私有的 copy。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android RxJava + Retrofit + Dagger2 + MVP</title>
      <link href="2018/08/05/Android-resource-library/"/>
      <url>2018/08/05/Android-resource-library/</url>
      
        <content type="html"><![CDATA[<p>如何即快速掌握 Android RxJava + Retrofit + Dagger2 + MVP，以下是个人认为值得学习的开源项目、库以及技术教程，以下两个项目基本涵盖了当前 Android 开发中常用的主流技术框架，适合没有项目经验的同学，能够帮助你快速提高项目开发能力、掌握前沿技术。</p>        <h3 id="值得学习的项目">          <a href="#值得学习的项目" class="heading-link"><i class="fas fa-link"></i></a>值得学习的项目</h3>      <ul><li><span class="exturl"><a class="exturl__link" href="https://github.com/JsonChao/Awesome-WanAndroid">Awesome-WanAndroid</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ：基于Material Design + MVP + Rxjava2 + Retrofit + Dagger2 + GreenDao + Glide ，一款极致体验的 WanAndroid 客户端。</li><li><span class="exturl"><a class="exturl__link" href="https://github.com/Will-Ls/WeiYue/">WeiYue</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ：微阅是一款使用 MVP + Retrofit2 + Rxjava + dagger2 等框架开发的阅读软件。包括新闻、视频等。</li></ul>        <h3 id="RxJava-教程">          <a href="#RxJava-教程" class="heading-link"><i class="fas fa-link"></i></a>RxJava 教程</h3>      <ul><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/464fa025229e">给初学者的RxJava2.0教程(一)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/8818b98c44e2">给初学者的RxJava2.0教程(二)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/128e662906af">给初学者的RxJava2.0教程(三)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/bb58571cdb64">给初学者的RxJava2.0教程(四)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/0f2d6c2387c9">给初学者的RxJava2.0教程(五)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/e4c6d7989356">给初学者的RxJava2.0教程(六)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/9b1304435564">给初学者的RxJava2.0教程(七)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/a75ecf461e02">给初学者的RxJava2.0教程(八)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/36e0f7f43a51">给初学者的RxJava2.0教程(九)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/d6552d020307">给初学者的RxJava2.0教程(十)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>        <h3 id="Retrofit-教程">          <a href="#Retrofit-教程" class="heading-link"><i class="fas fa-link"></i></a>Retrofit 教程</h3>      <ul><li><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/carson_ho/article/details/73732076">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>        <h3 id="Dagger2-教程">          <a href="#Dagger2-教程" class="heading-link"><i class="fas fa-link"></i></a>Dagger2 教程</h3>      <ul><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/cd2c1c9f68d4">Android：dagger2让你爱不释手-基础依赖注入框架篇</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/1d42d2e6f4a5">Android：dagger2让你爱不释手-重点概念讲解、融合篇</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/65737ac39c44">Android：dagger2让你爱不释手-终结篇</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://blog.xujiaji.com/post/learn-dagger">Dagger2 的深入分析与使用</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>        <h3 id="优秀的开源库">          <a href="#优秀的开源库" class="heading-link"><i class="fas fa-link"></i></a>优秀的开源库</h3>      <ul><li><span class="exturl"><a class="exturl__link" href="https://github.com/scwang90/SmartRefreshLayout">SmartRefreshLayout</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper">BaseRecyclerViewAdapterHelper</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://github.com/YoKeyword/Fragmentation">Fragmentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://github.com/Justson/AgentWeb">AgentWeb</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://github.com/H07000223/FlycoTabLayout">FlycoTabLayout</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android APK 签名原理</title>
      <link href="2018/07/10/Android-APK-signature-principle/"/>
      <url>2018/07/10/Android-APK-signature-principle/</url>
      
        <content type="html"><![CDATA[<p>Android APK 签名原理涉及到密码学的加密算法、数字签名、数字证书等基础知识，这里做个总结记录。</p>        <h3 id="非对称加密">          <a href="#非对称加密" class="heading-link"><i class="fas fa-link"></i></a>非对称加密</h3>      <p>需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。</p><p>其相对的加密即为对称加密，可以用现实世界中的例子来对比：一个传统保管箱，开门和关门都是使用同一条钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有邮箱主人拥有钥匙可以打开邮箱，这就视为私钥。</p>        <h3 id="消息摘要算法">          <a href="#消息摘要算法" class="heading-link"><i class="fas fa-link"></i></a>消息摘要算法</h3>      <p>一种能产生特殊输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，被提取出的信息就被称作原始数据的消息摘要。著名的摘要算法有 RSA 公司的 MD5 算法和 SHA-1 算法及其大量的变体。</p><p>消息摘要算法的主要特点：</p><ul><li>变长输入，定长输出。即不管输入多长，输出永远是相同的长度。</li><li>输入不同，输出不同。输入相同，输出相同。</li><li>单向、不可逆。即只能进行正向的消息摘要，而无法从摘要中恢复出任何的原始消息 。</li></ul><p>消息摘要的作用：保证了消息的完整性。如果发送者发送的信息在传递过程中被篡改，那么接受者收到信息后，用同样的摘要算法计算其摘要，如果新摘要与发送者原始摘要不同，那么接收者就知道消息被篡改了。</p>        <h3 id="数字签名">          <a href="#数字签名" class="heading-link"><i class="fas fa-link"></i></a>数字签名</h3>      <p>数字签名是对非对称加密和消息摘要技术的具体应用。其目的就是确保消息来源的可靠性。</p><p>消息发送者生成一对公私钥对，将公钥给消息的接收者。如果发送者要发送信息给接收者，会进行如下三步操作：</p><ul><li>通过消息摘要算法提取消息摘要。</li><li>使用私钥，对这个摘要加密，生成数字签名。</li><li>将原始信息和数字签名一并发给接收者。</li></ul><p>接收者在收到信息后通过如下两步验证消息来源的真伪。</p><ul><li>使用公钥对数字签名进行解密，得到消息的摘要，由此可以确定信息是又发送者发来的。</li><li>对原始信息提取消息摘要，与解密得到的摘要对比，如果一致，说明消息在传递的过程中没有被篡改。</li></ul><p>以上的数字签名方法的前提是，接收者必须要事先得到正确的公钥。如果一开始公钥就被别人篡改了，那坏人就会被你当成好人，而真正的消息发送者给你发的消息会被你视作无效的。如何保证公钥的安全性？这就需要数字证书来解决。</p>        <h3 id="数字证书">          <a href="#数字证书" class="heading-link"><i class="fas fa-link"></i></a>数字证书</h3>      <p>发送者的公钥的安全合法性需要一个公钥做认证，而这个公钥的合法性又该如何保证？这个问题可以无限循环下去，无法到头了。所以需要一个可信的机构来提供公钥，这种机构称为认证机构 (Certification Authority， CA)。CA 就是能够认定”公钥确实属于此人”，并能生成公钥的数字签名的组织或机构。 </p><p>CA 用自己的私钥，对发送者的公钥和一些相关信息一起加密，生成”数字证书”。发送者在签名的时候，带上数字证书发送给接收者。接收者用 CA 的公钥解开数字证书，就可以拿到发送者真实的公钥了，然后就能证明”数字签名”是否来源真实。</p><p>对于数字签名和数字证书，可以查看阮一峰老师的文章《 <span class="exturl"><a class="exturl__link" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>》，讲得很简单易懂。</p>        <h3 id="Android-APK-签名流程">          <a href="#Android-APK-签名流程" class="heading-link"><i class="fas fa-link"></i></a>Android APK 签名流程</h3>      <p>为了防止 APK 在传送的过程中被第三方篡改，Google 引入了签名机制。</p><p>签过名的 APK 文件比未签名的 APK 文件多了一个 META-AF 文件夹，包含以下三个文件。签名的信息就在这三个文件中。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MANIFEST.MF</span><br><span class="line">CERT.RSA</span><br><span class="line">CERT.SF</span><br></pre></td></tr></table></div></figure><p>APK 的签名主要有以下几个流程：</p><p>1、对 APK 文件夹中的文件逐一遍历进行 SHA1 （或者 SHA256）算法计算文件的消息摘要，然后进行 BASE64 编码后，作为 “SHA1-Digest” 属性的值写入到 MANIFEST.MF 文件中的一个块中。该块有一个 “Name” 属性，其值就是该文件在 APK 包中的路径。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Built-By: Generated-by-ADT</span><br><span class="line">Created-By: Android Gradle <span class="number">3.1</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml</span><br><span class="line">SHA1-Digest: <span class="number">9</span>hTSmRfzHEeQc7V2wxBbTT3DmCY=</span><br><span class="line"></span><br><span class="line">Name: META-INF/android.arch.core_runtime.version</span><br><span class="line">SHA1-Digest: BeF7ZGqBckDCBhhvlPj0xwl01dw=</span><br><span class="line"></span><br><span class="line">Name: META-INF/android.arch.lifecycle_livedata-core.version</span><br><span class="line">SHA1-Digest: BeF7ZGqBckDCBhhvlPj0xwl01dw=</span><br></pre></td></tr></table></div></figure><p>2、计算这个 MANIFEST.MF 文件的整体 SHA1 值，再经过 BASE64 编码后，记录在 CERT.SF 主属性块（在文件头上）的 “SHA1-Digest-Manifest” 属性值值下。然后，再逐条计算 MANIFEST.MF 文件中每一个块的 SHA1，并经过 BASE64 编码后，记录在 CERT.SF 中的同名块中，属性的名字是 “SHA1-Digest” 。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Signature-Version: <span class="number">1.0</span></span><br><span class="line">Created-By: <span class="number">1.0</span> (Android)</span><br><span class="line">SHA1-Digest-Manifest: MJQyZ0dc4dv7G9nlJPAMQLwEwbU=</span><br><span class="line">X-Android-APK-Signed: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml</span><br><span class="line">SHA1-Digest: IJioMmfD693T4qnUJcPKhq9woHQ=</span><br><span class="line"></span><br><span class="line">Name: META-INF/android.arch.core_runtime.version</span><br><span class="line">SHA1-Digest: OPQCkzMXJVPQryHeMowVNZmfRMw=</span><br><span class="line"></span><br><span class="line">Name: META-INF/android.arch.lifecycle_livedata-core.version</span><br><span class="line">SHA1-Digest: TSBGEIW1zN2n2sraHWcuRYSO8JU=</span><br></pre></td></tr></table></div></figure><p>3、把之前生成的 CERT.SF 文件， 用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入  CERT.RSA  中保存。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3082</span> <span class="number">02f</span>9 <span class="number">060</span>9 <span class="number">2</span>a86 <span class="number">4886</span> f70d <span class="number">0107</span> <span class="number">02</span>a0</span><br><span class="line"><span class="number">8202</span> ea30 <span class="number">8202</span> e602 <span class="number">0101</span> <span class="number">310</span>b <span class="number">3009</span> <span class="number">0605</span></span><br><span class="line"><span class="number">2</span>b0e <span class="number">0302</span> <span class="number">1</span>a05 <span class="number">0030</span> <span class="number">0b0</span>6 <span class="number">092</span>a <span class="number">8648</span> <span class="number">86f</span>7</span><br><span class="line"><span class="number">0d</span>01 <span class="number">0701</span> a082 <span class="number">01</span>e1 <span class="number">3082</span> <span class="number">01d</span>d <span class="number">3082</span> <span class="number">0146</span></span><br><span class="line"><span class="number">0201</span> <span class="number">0130</span> <span class="number">0d</span>06 <span class="number">092</span>a <span class="number">8648</span> <span class="number">86f</span>7 <span class="number">0d</span>01 <span class="number">0105</span></span><br><span class="line"><span class="number">0500</span> <span class="number">3037</span> <span class="number">3116</span> <span class="number">3014</span> <span class="number">0603</span> <span class="number">5504</span> <span class="number">030</span>c <span class="number">0d</span>41</span><br><span class="line"><span class="number">6e64</span> <span class="number">726f</span> <span class="number">6964</span> <span class="number">2044</span> <span class="number">6562</span> <span class="number">7567</span> <span class="number">3110</span> <span class="number">300</span>e</span><br><span class="line"><span class="number">0603</span> <span class="number">5504</span> <span class="number">0</span>a0c <span class="number">0741</span> <span class="number">6e64</span> <span class="number">726f</span> <span class="number">6964</span> <span class="number">310</span>b</span><br><span class="line"><span class="number">3009</span> <span class="number">0603</span> <span class="number">5504</span> <span class="number">0613</span> <span class="number">0255</span> <span class="number">5330</span> <span class="number">1e17</span> <span class="number">0d</span>31</span><br></pre></td></tr></table></div></figure>        <h3 id="签名校验">          <a href="#签名校验" class="heading-link"><i class="fas fa-link"></i></a>签名校验</h3>      <p>1、完整性校验</p><p>如果 APK 中文件被修改，对应 MANIFEST.MF 中的 SHA1 会发生改变。</p><p>2、APK 作者身份唯一性校验</p><p>当在 Android 设备上安装  APK 包时，会从存放在 CERT.RSA 中的公钥证书中提取公钥，进行 RSA 解密来校验安装包的身份。 使用不同的 key 生成的签名信息会不同，不同的私钥对应不同的公钥，因此最大的区别是签名证书中存放的公钥会不同，所以我们可以通过提取 CERT.RSA 中的公钥来检查安装包是否被重新签名了。 </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在工作一周年</title>
      <link href="2018/07/07/written-on-the-first-anniversary-of-work/"/>
      <url>2018/07/07/written-on-the-first-anniversary-of-work/</url>
      
        <content type="html"><![CDATA[<p>早上收到了公司发来的祝福邮件，祝福入职工作一周年。</p><p>这一年里，经历了一些事，遇见了一些人，有一些所思所想，这里做个总结吧。</p><p>关于工作。                               </p><p>技术方面，相比于学生时代，还是有了很大提升，也逐渐能在公司站住脚。虽然说技术不是全部，但对于目前这个阶段，技术还是核心竞争力。首先感谢一下我的导师吧，他是一个性格很好的人，也很有耐心，对我技术及思维提升上给了很大的帮助。然后也要感谢自己，感谢自己对技术还是感兴趣的，还能继续坚持学习下去，毕竟这是我目前唯一的谋生技能。我生性内敛，很多时候不够主动，所以这一年也没得到比较好的机会，表现平平，这也是我需要改变的一个方面。</p><p>关于生活。</p><p>生活方面，感触最深的就是自己逐渐成为顶梁柱，这个过程压力还是挺大的。父母亲逐渐在变老，我最关心的是他们的健康问题，一辈子劳累的工作欠下了很多健康债。要是他们身体有了大问题，对于这样普通的家庭，经济负担是完全会压垮整个家庭的。所以逐渐得给他们买些商业保险，希望能对冲一些风险。父母的健康可能是我后面生活最大的牵挂。对于未婚妻，说实话是有歉意的。我们从 20 岁就开始谈恋爱了，到现在工作一周年，好像我也没给她什么，物质上给不了多少，还经常性地加班，陪伴比以前更少了，她自然也能理解，为了在这个城市生活下去，家境平平的我们都得加倍努力才行。</p><p>关于得。</p><p>其实经济上面也没得到啥改善，倒是个人思维认知有了很大的提升。能透过一些人和事看清背后的本质。也不会刻意去跟别人攀比，因为我发现攀比并没有什么卵用，别人再牛逼跟我也没有什么关系，有这样的攀比心理反而会影响自己的节奏，不利于目标的达成。所以还是得珍惜所拥有的，朝着目标不断努力。</p><p>关于失。</p><p>没有什么大失吧，就算是有，说明是我没能力得到，那些也暂时不属于我。唯有提升自己，能力越大，机会越多，得到的也会更多。</p><p>关于未来。</p><p>我时常在考虑我要怎样过这一生，这一年的工作中，有些时候感觉生活特乏味，感觉自己跟美剧「西部世界」里的那些机器人没什么两样，被人类操纵着，每一天都是重复的。但实际上，每一天都是新的，只是自己把今天过成了昨天的模样。关于未来，这里我不想去畅想，因为我把握不了未来，我能把握的就是今天、此刻。我认为把当下的事情做好，该来的总会来。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android APK 打包过程</title>
      <link href="2018/07/07/apk-build-and-package-flow-introduction/"/>
      <url>2018/07/07/apk-build-and-package-flow-introduction/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中，每天都会点击 Android Studio 的 run 按钮运行很多次应用，Android Studio 很好地帮我们隐去了 APK 的生成流程，这中间经历了哪些流程，这里简单梳理记录下。</p><p>Android APK 本质上是一个压缩包，打开后会发现就是各种资源文件、一或多个 dex 文件、AndroidManifest.xml、resources.arsc 以及其他一些文件组成的。</p><p>Android 官网给出的构建流程图：</p><p><img src="/2018/07/07/apk-build-and-package-flow-introduction/android_build.png" alt="android_build"></p><p><strong>从图中可以总结为 7 个步骤</strong>：</p><p>1、通过 aapt 打包 res 资源文件，生成 R.java、resources.arsc 和 res 文件（二进制 &amp; 非二进制如 res/raw 和 pic 保持原样）</p><p>2、处理 .aidl 文件，生成对应的Java接口文件。</p><p>3、通过 Java Compiler 编译 R.java、Java 接口文件、Java 源文件，生成 .class 文件。</p><p>4、通过 dex 命令，将 .class 文件和第三方库中的 .class 文件处理生成 classes.dex。</p><p>5、通过 apkbuilder 工具，将 aapt 生成的 resources.arsc 和 res 文件、assets 文件和 classes.dex 一起打包生成apk。</p><p>6、通过 Jarsigner 工具，对上面的 apk 进行 debug 或 release 签名。</p><p>7、通过 zipalign 工具，将签名后的 apk 进行对齐处理。</p><p><img src="/2018/07/07/apk-build-and-package-flow-introduction/android_build_detail.png" alt="android_build_detail">更详细的流程图可以看下图：</p><p><strong>参考</strong></p><ul><li><span class="exturl"><a class="exturl__link" href="http://mouxuejie.com/blog/2016-08-04/build-and-package-flow-introduction/">Android打包系列——打包流程梳理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="http://blog.zhaiyifan.cn/2016/02/13/android-reverse-2/">Android逆向分析(2) APK的打包与安装</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (非常详细)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速上传开源项目至 Jcenter</title>
      <link href="2018/07/03/how-to-upload-library-to-jcenter/"/>
      <url>2018/07/03/how-to-upload-library-to-jcenter/</url>
      
        <content type="html"><![CDATA[<p>前几天上传了个项目至 Jcenter，看了网上很多教程，基本都是以 <code>gradle-bintray-plugin </code> 这个插件做上传，教程看着都好费劲，对于新手来说真的好麻烦。</p><p>找到了另外一种方法，采用 <code>bintray-release</code> 插件，感觉要比 <code>gradle-bintray-plugin </code> 简单很多啊。于是在此记录一下，希望能帮助到新手。</p>        <h3 id="1、注册-bintray-com-账户">          <a href="#1、注册-bintray-com-账户" class="heading-link"><i class="fas fa-link"></i></a>1、注册 bintray.com 账户</h3>      <p>jcenter 是属于 bintray 的一个仓库，所以需要注册账户。注意默认注册的是组织，个人账户注册地址是 <code>https://bintray.com/signup/oss</code> ，可以用 GitHub、Google 账户注册。</p>        <h3 id="2、创建私有maven仓库">          <a href="#2、创建私有maven仓库" class="heading-link"><i class="fas fa-link"></i></a>2、创建私有maven仓库</h3>      <p>点击下图中的 <code>Add New Repository</code> 。</p><p><img src="/2018/07/03/how-to-upload-library-to-jcenter/jcenter_1.png" alt="jcenter_1"></p><p>出现下图的界面，<strong>注意其中的 Name 和 Type 都要写成 maven</strong>。</p><p><img src="/2018/07/03/how-to-upload-library-to-jcenter/jcenter_2.png" alt="jcenter_2"></p>        <h3 id="3、引入-bintray-release">          <a href="#3、引入-bintray-release" class="heading-link"><i class="fas fa-link"></i></a>3、引入 bintray-release</h3>      <p>在项目的 build.gradle 添加 <code>bintray-release</code> 的 classpath，注意是项目的 build.gradle，不是module 的。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:3.1.0&#x27;</span></span><br><span class="line">        classpath <span class="string">&#x27;com.novoda:bintray-release:0.8.1&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在待上传 moudle 的 build.gralde 中添加</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">apply plugin: <span class="string">&#x27;com.novoda.bintray-release&#x27;</span>  <span class="comment">// 新增</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">27</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// 保持不变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        <span class="comment">// 保持不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   <span class="comment">// 保持不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">publish &#123;</span><br><span class="line">    userOrg = <span class="string">&#x27;wuzy&#x27;</span>        <span class="comment">//bintray.com用户名</span></span><br><span class="line">    groupId = <span class="string">&#x27;com.wuzy&#x27;</span>    <span class="comment">//jcenter上的路径</span></span><br><span class="line">    artifactId = <span class="string">&#x27;logger&#x27;</span>   <span class="comment">//项目名称</span></span><br><span class="line">    publishVersion = <span class="string">&#x27;1.0.0&#x27;</span><span class="comment">//版本号</span></span><br><span class="line">    desc = <span class="string">&#x27;desc&#x27;</span><span class="comment">//描述，自由填写</span></span><br><span class="line">    website = <span class="string">&#x27;https://github.com/zywudev/Logger&#x27;</span> <span class="comment">// 网址，自由填写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>按照上述的编写，最终引入的方式为：<code>compile &#39;com.wuzy:logger:1.0.0</code> 。</p>        <h3 id="4、上传">          <a href="#4、上传" class="heading-link"><i class="fas fa-link"></i></a>4、上传</h3>      <p>上传很简单，在 Android Studio 或 cmd 控制台运行一下命令，看到 BUILD SUCCESS 即上传成功。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew clean build bintrayUpload -PbintrayUser=username -PbintrayKey=xxxxxxxxxxxxx -PdryRun=<span class="keyword">false</span></span><br></pre></td></tr></table></div></figure><p>其中 PbintrayUser 为用户名，PbintrayKey 是个人的 API Key，可在 bintray 网站上点击 Edit Profile，即可看到。</p><p><img src="/2018/07/03/how-to-upload-library-to-jcenter/jcenter_3.png" alt="jcenter_3"></p><p>上传成功后，访问 <code>https://bintray.com/用户名/maven</code>，即可看到上传的项目。</p><p><img src="/2018/07/03/how-to-upload-library-to-jcenter/jcenter_4.png" alt="jcenter_4"></p><p>注意此时还不能直接引用，因为项目还未添加到 Jcenter 仓库中。在下图的红色区域，未手动添加到 Jcenter 的会出现 <code>Add to Jcenter</code> 按钮，点击 <code>Add to Jcenter</code> 加入 <code>commit</code> 信息就行了，一般需要等待审核通过，几个小时吧，添加成功后<code>Add to Jcenter</code>那个按钮就消失了，如下图。</p><p><img src="/2018/07/03/how-to-upload-library-to-jcenter/jcenter_5.png" alt="jcenter_5"></p><p>同样，可以在 jcenter 仓库中可以看到自己的项目了。</p><p><img src="/2018/07/03/how-to-upload-library-to-jcenter/jcenter_6.png" alt="jcenter_6"></p><p>至此，整个流程就结束了，是不是很简单。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jcenter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 专用的日志封装库</title>
      <link href="2018/07/01/Android-logger/"/>
      <url>2018/07/01/Android-logger/</url>
      
        <content type="html"><![CDATA[<p>俗话说，要想程序不出 Bug， 那就一行代码也不写。</p><p>所以在程序开发或者上线后如果出现了 Bug，能够及时查看日志，对修复 Bug 非常有帮助。</p><p>目前最为流行的本地日志框架应该是 orhanobut 的 <span class="exturl"><a class="exturl__link" href="https://github.com/orhanobut/logger">Logger</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 库，功能很强大而且打印出来的日志非常好看。网络日志这块应该是 square 的 <span class="exturl"><a class="exturl__link" href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor">okhttp-logging-interceptor</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 库。</p><p>于是我便对这两种框架进行了封装，作为日常日志工具。这里推荐给大家使用。</p>        <h3 id="支持以下功能">          <a href="#支持以下功能" class="heading-link"><i class="fas fa-link"></i></a>支持以下功能</h3>      <ul><li>Logcat 后台打印好看整洁的日志。</li><li>应用崩溃日志和 error 级别日志自动保存至本地文件。</li><li>Logcat 后台打印 Http 日志，屏蔽了文件流打印乱码。</li></ul>        <h3 id="使用方法">          <a href="#使用方法" class="heading-link"><i class="fas fa-link"></i></a>使用方法</h3>      <p>1、引入依赖</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.wuzy:logger:1.0.0&#x27;</span></span><br></pre></td></tr></table></div></figure><p>2、在 Application 中初始化：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.init(tag, isLoggable, packageName, appName);</span><br></pre></td></tr></table></div></figure><p>其中 <code>tag</code>为日志标识，<code>isLoggable</code> 是否支持打印后台日志，<code>packageName</code> 为包名， <code>appName</code> 为应用名称。</p><p>应用崩溃日志和 error 级别日志会自动保存至内部存储路径 <code>Android/data/packageName/log/</code> 路径下。</p><p>3、打印不同级别日志：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">L.d(<span class="string">&quot;message1&quot;</span>);</span><br><span class="line"></span><br><span class="line">L.w(<span class="string">&quot;message2&quot;</span>);</span><br><span class="line"></span><br><span class="line">L.i(<span class="string">&quot;message3&quot;</span>);</span><br><span class="line"></span><br><span class="line">L.json(<span class="string">&quot;&#123; \&quot;key\&quot;: 3, \&quot;value\&quot;: something&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line">L.d(map);</span><br><span class="line"></span><br><span class="line">L.e(<span class="keyword">new</span> Throwable(<span class="string">&quot;error&quot;</span>));</span><br></pre></td></tr></table></div></figure><p>4、打印 OKHttp 网络日志：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpLogInterceptor logger = <span class="keyword">new</span> HttpLogInterceptor();</span><br><span class="line">logger.setLevel(HttpLogInterceptor.Level.BODY);</span><br><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(logger)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></div></figure><p>如果在使用的过程中出现问题，大家去 <span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/Logger">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 提 Issues，也可以自行修改。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 日志 </tag>
            
            <tag> 开源库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android onSaveInstanceState</title>
      <link href="2018/06/09/Android-onSaveInstanceState/"/>
      <url>2018/06/09/Android-onSaveInstanceState/</url>
      
        <content type="html"><![CDATA[<p>1、onSaveInstanceState 调用时机？</p><ul><li>按 home 键退到后台</li><li>按手机息屏键</li><li>选择其他程序时</li><li>从当前 Activity 启动其他 Activity 中</li><li>屏幕切换时</li><li>系统内存不足时，优先级低的 Activity 被杀死时</li></ul><p>总之，onSaveInstanceState 的调用遵循一个重要原则，即当系统 ”未经许可“ 有销毁 Activity 的可能时，系统有责任保存一些非永久性的数据，而正常退出时是不会调用的。</p><p>2、onSaveInstanceState 怎样保存数据？</p><ul><li>系统调用 onSaveInstanceState 保存 Activity 的视图结构，比如文本框的输入数据。系统的工作流程大致是，Activity 委托 Window 去保存数据，Window 再委托 DecorView 保存数据， DecorView 再委托各个子元素保存数据。</li><li>当然如果你想保存一些想要的数据，需要重写 onSaveInstanceState 方法。</li></ul><p>3、onRestoreInstanceState 调用时机？</p><ul><li>onSaveInstanceState 方法和 onRestoreInstanceState 方法 “不一定” 是成对的被调用的。</li><li>onRestoreInstanceState 被调用的前提是，Activity 确实被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示 Activity 的时候，用户按下 home 键回到主界面，然后用户紧接着又返回到 Activity，这种情况下 Activity 一般不会因为内存的原因被系统销毁，故Activity 的onRestoreInstanceState 方法不会被执行。</li><li>而比如屏幕切换时，Activity 会先被销毁然后重建，saveInstanceState 方法里保存的数据都会传到 onCreate 和 onRestoreInstanceState 方法中，如果在 onCreate 中恢复数据，需要先判断 Bundle 是否为空。而在 onRestoreInstanceState  方法中不需要判空处理，因为这个方法只会在有数据需要恢复时才被调用，Bundle 不可能为空。所以推荐在这个方法中恢复数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Exception and Error</title>
      <link href="2018/06/01/Java-Exception-and-Error/"/>
      <url>2018/06/01/Java-Exception-and-Error/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/06/01/Java-Exception-and-Error/java_exception_and_error.png" alt="java_exception_and_error"></p><p>1、Exception 和 Error 都是继承自 Throwable 类。</p><p>2、Exception 包括可检查异常和不检查异常。可检查异常需要在代码中进行显式捕获；不检查异常又叫运行时异常，不强求在代码中捕获。</p><p>3、Error 是指在正常情况下，不太会出现的错误，绝大部分 Error 都会导致程序处于非正常、不可恢复状态。</p><p>4、尽量不要捕获 Throwable 或者 Error，这样很难保证我们能正确处理。</p><p>5、不要生吞异常。对于不知道怎么处理的异常可以直接抛出去或者构建新的异常抛出去，在更高层面有了清晰的业务，往往更清楚合适的处理方式。</p><p>6、try-catch 会产生额外的性能开销，所以建议仅仅捕获有必要的代码段。</p><p>7、自定义异常：对特有的问题进行自定义异常封装，捕获处理异常。可见继承自 Exception 或者 Throwable，不要继承自 Error。</p><p>8、try-with-resources: 一个声明一个或多个资源的 try 语句。一个资源作为一个对象，必须在程序结束之后随之关闭。 try-with-resources 语句确保在语句的最后每个资源都被关闭 。任何实现了 java.lang.AutoCloseable 的对象, 包括所有实现了 java.io.Closeable 的对象, 都可以用作一个资源。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader)</span><br><span class="line">    ) &#123;</span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>一旦 <code>bufferedReader.readLine()</code> 出现异常，fileReader 和 bufferedReader 会自动关闭。</p><p>9、multiple-catch : 将多个异常合并写法，简化代码。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException|SQLException ex) &#123;</span><br><span class="line">    logger.log(ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意 <code>|</code> 两边的异常不能相交，即不能有父子继承关系。以上两种特性均是 Java7 之后的特性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ViewPager 与 Fragment 懒加载</title>
      <link href="2018/04/23/android-viewpager-fragment-demo/"/>
      <url>2018/04/23/android-viewpager-fragment-demo/</url>
      
        <content type="html"><![CDATA[<p>ViewPager + 多 Fragment 的模式很常用，但是 ViewPager 存在预加载的问题，如果多个 Fragment 都存在大量的网络请求或读写情况，就影响了 APP 性能和体验。在网上找到了一个比较好的<span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/c5d29a0c3f4c#">解决方法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，方法就是保留 ViewPager 的预加载，在 Fragment 被选中时再加载数据，记录一下。</p><p>主要的代码如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzy on 2018/4/23.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePagerFragment</span> <span class="keyword">extends</span> <span class="title">BaseFragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BasePagerFragment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isViewInitiated;    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isVisibleToUser;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isDataInitiated;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        isViewInitiated = <span class="keyword">true</span>;</span><br><span class="line">        prepareLoadData();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onActivityCreated: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        <span class="keyword">this</span>.isVisibleToUser = isVisibleToUser;</span><br><span class="line">        prepareLoadData();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;setUserVisibleHint: &quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prepareLoadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prepareLoadData(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prepareLoadData</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisibleToUser &amp;&amp; isViewInitiated &amp;&amp; (!isDataInitiated || forceUpdate)) &#123;</span><br><span class="line">            loadData();</span><br><span class="line">            isDataInitiated = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里简单解释下，<code>setUserVisibleHint</code> 方法可被用来判断 Fragment UI 是否可见。注意的是，如果项目中没有使用 ViewPager 的话，这个方法压根不调用。<br>这里，在 UI 可见的时候的时候 调用 <code>prepareLoadData</code> 方法，在 <code>prepareLoadData</code> 方法中做判断：如果 UI 可见，并且 Fragment 已经初始化完毕，数据未加载或者需要强制加载数据的情况下，进行数据加载。</p><p>在某些情况下可能想禁掉 ViewPager 的滑动，可以自定义 ViewPager，提供设置滑动的方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzy on 2018/4/23.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomViewPager</span> <span class="keyword">extends</span> <span class="title">ViewPager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPageChangeEnabled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomViewPager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomViewPager</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isPageChangeEnabled &amp;&amp; <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isPageChangeEnabled &amp;&amp; <span class="keyword">super</span>.onInterceptTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置是否可以滑动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPageChangeEnabled</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isPageChangeEnabled = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>具体 Demo 地址 ：<span class="exturl"><a class="exturl__link" href="https://github.com/zywudev/ViewPagerDemo">ViewPagerDemo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一个好用的 Android 屏幕适配的插件</title>
      <link href="2018/04/18/a-screen-match-method-was-recommend-in-android/"/>
      <url>2018/04/18/a-screen-match-method-was-recommend-in-android/</url>
      
        <content type="html"><![CDATA[<p>Android 屏幕适配一直是个消耗时间，但没啥意思的活。</p><p>关于 Android 屏幕适配的基本知识可以参考这篇文章：</p><ul><li><a href="http://wuzhangyang.com/2017/08/02/android-screen-adaptation/">Android 屏幕适配笔记</a>  </li></ul><p>今天推荐一种适配方案，能够节约大部分适配时间。</p>        <h2 id="dp-适配">          <a href="#dp-适配" class="heading-link"><i class="fas fa-link"></i></a>dp 适配</h2>      <p>我们知道获取屏幕最小宽度 dp 值的方法：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DisplayMetrics dm = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line"></span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> widthPixels = dm.widthPixels;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> density = dm.density;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> widthDP = widthPixels / density;</span><br></pre></td></tr></table></div></figure><p>而 dp 适配的原理就是根据 dp 值等比缩放。根据<strong>“最小宽度（Smallest-width）限定符”</strong>，即如果当前设备最小宽度（以 dp 为单位）为 400dp，那么系统会自动找到对应的 values-sw400dp 文件夹下的 dimens.xml 文件。</p><p>所以如果可以以某一 widthDP 为基准，生成所有设备对应的  dimens.xml 文件，就可以省去很多适配时间了。</p><p>网上已经有大神写了一个自动生成的插件，非常好用。下面介绍下使用方法。</p><p>1、首先是下载 ScreenMatch 插件，这个不用多讲了，直接在 Android Studio 中下载即可，安装完成重启 AS。</p><p>2、在项目的默认 values 文件夹中需要提供一份 dimens.xml 文件。这个文件中的 dp 值和 sp 值就是基准值。写法如下。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Your custom size defind by references, can be writted in anywhere, any module, any values&#x2F;*.xml, for example: --&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;card_common_margin_left&quot;&gt;@dimen&#x2F;dp_15&lt;&#x2F;dimen&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- dp and sp values, must be defind in this file! --&gt;</span><br><span class="line">    &lt;!-- view size,you can add if there is no one --&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_60&quot;&gt;-60dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_30&quot;&gt;-30dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_20&quot;&gt;-20dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_12&quot;&gt;-12dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_10&quot;&gt;-10dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_8&quot;&gt;-8dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_5&quot;&gt;-5dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_2&quot;&gt;-2dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_m_1&quot;&gt;-1dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_0&quot;&gt;0dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_0_1&quot;&gt;0.1dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_0_5&quot;&gt;0.5dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_1&quot;&gt;1dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_1_5&quot;&gt;1.5dp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;dp_2&quot;&gt;2dp&lt;&#x2F;dimen&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- font size,you can add if there is no one --&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;sp_6&quot;&gt;6sp&lt;&#x2F;dimen&gt;</span><br><span class="line">    &lt;dimen name&#x3D;&quot;sp_7&quot;&gt;7sp&lt;&#x2F;dimen&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;resources&gt;</span><br></pre></td></tr></table></div></figure><p>3、在任何目录下右键选择 ScreenMatch 选项，执行自动生成其他 widthDP 设备对应的 dimens.xml 文件。</p><p>4、插件默认的 widthDP 基准值是 360dp，一般手机的 widthDP 都是 360dp。这个插件会自动生成  widthDP 为 384,392,400,410,411,480,533,592,600,640,662,720,768,800,811,820,960,961,1024,1280,1365 下的 dimen 文件。</p><p>5、当然你也可以通过修改以下配置文件的属性来满足自己的需求。记得修改配置后，需要删除自动生成的文件夹，重新点击 ScreenMatch 生成。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">############################################################################</span><br><span class="line"># Start with &#x27;#&#x27; is annotate.                                              #</span><br><span class="line"># In front of &#x27;=&#x27; is key, cannot be modified.                              #</span><br><span class="line"># More information to visit:                                               #</span><br><span class="line">#   http://blog.csdn.net/fesdgasdgasdg/article/details/52325590            #</span><br><span class="line">#   http://download.csdn.net/detail/fesdgasdgasdg/9913744                  #</span><br><span class="line">#   https://github.com/mengzhinan/PhoneScreenMatch                         #</span><br><span class="line">############################################################################</span><br><span class="line">#</span><br><span class="line"># You need to refresh or reopen the project every time you modify the configuration,</span><br><span class="line"># or you can&#x27;t get the latest configuration parameters.</span><br><span class="line">#</span><br><span class="line">#############################################################################</span><br><span class="line">#</span><br><span class="line"># Base dp value for screen match. Cut the screen into [base_dp] parts.</span><br><span class="line"># Data type is double. System default value is 360.</span><br><span class="line"># I advise you not to modify the value, be careful !!!!!!!!! _^_  *_*</span><br><span class="line">base_dp=<span class="number">360</span>            <span class="comment">// widthDP 默认基准</span></span><br><span class="line"># Also need to match the phone screen of [match_dp].</span><br><span class="line"># If you have another dp values.</span><br><span class="line"># System default values is 384,392,400,410,411,480,533,592,600,640,662,720,768,800,811,820,960,961,1024,1280,1365</span><br><span class="line">match_dp=    <span class="comment">// 可以添加你想要的 widthDP 值</span></span><br><span class="line"># If you not wanna to match dp values above. Write some above values here, append value with &quot;,&quot; .</span><br><span class="line"># For example: 811,961,1365 </span><br><span class="line">ignore_dp=     <span class="comment">// 添加不需要生成的 widthDP 值</span></span><br><span class="line"># They&#x27;re not android module name. If has more，split with , Symbol.</span><br><span class="line"># If you set, it will not show in SelectDialog.</span><br><span class="line"># If you have, write here and append value with &quot;,&quot; .</span><br><span class="line"># For example: testLibrary,commonModule</span><br><span class="line"># System default values is .gradle, gradle, .idea, build, .git</span><br><span class="line">ignore_module_name=</span><br><span class="line"># Use which module under the values/dimen.xml file to do the base file,</span><br><span class="line"># and generated dimen.xml file store in this module?</span><br><span class="line"># Default value is &#x27;app&#x27;.</span><br><span class="line">match_module=app</span><br><span class="line"># Don&#x27;t show select dialog again when use this plugin.</span><br><span class="line"># System screen match will use the last selected module name or default module name.</span><br><span class="line"># You can give value true or false. Default value is false.</span><br><span class="line">not_show_dialog=<span class="keyword">false</span></span><br><span class="line"># Do you want to generate the default example dimens.xml file?</span><br><span class="line"># In path of .../projectName/screenMatch_example_dimens.xml, It does not affect your project code.</span><br><span class="line"># You can give value true or false. Default value is false.</span><br><span class="line">not_create_default_dimens=<span class="keyword">false</span></span><br><span class="line"># Does the font scale the same size as the DP? May not be accuracy.</span><br><span class="line"># You can give value true or false. Default value is true. Also need scaled.</span><br><span class="line">is_match_font_sp=<span class="keyword">true</span></span><br><span class="line"># Do you want to create values-wXXXdp folder or values-swXXXdp folder ?</span><br><span class="line"># I suggest you create values-swXXXdp folder,</span><br><span class="line"># because I had a problem when I was working on the horizontal screen adapter.</span><br><span class="line"># values-swXXXdp folder can solve my problem.</span><br><span class="line"># If you want create values-swXXXdp folder, set &quot;create_values_sw_folder=true&quot;,</span><br><span class="line"># otherwise set &quot;create_values_sw_folder=true&quot;.</span><br><span class="line"># Default values is true.</span><br><span class="line">create_values_sw_folder=<span class="keyword">true</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>6、对于其他 module， 只需要在 values 文件夹下有一套与 app module 一样的 dimens 文件即可达到适配。</p><p>具体的插件原理以及更多细节可以直接去看插件作者的文章 <span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/fesdgasdgasdg/article/details/78108169">Android dp方式的屏幕适配工具使用(Android Studio插件方式)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，非常感谢作者。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 绘制虚线</title>
      <link href="2018/04/17/how-to-draw-dashed/"/>
      <url>2018/04/17/how-to-draw-dashed/</url>
      
        <content type="html"><![CDATA[<p>Android 中绘制虚线可采用添加在布局文件中添加一个 View，然后给这个 View 加个虚线背景即可。</p><p>一般都是用 shape 绘制虚线 :</p><figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;shape xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:shape=<span class="string">&quot;line&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;stroke</span><br><span class="line">        android:dashGap=<span class="string">&quot;2dp&quot;</span></span><br><span class="line">        android:dashWidth=<span class="string">&quot;2dp&quot;</span></span><br><span class="line">        android:color=<span class="string">&quot;@color/colorAccent&quot;</span></span><br><span class="line">        android:width=<span class="string">&quot;1dp&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></div></figure><p>然后在需要绘制虚线的地方加个 View :</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">    android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;2dp&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;@drawable/shape_dashed&quot;</span>/&gt;</span><br></pre></td></tr></table></div></figure><p>很简单。</p><p>但运行到真机上发现并不是虚线，而是一条实线。网上一堆博客文章都是这种做法，不知道他们都验证过没有。。。</p><p>查了一些资料，才知道绘制的虚线变成实线的原因是 dashGap 不支持硬件加速，而我们的手机默认是开启了硬件加速的。因此只需要修改下 View 的属性即可。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">    android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;2dp&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;@drawable/shape_dashed&quot;</span></span><br><span class="line">    android:layerType=<span class="string">&quot;software&quot;</span>/&gt;</span><br></pre></td></tr></table></div></figure><p>此外要注意 View 的高度要比 shape 中定义的高度要大，不然不显示。都是一些细节，虽然没什么技术含量，但最近发现很多 Bug 都是低级错误导致的，都是平时不注重细节的原因。在此记录一下，提醒自己。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保险概览</title>
      <link href="2018/03/28/insurance-note/"/>
      <url>2018/03/28/insurance-note/</url>
      
        <content type="html"><![CDATA[<p>了解了些保险知识，整理了部分导图笔记。</p><p><img src="/2018/03/28/insurance-note/insurance.png" alt="insurance"></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保险 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android setContentView，Window，PhoneWindow and DecorView</title>
      <link href="2018/02/23/android-window-phonewindow-decorview/"/>
      <url>2018/02/23/android-window-phonewindow-decorview/</url>
      
        <content type="html"><![CDATA[<p>从 Activity 的 <code>setContentView(R.layout.activity_main)</code> 开始。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">  getWindow().setContentView(layoutResID);</span><br><span class="line">  initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里调用了 <code>getWindow().setContentView</code> 方法，那这个 getWindow() 是什么呢？</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the current &#123;<span class="doctag">@link</span> android.view.Window&#125; for the activity.</span></span><br><span class="line"><span class="comment">     * This can be used to directly access parts of the Window API that</span></span><br><span class="line"><span class="comment">     * are not available through Activity/Screen.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Window The current window, or null if the activity is not</span></span><br><span class="line"><span class="comment">     *         visual.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从上面的 getWindow() 方法可以看到，获取的是当前 activity 的 Window 对象，如果 activity 不可见，返回 null。而 Window 是一个抽象类，所以这里的 mWindow.setContentView 方法调用的是 Window 实现类的方法。那 Window 的实现类是什么呢？</p><p>在 Activity 类的 attach 方法中，可以看出，PhoneWindow 即是 Window 的实现类。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                  CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">                  NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">  attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">  mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">  <span class="comment">// 创建 PhoneWindow 对象</span></span><br><span class="line">  mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">  ... <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>所以我们直接去看 PhoneWindow 的 setContentView 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">  <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">  <span class="comment">// before this happens.</span></span><br><span class="line">  <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    installDecor(); </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">    mContentParent.removeAllViews();</span><br><span class="line">  &#125;</span><br><span class="line">   ... <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果 mContentParent == null，也就是当前内容未加载到窗口中，第一次加载时，调用 installDecor() 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mDecor = generateDecor(-<span class="number">1</span>);  </span><br><span class="line">    mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">    mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">      mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mContentParent = generateLayout(mDecor);</span><br><span class="line">    ... <span class="comment">// 省略 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>installDecor() 方法中先是通过 generateDecor() 方法创建 DecorView 对象，DecorView 继承于 FrameLayout，用来作为整个PhoneWindow的根视图，但此时还只是个空架子。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">  ... <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>创建完成后，根据用户的设置，通过 generateLayout() 方法根据 Theme 从系统中选择创建默认布局。</p><p><strong>引用 <span class="exturl"><a class="exturl__link" href="https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B12%5DDispatch-TouchEvent-Theory.md">事件分发机制原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 中的例子阐述 Window、PhoneWindow 及 DecorView 之间的关系</strong>：</p><blockquote><p>简单来说，Window是一个抽象类，是所有视图的最顶层容器，视图的外观和行为都归他管，不论是背景显示，标题栏还是事件处理都是他管理的范畴，它其实就像是View界的太上皇(虽然能管的事情看似很多，但是没实权，因为抽象类不能直接使用)。</p><p>而 PhoneWindow 作为 Window 的唯一亲儿子(唯一实现类)，自然就是 View 界的皇帝了，PhoneWindow 的权利可是非常大大，不过对于我们来说用处并不大，因为皇帝平时都是躲在深宫里面的，虽然偶尔用特殊方法能见上一面，但想要完全指挥 PhoneWindow 为你工作是很困难的。</p><p>而上面说的 DecorView 是 PhoneWindow 的一个内部类，其职位相当于小太监，就是跟在 PhoneWindow 身边专业为 PhoneWindow 服务的，除了自己要干活之外，也负责消息的传递，PhoneWindow 的指示通过 DecorView 传递给下面的 View，而下面 View 的信息也通过 DecorView 回传给 PhoneWindow。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《禅与摩托车维修艺术》摘录</title>
      <link href="2018/01/28/Zen-and-the-Art-of-Motorcycle-Maintenance/"/>
      <url>2018/01/28/Zen-and-the-Art-of-Motorcycle-Maintenance/</url>
      
        <content type="html"><![CDATA[<p>1.</p><p>我们夫妻俩和一些老友迷上这种乡间小路已经有好些年了。当初为了调剂一下或是为了去另一条干道而走捷径，都不免要骑上一段。每次我们都会惊讶于景色的美丽，骑回原路时便有一种轻松愉悦的感觉。我们经常这么骑，后来才明白道理其实很简单：这些乡间小路和一般的干道迥然不同，就连沿线居住的居民的生活步调和个性也不一样。他们一直都没有离开过本地，所以可以很悠闲地和你寒暄问候、谈天说地，那感觉好极了。反而是那些早就搬到城市里的人和他们的子子孙孙迷失了，忘记了这种情怀。这实在是一个宝贵的发现。我在想，为什么我们这么久之后才会对其着迷。我们早已看过却仿佛没有看到，或者说是环境使我们视而不见，蒙骗了我们，让我们以为真正的生活是在大都市里，而这里只不过是落后的穷乡僻壤。这的确是件令人迷惘的事，就好像真理已经在敲你的门，而你却说：“走开，我正在寻找真理。”所以真理掉头就走了。哎，这种现象真是让人不解。</p><p>2.</p><p>当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。</p><p>3.</p><p>其实现代人未必比以前的人聪明，人的智商并没有多大改变，那些印第安人和中古世纪的人跟我们都差不多，但是彼此所处的环境不同；在以前的环境中，他们认为鬼神是存在的，就像现代人认为原子、质子、光子和量子是存在的。从这个角度来说，我相信有鬼，也就是说，现代人也有属于他们的鬼神，你知道的。”</p><p>4.</p><p>地心引力也没有自己的质量，没有自己的能量，当时人尚未出现，所以也不存在于人的心灵之中。它也不在空间里，因为也没有空间存在，更不存在于任何地方–这个地心引力仍然存在吗？”</p><p>5.</p><p>因果逻辑是思想上的产物，我认为精神疾病先于人的思想。</p><p>6.</p><p>人在思考和感觉的时候往往会偏向于某一种形式，而且会误解和看轻另一种形式。然而没有人会放弃自己所看到的真理，就我所知，目前还没有人可以真正融合两者，因为这两者之间根本就找不到交会点。</p><p>7.</p><p>熟悉往往也会使一个人视而不见。</p><p>8.</p><p>钢铁？钢铁也是人所设计出来的，因为在自然界之中并没有钢铁的存在，在远古的铜器时代，就有人能告诉你这个。自然界所有的，只是可以做钢铁的原料。但是什么又是原料呢？同样的这也是人所想出来的……鬼魂！</p><p>9.</p><p>把问题正确地写下来，起码要兼顾到六方面：<br>（1）问题是什么。<br>（2）假设问题的原因。<br>（3）证实每个问题的假设。<br>（4）预测实验的结果。<br>（5）观察实验的结果。<br>（6）由实验得出结论。</p><p>10.</p><p>运用科学方法的目的，就是要从许多假设当中找出正确的一个，这就是科学的目的。然而我们从科学的历史来看，事实恰恰相反。各种资料、史料、理论和假设不断大量地增加，科学把人从唯一绝对的真理，引向多元、摇摆不定、相对的世界，是造成社会混乱、思想价值混淆的主要元凶。而这一切现象原本是科学要消灭的。</p><p>11.</p><p>我们目前所谓的理性模式并没有把社会带向更美好的世界，反而离它愈来愈远。自从文艺复兴以来，这些模式就一直存在。只要人们主要的需求还在于衣食住行，这些模式就会存在下去，而且还会继续运作。但是对现在大部分的人来说，这些基本的需要不再是主要的问题，因而从古代流传下来的理性结构已经不符合所需，从而显露出它真正的面目–在情感上是空虚的，在美学上没有任何表现，而在灵性上更是一片空白。这就是它的现状，而且它还会持续很长的一段时间。</p><p>12.</p><p>如果你对事情有完全的信心，就不太可能产生狂热的态度。就拿太阳来说 吧，没有人会为了它明天会升起而兴奋不已，因为这是必然的现象。如果有人对政治或是宗教狂热，那是因为他对这些目标或是教义没有完全的信心。</p><p>13.</p><p>克伦威尔曾经说：”一个没有目标的人才能爬到最高。“</p><p>14.</p><p>任何想要以己为荣的目标，结局都非常悲惨。</p><p>15.</p><p>哲学上的神秘主义认为真理是无法界定的，自有历史以来就存在，只能通过非理性的方式了解。这就是禅的根基，但是这并不属于学校研究的范围。而学校这座理性教会主要就是研究那些能被界定的事物，所以一个人如果想研究神秘的主义，他就应该去修道院而不是去大学，大学要研究的是能够形之于文字的事物。</p><p>16.</p><p>从一开始唯心、唯物就没有很清楚的分野。</p><p>17.</p><p>过去”只存在于我们的记忆之中，”未来”则存在于我们的计划之中，而只有”现在”才是惟一的真实。你理智上所意识到的那棵树，由于这一小段的时间的关系，便属于过去，因而对你来说并不真实。任何经由思想所意识到的总是存在于过去，因而都不真实。所以真实总是存在于你所看到的那一刹那，且在你还没有意识到之前。除此之外，没有别的真实。这种在意识之前的真实，就是斐德洛所谓的良质。由于所有经由思想所认知的事物必须来自于这一段思考前的真实，所以良质是因，而果才是所有的主体以及客体。   </p><p>18.</p><p>古典和浪漫必须从根本上融合在一起。</p><p>19.</p><p>佛教的禅宗提倡打坐，就是要使人物我两忘。而在我所提到的摩托车维修问题上，你只要专注地修理车子，就不会出现物我对立的情况。一旦真正地投入了工作之中，就可以说是在关心自己的工作，这就是关心的真正意义–对自己手中的工作产生认同感。当一个人产生这种认同感的时候，他就会看到关心的另外一面–良质。</p><p>20.</p><p>太阳已经下山了，我有一种强烈的寂寞感和孤独感，我的精神也随太阳西 沉了。</p><p>21.</p><p>如果你一时无法谦虚下来，有一个方法，就是无论如何也要装出这种态度。<br>因为如果你刻意地假设自己表现得不够好，那么一旦事实证明的确如此，你的进取心反而会提升。你会继续这样做，一直到事实证明你的假设是错误的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Handler 消息处理机制</title>
      <link href="2018/01/07/android-handler-looper-message/"/>
      <url>2018/01/07/android-handler-looper-message/</url>
      
        <content type="html"><![CDATA[<p>日常开发中，一般不会在子线程中直接进行 UI 操作，大部分采取的办法是创建 Message 对象，然后借助 Handler 发送出去，再在 Handler 的 handlerMessage() 方法中获取 Message 对象，进行一系列的 UI 操作。Handler 负责发送 Message， 又负责处理 Message， 其中经历了什么 ，需要从源码中一探究竟。</p><p>首先看 Handler 的构造函数：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">    <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">        (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">      Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">            klass.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mLooper = Looper.myLooper();</span><br><span class="line">  <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">      <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mQueue = mLooper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Handler 的无参构造函数会调用上面的重载构造函数，我们直接看第二个 if 语句， 如果 mLooper 为 null，将会抛出异常 “Can’t create handler inside thread that has not called Looper.prepare()”，意思是说如果没有调用 Looper.prepare()， 在当前线程中不能创建 Handler 实例。但是，我们在 UI 主线程中创建 Handler 时，好像并不要调用方法 Looper.prepare()，肯定是系统已经帮我们自动调用了 Looper.prepare() 方法。</p><p>我们来看 Looper.myLooper() 方法，这个方法直接从 sThreadLocal 取出 Looper 对象。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>所以 sThreadLocal 中的 Looper 对象肯定是在 Looper.prepare() 方法中 set 进去，Looper.prepare() 方法会调用 Looper.prepare(boolean quitAllowed) 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到，这个方法中首先判断当前线程中有没有 Looper 对象了，如果没有，就会创建一个 Looper 对象 set 到 sThreadLocal 中 ；如果有 Looper 对象了，就不能再创建 Looper 对象，即一个线程只能创建一个 Looper 对象。而在 UI 主线程中，系统是什么时候调用了 Looper.prepare() 方法呢？</p><p>查看 ActivityThread 中的 main() 方法，代码如下所示：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line">  SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">  <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">  <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">  CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">  EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">  <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">  TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">  Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Looper.prepareMainLooper(); <span class="comment">// 创建 Looper 对象</span></span><br><span class="line"></span><br><span class="line">  ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">  thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">    Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">  Looper.loop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>查看 <code> Looper.prepareMainLooper();</code> 这一行，应用启动的时候就调用了这个方法，在这个方法中又去调用了方法 prepare(boolean quitAllowed) 去创建一个 Looper 对象。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prepare(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sMainLooper = myLooper();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>至此，Handler 的创建过程已经清晰。再来看看 Looper 的构造函数如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">  mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看出在当前线程中创建了一个 MessageQueue，顾名思义，MessageQueue 是用来存放消息的消息队列。同样从这可以看出，一个线程只能创建一个 Looper，也就只有一个 MessageQueue。</p><p>那么，Handler 是如何发送消息并处理消息的呢？得从发送消息的方法看起，Handler 提供很多发送消息的方法，但大部分方法最终都会调用 sendMessageAtTime 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  MessageQueue queue = mQueue;</span><br><span class="line">  <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">      <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">    Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个方法的第一个参数是发送的消息，第二个参数是自系统开机到当前时间的毫秒数再加上延迟时间，如果调用的不是 sendMessageDelayed() 方法，延迟时间就为 0。最后调用 enqueueMessage 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  msg.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个方法中，首先将 msg.target 设置为 handler 对象本身，然后调用 MessageQueue 的 enqueueMessage 方法，我们再看 MessageQueue 的 enqueueMessage 方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">      IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">      Log.w(TAG, e.getMessage(), e);</span><br><span class="line">      msg.recycle();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg.markInUse();</span><br><span class="line">    msg.when = when;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">boolean</span> needWake;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">      <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">      needWake = mBlocked;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">      <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">      <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">      needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">      Message prev;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">          needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">      prev.next = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">      nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个方法中主要就是将消息按照时间的先后顺序进行排队，通过 msg.next 指定下一个消息。</p><p>那么消息是如何出队的呢？这得看 Looper.loop() 源码了。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">  <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">  <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">  Binder.clearCallingIdentity();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">    <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">      logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                      msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">    <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">      Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      msg.target.dispatchMessage(msg);  <span class="comment">// 回调 Handler 的 dispatchMessage 方法</span></span><br><span class="line">      end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.traceEnd(traceTag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> time = end - start;</span><br><span class="line">      <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Dispatch took &quot;</span> + time + <span class="string">&quot;ms on &quot;</span></span><br><span class="line">               + Thread.currentThread().getName() + <span class="string">&quot;, h=&quot;</span> +</span><br><span class="line">               msg.target + <span class="string">&quot; cb=&quot;</span> + msg.callback + <span class="string">&quot; msg=&quot;</span> + msg.what);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">      logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">    <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">      Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">              + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">              + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">              + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">              + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>主线程中，这个方法在 ActivityThread 中的 main() 方法中被调用。可以看出，在这个方法中进入了一个死循环，不断调用 MessageQueue.next() 方法从消息队列中获取出队消息，将消息传递到 msg.target 的 dispatchMessage() 方法中，这里的 msg.target 其实就是 Handler，是在 Handler 的 enqueueMessage 方法中设置的。然后看一看 Handler 中 dispatchMessage() 方法的源码，如下所示：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里三种不同的调用方法都是对消息进行处理，提供不同的应用场景。</p><p>到这里 Android Handler 的基本原理一目了然了，对于其他一些在子线程中使用的方法，比如 Handler 的 post()方法 、Activity 的 runOnUiThread() 等方法，其背后的原理都是一样的，不再赘述。</p>        <h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>      <ul><li>基本概念<ul><li>Message：消息。</li><li>MessageQueue：消息队列，用来存放 Handler 发送过来的 Message，并且按照时间顺序将消息排成队列。</li><li>Handler：消息处理者，负责发送和处理消息。</li><li>Looper：消息轮询器，不断的从 MessageQqueue 中取出 Message 交给 Handler 处理。</li></ul></li><li>应用启动时系统默认给 UI 主线程创建了 Looper 对象。如果是在子线程中创建 Handler 对象，需要先创建 Looper.prepare() 方法创建 Looper 对象。</li><li>一个线程只能拥有一个 Looper 对象和 一个 MessageQueue 对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 多进程基本知识整理</title>
      <link href="2017/09/08/android-multiple-processes-summary/"/>
      <url>2017/09/08/android-multiple-processes-summary/</url>
      
        <content type="html"><![CDATA[<p>在 Android 中，一个应用默认有一个进程。但我们可以通过配置实现在一个应用中开启多个进程。</p>        <h3 id="开启多进程方式">          <a href="#开启多进程方式" class="heading-link"><i class="fas fa-link"></i></a>开启多进程方式</h3>      <ul><li>在清单文件中指定 <code>android:process</code> 属性</li><li>适用元素：Activity，Service，Receiver，ContentProvider。</li><li>以<code>:</code> 开头，表示这个进程是应用的私有进程；以小写字母开头，表示这个进程是全局进程，可以被多个应用公用。</li></ul><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;:second&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.ThirdActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;com.example.wuzy.helloworld.third&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>        <h3 id="多进程的优点">          <a href="#多进程的优点" class="heading-link"><i class="fas fa-link"></i></a>多进程的优点</h3>      <p>系统为每个应用分配一定大小的内存，从之前的 16M 到 32M、48M，甚至更高。但毕竟有限。</p><p>进程是资源分配的基本单位。也就是说，一个应用有对个进程，那这个应用可以获得更多的内存。</p><p>所以，<strong>开启多进程可以分担主进程的内存消耗</strong>，常见音乐类 APP 的后台播放，应用的推送服务等。</p>        <h3 id="多进程的不足">          <a href="#多进程的不足" class="heading-link"><i class="fas fa-link"></i></a>多进程的不足</h3>      <p><strong>1、数据共享问题</strong></p><p>Android 系统为每个进程分配独立的虚拟机，不同的虚拟机之间数据不能共享，即使是静态成员还是单例模式。</p><p><strong>2、线程同步机制失效</strong></p><p>不同进程锁的不是同一个对象，无法保证线程同步了。</p><p><strong>3、SharedPreferences 可靠性下降</strong></p><p>SharedPreferences 还没有增加对多进程的支持。</p><p><strong>4、Application 多次创建</strong></p><p>当一个组件跑在新的进程中，系统要在创建进程的同时为其分配独立的虚拟机，自然就会创建新的 Application。这就导致了 application 的 onCreate方法重复执行全部的初始化代码。因此，可以根据进程需要进行最小的业务初始化。</p><p><strong>不同进程共同的初始化业务逻辑</strong> ：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不同进程共同的初始化代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppCreate</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p><strong>简单工厂模式</strong> ：</p><p>根据进程名进行对应进程的初始化逻辑。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitFactory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppInitialization <span class="title">getAppInitialization</span><span class="params">(String processName)</span> </span>&#123;</span><br><span class="line">        AppInitialization appInitialization;</span><br><span class="line">        <span class="keyword">if</span> (processName.endsWith(<span class="string">&quot;:second&quot;</span>)) &#123;</span><br><span class="line">            appInitialization = <span class="keyword">new</span> SecondApplication();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processName.endsWith(<span class="string">&quot;:third&quot;</span>)) &#123;</span><br><span class="line">            appInitialization = <span class="keyword">new</span> ThirdApplication();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appInitialization = <span class="keyword">new</span> AppInitialization();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appInitialization;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondApplication</span> <span class="keyword">extends</span> <span class="title">AppInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppCreate</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onAppCreate(application);</span><br><span class="line">            <span class="comment">// init</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdApplication</span> <span class="keyword">extends</span> <span class="title">AppInitialization</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppCreate</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onAppCreate(application);</span><br><span class="line">            <span class="comment">// init</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p><strong>具体调用代码</strong> ：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MyApplication&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        String currentProcessName = getCurrentProcessName();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;currentProcessName : &quot;</span> + currentProcessName );</span><br><span class="line">        AppInitialization appInitialization =                                AppInitFactory.getAppInitialization(currentProcessName);</span><br><span class="line">        <span class="keyword">if</span> (appInitialization != <span class="keyword">null</span>) &#123;</span><br><span class="line">            appInitialization.onAppCreate(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前进程名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCurrentProcessName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String currentProcessName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> pid = android.os.Process.myPid();</span><br><span class="line">        ActivityManager manager = (ActivityManager) <span class="keyword">this</span>.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInfo.pid == pid) &#123;</span><br><span class="line">                currentProcessName = processInfo.processName;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentProcessName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 编码规范</title>
      <link href="2017/08/28/android-coding-standards/"/>
      <url>2017/08/28/android-coding-standards/</url>
      
        <content type="html"><![CDATA[<p>简单总结了 Android 开发中的一些代码规范，供开发者参考。</p>        <h2 id="0-Index">          <a href="#0-Index" class="heading-link"><i class="fas fa-link"></i></a>0 Index</h2>      <ul><li><a href="#1-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">1 命名规范</a></li><li><a href="#2-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83">2 注释规范</a></li><li><a href="#3-%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83">3 格式规范</a></li><li><a href="#4-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">4 参考资料</a></li></ul>        <h2 id="1-命名规范">          <a href="#1-命名规范" class="heading-link"><i class="fas fa-link"></i></a>1 命名规范</h2>      <p><strong>大驼峰命名（UpperCamelCase）</strong>：每个单词的第一个字母都大写。</p><p><strong>小驼峰命名（lowerCamelCase）</strong>：除第一个单词以外，每一个单词的第一个字母大写。</p><p><strong>命名的基本原则</strong>： </p><ul><li>不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</li><li>严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。但比如 <code>shanghai</code> 等通用的名称，可视同英文。</li><li>除了常见的英文缩写，尽量避免缩写。</li></ul>        <h3 id="1-1-类-接口命名">          <a href="#1-1-类-接口命名" class="heading-link"><i class="fas fa-link"></i></a>1.1 类 / 接口命名</h3>      <ul><li>使用大驼峰命名法，用名词或者名词词组命名，每个单词的首字母大写。</li><li>尽量避免大写，除非该缩写是众所周知的，比如 <code>URL</code>、<code>HTML</code> 等。</li><li>接口命名规则与类一样采用大驼峰命名法，多以<code>able</code> 或 <code>ible</code> 结尾，如<code>interface Runnable</code>、<code>interface Accessible</code> 。</li><li>若项目采用 <code>MVP</code> 架构，接口都以 <code>I</code> 为前缀，不加后缀，其他的接口采用上述命名规则。比如 <code>interface IUserTest</code>。</li><li>常见类名命名规则如下：</li></ul><div class="table-container"><table><thead><tr><th>类</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>Activity 类</td><td>以 Activity 为后缀</td><td>登录页面类 LoginActivity</td></tr><tr><td>Fragment 类</td><td>以 Fragment 为后缀</td><td>新闻标题列表 NewsTitlelFragment</td></tr><tr><td>Service 类</td><td>以 Service 为后缀</td><td>下载服务 DownloadService</td></tr><tr><td>Adapter 类</td><td>以 Adapter 为后缀</td><td>新闻详情适配器 NewsDetailAdapter</td></tr><tr><td>工具方法类</td><td>以 Utils 或 Manager 为后缀</td><td>日志工具 LogUtils</td></tr><tr><td>数据库类</td><td>以 DBHelper 为后缀</td><td>新闻数据库 NewsDBHelper</td></tr><tr><td>解析类</td><td>以 Parser 为后缀</td><td>JSON 解析类 JsonParser</td></tr><tr><td>BroadcastReceiver 类</td><td>以 Receiver 为后缀</td><td>强制下线广播 ForceOfflineReceiver</td></tr><tr><td>自定义共享基础类</td><td>以 Base 为前缀</td><td>BaseActivity、BaseFragment</td></tr><tr><td>测试类</td><td>以它要测试的类的名称开始，以 Test 结束</td><td>UserTest</td></tr><tr><td>抽象类</td><td>以 Abstract 或 Abs 为前缀</td><td>AbsUserTest</td></tr></tbody></table></div>        <h3 id="1-2-变量命名">          <a href="#1-2-变量命名" class="heading-link"><i class="fas fa-link"></i></a>1.2 变量命名</h3>      <ul><li>成员变量 / 局部变量<ul><li>使用小驼峰命名。</li><li>不推荐使用谷歌的前面加 <code>m</code> 的编码风格。</li></ul></li><li>控件变量<ul><li>使用小驼峰命名。</li><li>建议使用 <code>控件缩写 + 逻辑名称</code> 格式，例如 <code>btnLogin</code>、<code>etUserName</code> 。</li><li>对应的控件 <code>id</code> 命名为 <code>控件缩写_逻辑名称</code>，例如 <code>btn_login</code>、<code>et_user_name</code> 。</li><li>常见控件缩写如下：</li></ul></li></ul><div class="table-container"><table><thead><tr><th>控件</th><th>缩写</th><th>控件</th><th>缩写</th></tr></thead><tbody><tr><td>TextView</td><td>tv</td><td>ImageButton</td><td>ib</td></tr><tr><td>EditText</td><td>et</td><td>CheckBox</td><td>cb</td></tr><tr><td>WebView</td><td>wv</td><td>RadioButton</td><td>rb</td></tr><tr><td>ImageView</td><td>iv</td><td>SeekBar</td><td>sb</td></tr><tr><td>VideoView</td><td>vv</td><td>ProgressBar</td><td>pb</td></tr><tr><td>MediaController</td><td>mc</td><td>Spinner</td><td>spr</td></tr><tr><td>ListView</td><td>lv</td><td>SerachView</td><td>sev</td></tr><tr><td>GridView</td><td>gv</td><td>Button</td><td>btn</td></tr><tr><td>Gallery</td><td>gly</td><td>TimePicker</td><td>tp</td></tr><tr><td>LinearLayout</td><td>ll</td><td>DatePicker</td><td>dp</td></tr><tr><td>RelativeLayout</td><td>rl</td><td>ScrollView</td><td>sv</td></tr><tr><td>FrameLayout</td><td>fl</td><td>RecyclerView</td><td>rv</td></tr></tbody></table></div>        <h3 id="1-3-常量命名">          <a href="#1-3-常量命名" class="heading-link"><i class="fas fa-link"></i></a>1.3 常量命名</h3>      <ul><li>单词每个字母均大写。</li><li>单词之间用下划线连接，力求语义表达完整清楚，不要嫌名字长。</li></ul>        <h3 id="1-4-方法命名">          <a href="#1-4-方法命名" class="heading-link"><i class="fas fa-link"></i></a>1.4 方法命名</h3>      <ul><li>使用小驼峰命名。</li><li>方法名通常是动词或动词短语，保证见名知义，尽量不适用 <code>or</code> 或者 <code>and</code>，遵循 “ do one thing ” 原则。</li><li>一个方法尽量不要超过 50 行，如果方法太长，说明当前方法业务逻辑已经非常复杂，那么就需要进行方法拆分。</li></ul><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>initXX()</td><td>初始化相关方法</td><td>resetXX()</td><td>重置数据</td></tr><tr><td>onXX()</td><td>回调方法</td><td>clearXX()</td><td>清除数据</td></tr><tr><td>getXX()</td><td>具有返回值的获取方法</td><td>removeXX()</td><td>移除数据或视图</td></tr><tr><td>setXX()</td><td>设置方法</td><td>drawXX()</td><td>绘制</td></tr><tr><td>isXX()/hasXX()/checkXX()</td><td>布尔型的判断方法</td><td>displayXX()/showXX()</td><td>展示、提示信息的方法</td></tr><tr><td>updateXX()</td><td>更新数据</td><td>handleXX()/processXX()</td><td>对数据进行处理的方法</td></tr><tr><td>saveXX()</td><td>保存数据</td><td></td><td></td></tr></tbody></table></div>        <h3 id="1-5-资源文件命名">          <a href="#1-5-资源文件命名" class="heading-link"><i class="fas fa-link"></i></a>1.5 资源文件命名</h3>      <p>全部小写，采用下划线命名法。</p>        <h4 id="1-5-1-布局文件命名（xml-文件）">          <a href="#1-5-1-布局文件命名（xml-文件）" class="heading-link"><i class="fas fa-link"></i></a>1.5.1 布局文件命名（xml 文件）</h4>      <p>以对应的类别名称为前缀，逻辑名称在后，以下划线连接。</p><div class="table-container"><table><thead><tr><th>布局类型</th><th>布局前缀</th></tr></thead><tbody><tr><td>Activity</td><td>activity_</td></tr><tr><td>Fragment</td><td>fragment_</td></tr><tr><td>Include</td><td>include_</td></tr><tr><td>Dialog</td><td>dialog_</td></tr><tr><td>PopupWindow</td><td>popup_</td></tr><tr><td>Menu</td><td>menu_</td></tr><tr><td>GridView 的item 布局文件</td><td>item_grid_</td></tr><tr><td>ListView 的 item 布局文件</td><td>item_list_</td></tr></tbody></table></div>        <h4 id="1-5-2-drawable-文件命名">          <a href="#1-5-2-drawable-文件命名" class="heading-link"><i class="fas fa-link"></i></a>1.5.2 drawable 文件命名</h4>      <p>以用途缩写作为前缀，逻辑名称在后，以下划线连接，区分状态时，添加状态后缀。</p><div class="table-container"><table><thead><tr><th>drawable</th><th>规则</th></tr></thead><tbody><tr><td>图标资源</td><td>ic_</td></tr><tr><td>背景图片</td><td>bg_</td></tr><tr><td>按钮图片</td><td>btn_</td></tr><tr><td>分隔线</td><td>div_</td></tr><tr><td>默认类</td><td>def_</td></tr><tr><td>区分状态时，默认状态</td><td>_normal</td></tr><tr><td>区分状态时，按下时的状态</td><td>_pressed</td></tr><tr><td>区分状态时，选中时的状态</td><td>_selected</td></tr><tr><td>区分状态时，不可用时的状态</td><td>_disable</td></tr><tr><td>区分状态时，悬停效果</td><td>_hovered</td></tr><tr><td>区分状态时，可选状态</td><td>_checkable</td></tr></tbody></table></div>        <h4 id="1-5-3-动画文件命名（anim-文件夹下）">          <a href="#1-5-3-动画文件命名（anim-文件夹下）" class="heading-link"><i class="fas fa-link"></i></a>1.5.3 动画文件命名（anim 文件夹下）</h4>      <p>规则：动画类型_动画方向。</p><div class="table-container"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>fade_in</td><td>淡入</td></tr><tr><td>fade_out</td><td>淡出</td></tr><tr><td>push_down_in</td><td>从下方推入</td></tr><tr><td>push_down_out</td><td>从下方推出</td></tr><tr><td>push_left</td><td>推向左方</td></tr><tr><td>slide_in_from_top</td><td>从头部滑动进入</td></tr><tr><td>zoom_enter</td><td>变形进入</td></tr><tr><td>slide_in</td><td>滑动进入</td></tr><tr><td>shrink_to_middle</td><td>中间缩写</td></tr></tbody></table></div>        <h4 id="1-5-4-values-中-name-命名">          <a href="#1-5-4-values-中-name-命名" class="heading-link"><i class="fas fa-link"></i></a>1.5.4 values 中 name 命名</h4>              <h5 id="1-5-4-1-strings-xml">          <a href="#1-5-4-1-strings-xml" class="heading-link"><i class="fas fa-link"></i></a>1.5.4.1 strings.xml</h5>      <ul><li>命名格式：xx 界面 + 逻辑功能 ，如 <code>activity_home_welcome_str</code>。</li><li>建议把同一个界面的所有 String 都在一起，方便查找。</li></ul>        <h5 id="1-5-4-2-styles-xml">          <a href="#1-5-4-2-styles-xml" class="heading-link"><i class="fas fa-link"></i></a>1.5.4.2 styles.xml</h5>      <ul><li>使用大驼峰命名法，主题可以命名为<code>XXTheme</code> ，控件的风格可以命名为 <code>XXStyle</code> 。</li></ul>        <h5 id="1-5-4-3-colors-xml">          <a href="#1-5-4-3-colors-xml" class="heading-link"><i class="fas fa-link"></i></a>1.5.4.3 colors.xml</h5>      <ul><li>命名格式：color_16进制颜色值</li></ul><ul><li>不要为某个控件指定特定颜色，比如 <code>bg_login</code> ，这样非常容易重复定义颜色值。</li></ul><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;red_FF432F&quot;</span>&gt;</span>#FF432F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;red_FF0000&quot;</span>&gt;</span>#FF0000<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></div></figure>        <h5 id="1-5-4-4-dimens-xml">          <a href="#1-5-4-4-dimens-xml" class="heading-link"><i class="fas fa-link"></i></a>1.5.4.4 dimens.xml</h5>      <ul><li>可以和 colors.xml 中命名格式类似</li><li>必要时也可用”逻辑名称_功能“ 命名</li></ul><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- font sizes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;font_22&quot;</span>&gt;</span>22sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;font_12&quot;</span>&gt;</span>12sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- typical spacing between two views --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;spacing_40&quot;</span>&gt;</span>40dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;spacing_4&quot;</span>&gt;</span>4dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- typical sizes of views --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;button_height_60&quot;</span>&gt;</span>60dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;button_height_40&quot;</span>&gt;</span>40dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></div></figure>        <h2 id="2-注释规范">          <a href="#2-注释规范" class="heading-link"><i class="fas fa-link"></i></a>2 注释规范</h2>      <p>类、类属性、类方法的注释必须使用 Javadoc 规范，使用<code>/** XXX */ </code>格式，不得使用 <code>// XXX</code> 方式。</p>        <h3 id="2-1-类和接口注释">          <a href="#2-1-类和接口注释" class="heading-link"><i class="fas fa-link"></i></a>2.1 类和接口注释</h3>      <p>类和接口统一添加 Javadoc 注释，要求至少写出创建者、创建时间以及内容简要说明。具体可以在 AS 中自己配制，<code>Settings → Editor → File and Code Templates → Includes → File Header</code>，格式如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author : xxx</span></span><br><span class="line"><span class="comment"> * e-mail : xxx@xx</span></span><br><span class="line"><span class="comment"> * time   : 2017/08/28</span></span><br><span class="line"><span class="comment"> * desc   :</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></div></figure>        <h3 id="2-2-方法注释">          <a href="#2-2-方法注释" class="heading-link"><i class="fas fa-link"></i></a>2.2 方法注释</h3>      <p>下面几种方法，都必须添加 Javadoc 注释，除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</p><ul><li>接口中定义的所有方法</li><li>抽象类中自定义的抽象方法</li><li>抽象父类的自定义公用方法</li><li>工具类的公用方法</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 方法的一句话概述</span></span><br><span class="line"><span class="comment">* 方法详述（简单方法可不必详述）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> s 说明参数含义</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 说明返回值含义</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException 说明发生此异常的条件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException 说明发生此异常的条件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>        <h3 id="2-3-变量和常量注释">          <a href="#2-3-变量和常量注释" class="heading-link"><i class="fas fa-link"></i></a>2.3 变量和常量注释</h3>      <p>下面几种情况下的常量和变量，都要添加注释说明，优先采用右侧 <code>//</code> 来注释，若注释说明太长则在上方添加注释。</p><ul><li>接口中定义的所有常量</li><li>公有类的公有常量</li><li>枚举类定义的所有枚举常量</li><li>实体类的所有属性变量</li></ul>        <h3 id="2-4-方法体内代码的注释">          <a href="#2-4-方法体内代码的注释" class="heading-link"><i class="fas fa-link"></i></a>2.4 方法体内代码的注释</h3>      <ul><li>方法内部单行注释，在被注释语句上方另起一行，使用 <code>//</code> 注释。</li><li>方法内部多行注释使用 <code>/* ... */</code> 注释。</li></ul><ul><li>注意与代码对齐，<code>*</code> 及 <code>//</code> 与其后文字之间空一格。</li><li>不要在方法内部使用 Javadoc 形式的注释。</li></ul>        <h3 id="2-5-其他一些注释">          <a href="#2-5-其他一些注释" class="heading-link"><i class="fas fa-link"></i></a>2.5 其他一些注释</h3>      <ul><li>资源文件代码注释</li></ul><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释内容 --&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>AS 已帮你集成了一些注释模板，我们只需要直接使用即可，在代码中输入<code>todo</code>、<code>fixme</code>等这些注释模板，回车后便会出现如下注释：</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 2017/8/28 需要实现，但目前还未实现的功能的说明</span></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> 2017/8/28 需要修正，甚至代码是错误的，不能工作，需要修复的说明</span></span><br></pre></td></tr></table></div></figure>        <h2 id="3-格式规范">          <a href="#3-格式规范" class="heading-link"><i class="fas fa-link"></i></a>3 格式规范</h2>              <h3 id="3-1-使用标准的大括号风格">          <a href="#3-1-使用标准的大括号风格" class="heading-link"><i class="fas fa-link"></i></a>3.1 使用标准的大括号风格</h3>      <ul><li>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</li><li>对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格（R &amp; N）<ul><li>左大括号前不换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行；否则不换行。例如，如果右大括号后面是 <code>else</code> 或 <code>catch</code>，则不换行。</li></ul></li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          something();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">          recover();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>&#123;&#125;</code>，不需要换行。</li></ul>        <h3 id="3-2-限制代码行的长度">          <a href="#3-2-限制代码行的长度" class="heading-link"><i class="fas fa-link"></i></a>3.2 限制代码行的长度</h3>      <ul><li>每行代码的长度不应该不超过 100 个字符。</li><li>例外：<code>package</code>和<code>import</code>语句，不换行。</li><li>例外：注释中包含了超过 100 个字符的命令示例或者 URL，为了便于剪切和复制，其长度可以超过 100 个字符。</li></ul>        <h3 id="3-3-合理空白">          <a href="#3-3-合理空白" class="heading-link"><i class="fas fa-link"></i></a>3.3 合理空白</h3>      <ul><li>垂直空白<ul><li>方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。</li></ul></li><li>水平空白<ul><li>左小括号和右小括号与字符之间不出现空格。</li><li><code>if/for/while/switch/do</code> 等保留字与括号之间都必须加空格。</li><li>任何二目、三目运算符的左右两边都需要加一个空格。</li><li>方法参数在定义和传入时，多个参数逗号后边必须加空格。</li><li>请使用快捷键 <code>ctrl + alt + L</code> 格式化代码。</li></ul></li></ul>        <h2 id="4-参考资料">          <a href="#4-参考资料" class="heading-link"><i class="fas fa-link"></i></a>4 参考资料</h2>      <ul><li><span class="exturl"><a class="exturl__link" href="http://www.hawstein.com/posts/google-java-style.html">Google Java编程风格指南</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=100001199&idx=1&sn=c47917de3a4acc2b15186149ee918b82&chksm=692938a05e5eb1b6e1e075a2012cd4e17f09e3b175da682c8491221c73627cb52bbcc6f99d14&scene=20#rd">阿里巴巴Java开发手册v1.2.0</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="http://jaeger.itscoder.com/android/2015/11/02/code-style-guideline-for-android.html">Android 编码规范</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://github.com/Blankj/AndroidStandardDevelop#4-%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%A7%84%E8%8C%83">Android 开发规范</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="http://xhrong.github.io/2017/01/12/Android%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Android 开发规范</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 编码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Intent 传递自定义对象</title>
      <link href="2017/08/17/android-intent-transfer-subject/"/>
      <url>2017/08/17/android-intent-transfer-subject/</url>
      
        <content type="html"><![CDATA[<p>Intent 可以用来启动活动、发送广播、启动服务等，通过 <code>putExtra</code> 方法可以添加一些附加数据，达到传值的效果，但若想传递自定义对象的时候就无能为力了。</p><p>可以通过使用 Serializable 接口、Parcelable 接口以及转换对象为字符串的方式进行传递。</p><p><strong>1、Serializable</strong></p><p>表示将一个对象转为字节实现可存储或可传输的状态，一个对象能够序列化的前提是实现 Serializable 接口。</p><p>Model：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>传递对象：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">&quot;wuzy&quot;</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, Main2Activity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;person_data&quot;</span>,person);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>接收对象：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = (Person) getIntent().getSerializableExtra(<span class="string">&quot;person_data&quot;</span>);</span><br></pre></td></tr></table></div></figure><p><strong>2、Parcelable</strong></p><p>将一个完整的对象进行分解，分解后的每一部分都是 Intent 所支持的数据类型。</p><p>Model：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将想要传递的数据写入到 Parcel 容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel parcel, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        parcel.writeString(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用于将写入 Parcel 容器中的数据读出来，用读出来的数据实例化一个对象，并且返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person();</span><br><span class="line">            person.setName(in.readString());</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建一个长度为 size 的数组并且返回,供外部类反序列化本类数组使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>传递对象：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">&quot;wuzy&quot;</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, Main2Activity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;person_data&quot;</span>,person);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>接收对象：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person =  getIntent().getParcelableExtra(<span class="string">&quot;person_data&quot;</span>);</span><br></pre></td></tr></table></div></figure><p><strong>3、转化为 JSON 字符串</strong></p><p>Model：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>传递对象：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">&quot;wuzy&quot;</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, Main2Activity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;person_data&quot;</span>,<span class="keyword">new</span> Gson().toJson(person));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure><p>接受对象：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String personJson = getIntent().getStringExtra(<span class="string">&quot;person_data&quot;</span>);</span><br><span class="line">Person person =  <span class="keyword">new</span> Gson().fromJson(personJson, Person.class);</span><br></pre></td></tr></table></div></figure><p><strong>速度上，使用Parcelable 速度最快，Serializable 次之，转换为 JSON 字符串最慢。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步、异步、回调及观察者模式</title>
      <link href="2017/08/15/synchronous-asynchronous-callback-and-observer-pattern/"/>
      <url>2017/08/15/synchronous-asynchronous-callback-and-observer-pattern/</url>
      
        <content type="html"><![CDATA[        <h3 id="1、同步调用">          <a href="#1、同步调用" class="heading-link"><i class="fas fa-link"></i></a>1、同步调用</h3>      <p>同步调用是最基本的调用方式，即类 A 的方法 a() 调用类 B 的方法 b()，一直等待方法 b() 执行结束，方法 a() 才继续往下走。这是一种阻塞调用， 适用于方法 b() 执行时间不长的情况，如果方法 b() 执行时间过长或者直接阻塞的话，方法 a() 的余下代码是无法执行下去的。</p>        <h3 id="2、异步调用">          <a href="#2、异步调用" class="heading-link"><i class="fas fa-link"></i></a>2、异步调用</h3>      <p>异步调用是为了解决同步调用存在阻塞情况而产生的一种调用方式。类 A 的方法 a() 通过创建新线程的方式调用类 B 的方法 b()，代码接着直接往下执行。这样方法 b() 在新线程中执行，就不会阻塞方法 a() 的执行。对于方法 a() 无需方法 b() 的返回结果，可以直接往下执行其他操作。对于需要方法 b() 的返回结果，通常可以借助回调机制实现。</p>        <h3 id="3、回调">          <a href="#3、回调" class="heading-link"><i class="fas fa-link"></i></a>3、回调</h3>      <p><strong>定义</strong>：</p><blockquote><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p></blockquote><p>函数指针对应于 Java 中的引用，使用更加简单。</p><p>Android 中的 Button 点击事件就是应用了回调机制，这其实就是回调最常见的应用场景之一。<strong>我们自己不会显式地去调用 onClick 方法。用户触发了该按钮的点击事件后，它会由 Android 系统来自动调用</strong>。</p><p><strong>原始代码</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">      Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;按钮被点击了。&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure><p><strong>模拟 Button 监听事件</strong>：</p><p><strong>监听接口</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyOnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>Button 类</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> </span>&#123;</span><br><span class="line">MyOnClickListener listener;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(MyOnClickListener listener)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 按钮被点击</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    listener.onClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>注册监听器和触发点击操作</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyButton button = <span class="keyword">new</span> MyButton();</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 注册监听器</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> MyOnClickListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;按钮被点击了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户点击按钮</span></span><br><span class="line">button.click();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>与原始 android 点击 Button 事件对比，可以发现原始 android 点击不需要调用 click 事件。这是为什么呢？</p><p>实际上，在源码中，当 android 系统检测到该 View 的 ACTION_UP 的操作时，会调用 performClick() 这个函数，而这个函数的内容如下：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  </span><br><span class="line">    <span class="keyword">if</span> (mOnClickListener != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);  </span><br><span class="line">        mOnClickListener.onClick(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></div></figure><p>只要 mOnClickListener 不为 null，那么 onClick 就会被调用。所以，它和模拟点击原理其实是一样的。</p>        <h3 id="4、观察者模式">          <a href="#4、观察者模式" class="heading-link"><i class="fas fa-link"></i></a>4、观察者模式</h3>      <p><strong>定义</strong>：</p><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p></blockquote><p><strong>观察者接口</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>主题对象</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;Observer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">lists.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Observer observer : lists) &#123;</span><br><span class="line">observer.update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">lists.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>注册更新观察者</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">subject.register(<span class="keyword">new</span> Observer() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;onserver 1 update&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.register(<span class="keyword">new</span> Observer() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;observer 2 update&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>这样看来，回调机制和观察者模式是一致的，区别是观察者模式里面目标类维护了所有观察者的引用，而回调里面只是维护了一个引用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 屏幕适配笔记</title>
      <link href="2017/08/02/android-screen-adaptation/"/>
      <url>2017/08/02/android-screen-adaptation/</url>
      
        <content type="html"><![CDATA[        <h2 id="基本概念">          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a>基本概念</h2>      <ul><li>in</li></ul><p>英寸，手机屏幕的物理尺寸。1 英寸等于 2.54cm。如果说手机屏幕是 5 寸，表示手机屏幕对角线长度为 5X2.54=12.7cm。</p><ul><li>px</li></ul><p>像素，英文单词 pixel 的缩写，屏幕上的点。常见的分辨率 320x480、480x800、720x1280、1080x1920 指的就是像素。</p><ul><li>dpi</li></ul><p>每英寸包含的像素个数，dots per inch 的缩写。比如 320X480 分辨率的手机，宽 2 英寸，高 3 英寸, 每英寸包含的像素点的数量为 320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi。</p><ul><li>density</li></ul><p>屏幕密度，density 和 dpi 的关系为 density = dpi/160。</p><ul><li>dp</li></ul><p>独立密度像素，density independent pixel 的缩写。在 Android 中，规定以 160dpi 为基准，1dip = 1px，如果密度是 320dpi，则1dp = 2px，以此类推。</p><ul><li>sp</li></ul><p>独立比例像素，scale independent pixel 的缩写。Android 中设置字体大小，不推荐奇数，容易造成精度丢失。</p>        <h2 id="解决方案">          <a href="#解决方案" class="heading-link"><i class="fas fa-link"></i></a>解决方案</h2>              <h3 id="使用-wrap-content、match-parent">          <a href="#使用-wrap-content、match-parent" class="heading-link"><i class="fas fa-link"></i></a>使用 wrap_content、match_parent</h3>      <p>要确保布局的灵活性并适应各种尺寸的屏幕，应该使用 “wrap_content” 和 “match_parent” 控制某些视图组件的宽度和高度。使用 “wrap_content”，系统就会将视图的宽度或高度设置成刚好能够包含视图中的内容，而 “match_parent”（在低于 API 级别 8 的级别中称为 “fill_parent”）则会让视图的宽和高延伸至充满整个父布局。</p>        <h3 id="使用-RelativeLayout">          <a href="#使用-RelativeLayout" class="heading-link"><i class="fas fa-link"></i></a>使用 RelativeLayout</h3>      <p>RelativeLayout 允许布局的子控件之间使用相对定位的方式控制控件的位置，比如可以让一个子视图居屏幕左侧对齐，让另一个子视图居屏幕右侧对齐。</p>        <h3 id="使用-Size-限定符">          <a href="#使用-Size-限定符" class="heading-link"><i class="fas fa-link"></i></a>使用 Size 限定符</h3>      <p>配置 Size 限定符允许程序在运行时根据当前设备的配置自动加载合适的资源（比如为不同尺寸屏幕设计不同的布局）。</p><p><code>res/layout/main.xml</code>，单面板（默认）布局：</p><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/headlines&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:name</span>=<span class="string">&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p><code>res/layout-large/main.xml</code>，双面板布局：</p><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/headlines&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:name</span>=<span class="string">&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/article&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:name</span>=<span class="string">&quot;com.example.android.newsreader.ArticleFragment&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>第二个布局的目录名中包含了 large 限定符，那些被定义为大屏的设备（比如 7 寸以上的平板）会自动加载此布局，而小屏设备会加载另一个默认的布局。</p>        <h3 id="使用-Smallest-width-限定符">          <a href="#使用-Smallest-width-限定符" class="heading-link"><i class="fas fa-link"></i></a>使用 Smallest-width 限定符</h3>      <p>Smallest-width 限定符允许设定一个具体的最小值(以 dp 为单位)来指定屏幕。例如，7 寸的平板最小宽度是 600dp。</p><p><code>res/layout/main.xml</code>，single-pane（默认）布局：</p><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/headlines&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:name</span>=<span class="string">&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p><code>res/layout-sw600dp/main.xml</code>，双面板布局：</p><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/headlines&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:name</span>=<span class="string">&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/article&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:name</span>=<span class="string">&quot;com.example.android.newsreader.ArticleFragment&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>那些最小屏幕宽度大于 600dp 的设备会选择 layout-sw600dp/main.xml(two-pane) 布局，而更小屏幕的设备将会选择 layout/main.xml(single-pane) 布局。Android 3.2 系统的设备无法识别 sw600dp 这个限定符，所以同时需要使用 large 限定符。</p>        <h3 id="使用布局别名">          <a href="#使用布局别名" class="heading-link"><i class="fas fa-link"></i></a>使用布局别名</h3>      <p>为了避免 Smallest-width 限定符为兼容 Android 3.2 之前系统而重复定义布局，可以使用布局别名技巧。</p><p>首先定义</p><ul><li>res/layout/main.xml，single-pane 布局</li><li>res/layout/main_twopanes.xml，two-pane 布局</li></ul><p>加入以下两个文件：</p><p><code>res/values-large/layout.xml</code>：</p><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span> <span class="attr">type</span>=<span class="string">&quot;layout&quot;</span>&gt;</span>@layout/main_twopanes<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span> </span><br></pre></td></tr></table></div></figure><p><code>res/values-sw600dp/layout.xml</code>：</p><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span> <span class="attr">type</span>=<span class="string">&quot;layout&quot;</span>&gt;</span>@layout/main_twopanes<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></div></figure>        <h3 id="使用-Orientation-限定符">          <a href="#使用-Orientation-限定符" class="heading-link"><i class="fas fa-link"></i></a>使用 Orientation 限定符</h3>      <p>根据屏幕方向进行布局的调整。</p>        <h3 id="使用-Nine-Patch-图片">          <a href="#使用-Nine-Patch-图片" class="heading-link"><i class="fas fa-link"></i></a>使用 Nine-Patch 图片</h3>      <p>支持不同屏幕大小通常情况下也意味着图片资源也需要有自适应的能力。例如，一个按钮的背景图片必须能够随着按钮大小的改变而改变。<br>使用 nine-patch 图片，它是一种被特殊处理过的 PNG 图片，可以指定哪些区域可以拉伸而哪些区域不可以。</p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><span class="exturl"><a class="exturl__link" href="http://blog.csdn.net/guolin_blog/article/details/8830286">http://blog.csdn.net/guolin_blog/article/details/8830286</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="http://blog.csdn.net/carson_ho/article/details/51234308">http://blog.csdn.net/carson_ho/article/details/51234308</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂方法模式</title>
      <link href="2017/06/15/factory-method-pattern/"/>
      <url>2017/06/15/factory-method-pattern/</url>
      
        <content type="html"><![CDATA[<p>简单工厂模式提供了专门的工厂类用于创建对象，实现了对象的创建和使用分离。但工厂类集中了所有产品对象的创建逻辑，职责过重；此外，如果增加新产品，需要修改工厂类的源代码，违背开闭原则。</p><p>工厂方法模式则可以很好的解决这一问题。在工厂方法模式中，不在提供统一的工厂类创建所有的产品对象，而是针对不同的产品提高不同的工厂。</p><p>模式结构图如下：</p><p><img src="/2017/06/15/factory-method-pattern/factory-method-pattern.jpg" alt="factory-method-pattern"></p><p>共包含以下 4 个角色：</p><ul><li>Product：定义产品的接口。也就是产品对象的公共父类。</li><li>ConcreteProduct：具体产品类，与具体工厂一一对应。</li><li>Factory：抽象工厂接口。它是工厂方法模式的核心。</li><li>ConcreteFactory：具体工厂类，返回一个具体产品类的实例。</li></ul><p><strong>工厂模式代码：</strong></p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;具体产品&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory  factory;</span><br><span class="line">Product product;</span><br><span class="line">factory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">product = factory.factoryMethod();</span><br><span class="line">product.productMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>工厂方法模式主要优点：</p><ul><li>用户只需要关心所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。</li><li>在系统中加入新产品时，无需修改抽象工厂和抽象产品接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，只需要加入一个具体工厂和具体产品就可以。系统的可扩展性非常好。</li></ul><p>主要缺点：</p><ul><li>添加新产品时，系统中类的个数成对增加，增加了系统的复杂性。同时，抽象层增加了系统的抽象性和理解难度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 插件推荐</title>
      <link href="2017/05/31/google-chrome-extension/"/>
      <url>2017/05/31/google-chrome-extension/</url>
      
        <content type="html"><![CDATA[<p>近些年来，在众多浏览器大战中，Google 的 Chrome 浏览器的市场份额位居首位，而且依然呈现高速增长趋势。Chrome 浏览器的优点不必多言，谁用谁知道。</p><p><img src="/2017/05/31/google-chrome-extension/chrome.jpg" alt="chrome"></p><p>这里主要推荐本人常用的 Chrome 插件，能够帮助你更加便捷高效的使用 Chrome 浏览器。</p><p>1、<span class="exturl"><a class="exturl__link" href="https://jasonsavard.com/zh-CN/Checker-Plus-for-Gmail">Checker Plus for Gmail™</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>这个插件的强大之处在于你无需打开 Gmail ，即可收到桌面邮件通知，方便地查看、撰写或删除邮件。</p><p><img src="/2017/05/31/google-chrome-extension/checker_plus_for_gmail.png" alt="checker_plus_for_gmail"></p><p>2、<span class="exturl"><a class="exturl__link" href="https://github.com/Selection-Translator/crx-selection-translate">划词翻译</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>支持谷歌、百度、有道、必应四大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。再也不用担心读不懂英文资料了。</p><p><img src="/2017/05/31/google-chrome-extension/translate.png" alt="translate"></p><p>3、<span class="exturl"><a class="exturl__link" href="https://www.one-tab.com/">OneTab</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>在 chrome 打开了很多窗口时，内存消耗大，对于配置较低的电脑可能会卡顿，但很多 tab 可能会用到，又不舍得关掉。这个时候你只需要点击 OneTab，就可以直接将所有 tab 回收，稍后重新打开 chrome 都能找到历史记录。</p><p><img src="/2017/05/31/google-chrome-extension/OneTab.png" alt="OneTab"></p><p>4、<span class="exturl"><a class="exturl__link" href="http://markdown-here.com/">Markdown Here</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>对于习惯使用 markdown 的人群来说，markdown 可能是写作的唯一方式。使用 Markdown Here 插件可以让你在 Gmail 中使用 markdown，让你写一封排版漂亮的电子邮件。不仅如此，Markdown Here 还支持 Evernote 和微信公众号。只需要在富文本区域按照 markdown 语法编辑，点击 Markdown Here图标进行转换，或者右键菜单进行 markdown 转换。当然能转换过去也能再转换回来继续编辑。</p><p><img src="/2017/05/31/google-chrome-extension/markdown_here.PNG" alt="markdown_here"></p><p>5、<span class="exturl"><a class="exturl__link" href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc">JSONView</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>通过 Chrome 查看服务器返回的 Json 格式的内容时，基本全是乱的。使用这个插件的好处是它自动排列出 Json 数据，可以很直观的查看数据格式，可谓开发者必备插件。</p><p><img src="/2017/05/31/google-chrome-extension/JSONView.png" alt="JSONView"></p><p>6、<span class="exturl"><a class="exturl__link" href="https://github.com/buunguyen/octotree">Octotree</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>这个插件能够直接在 Chrome 侧边栏查看 Github 项目文件夹，很方便、很实用。</p><p><img src="/2017/05/31/google-chrome-extension/octotree.png" alt="octotree"></p><p>7、<span class="exturl"><a class="exturl__link" href="https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj">Save to Pocket</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>Pocket 是一款稍后读软件，当你在浏览博客或者比较好的文章等，如果当时没有精力消化完，可以用这个插件保存到 Pocket 中，手机上的 Pocket 客户端会实时同步，你可以利用碎片化时间消化保存的知识。而且 Pocket 的阅读排版非常美观大方。<img src="/2017/05/31/google-chrome-extension/pocket.png" alt="pocket"></p><p>8、<span class="exturl"><a class="exturl__link" href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc">印象笔记·剪藏</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>最后，推荐「印象笔记·剪藏」。如果你使用印象笔记来记录笔记，肯定离不了这个插件，一键保存网页到印象笔记，即时同步到你的手机和电脑，不用复制粘贴编辑再整理。</p><p><img src="/2017/05/31/google-chrome-extension/evernote.png" alt="evernote"></p><p>这八个是我一直都在使用的插件，推荐给需要的看官。当然啦，Chrome 插件太多了，如果你有觉得不错的插件也可以推荐给我。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴树《猎户星座》</title>
      <link href="2017/04/29/orion/"/>
      <url>2017/04/29/orion/</url>
      
        <content type="html"><![CDATA[<p>朴树终于出新专辑了。专辑的名称叫《猎户星座》。4 月 28 号零点在网易云音乐预售数字专辑。</p><p><img src="/2017/04/29/orion/orion.png" alt="orion"></p><p>我第一次听到朴树的歌，是在 04 年，电视上播放丰田威驰的广告，放的就是朴树的 「Colorful Days」，当时觉得 MV 里的朴树酷极了。后来高中在学校，每个礼拜二和礼拜四下午放学后，校广播都会放 「Colorful Days」和 「生如夏花」。再后来上大学来到城市，耳边没有消失过的，总是他的歌。</p><p>这十多年，朴树一度沉寂，从公众视线中消失。我们这些歌迷一直都在等他，终于有幸看到他归来，热泪盈眶。</p><p>今天零点，新专辑第一首，「清白之年」公开，我在零点准时点开，歌曲平缓如徐徐微风，如潺潺流水从指间划走。今天白天再听来，感到一阵无奈哀伤，感叹时间一去不复返。</p><p>就如朴树吟唱：</p><blockquote><p>是不是生活太艰难<br>还是活色生香<br>我们都遍体鳞伤<br>也慢慢坏了心肠<br>你得到你想要的吗<br>换来的是铁石心肠<br>可曾还有什么人<br>再让你幻想</p><p>大风吹来了<br>我们随风飘荡<br>在风尘中熄灭的清澈目光<br>我想回头望<br>把故事从头讲<br>时光迟暮不返人生已不再来</p></blockquote><p>今天是五一小长假的第一天，哪也没去。一遍又一遍的聆听中。期待明天中午 11 点其他歌曲的公开。</p><p>感谢朴树。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之简单工厂模式</title>
      <link href="2017/04/26/simple-factory-pattern/"/>
      <url>2017/04/26/simple-factory-pattern/</url>
      
        <content type="html"><![CDATA[<p>简单工厂模式将有关创建和初始化产品对象的工作搬到一个工厂类中，客户端只需要根据参数调用工厂类的静态方法即可使用工厂类创建的产品对象，无需承担对象的创建工作。这样做的好处就是将对象的创建和使用分离开来，能够防止用来实例化一个类的数据和代码在多个客户端类中到处都是，利于系统维护。</p><p>模型结构图如下：</p><p><img src="/2017/04/26/simple-factory-pattern/simple_factory_pattern.png" alt="simple_factory_pattern"></p><p>其中包含以下几个角色：</p><ul><li><strong>Factory（工厂）</strong>：负责实现创建所有产品实例的内在逻辑。提供了静态方法便于外界直接调用。</li><li><strong>Product（抽象产品角色）</strong>：工厂创建所有产品对象的父类，封装了所有产品对象的公有方法。</li><li><strong>ConcreteProduct（具体产品角色）</strong>：每一个具体的产品对象，需要继承抽象产品角色。</li></ul><p>具体实现代码：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="comment">// 所有产品类的公共业务方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明抽象业务方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 ProductA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品类 ProductB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="comment">// 静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">Product product = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">product = <span class="keyword">new</span> ProductA();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">product = <span class="keyword">new</span> ProductB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Product product;</span><br><span class="line">product = Factory.createProduct(<span class="string">&quot;A&quot;</span>);  <span class="comment">// 通过工厂类创建产品对象</span></span><br><span class="line">product.methodSame();</span><br><span class="line">product.methodDiff();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>有时，为了简化工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类。</p><p><img src="/2017/04/26/simple-factory-pattern/simple-factory-pattern-2.png" alt="simple-factory-pattern-2"></p><p><strong>其主要缺点在于</strong>：</p><ul><li>工厂类集中了所有产品的创建逻辑，一旦不能正常工作，整个系统受到影响。</li><li>当引入新的产品，需要修改工厂类的源代码，违反了开闭原则。</li></ul><p>适用场景：</p><ul><li>产品对象较少，工厂方法的逻辑不会太复杂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="2017/04/24/singleton-pattern/"/>
      <url>2017/04/24/singleton-pattern/</url>
      
        <content type="html"><![CDATA[        <h2 id="什么是单例模式？">          <a href="#什么是单例模式？" class="heading-link"><i class="fas fa-link"></i></a>什么是单例模式？</h2>      <p>单例模式是一种对象创建型模式。所谓创建型模式就是将对象的创建和使用分离，在使用对象时无需关心对象的创建细节，从而降低系统的耦合度，使得设计方案更易于修改和扩展。</p><p>单例模式三个要点：（1）某个类只能有一个实例。（2）必须自行创建这个实例。（3）必须自行向整个系统提供这个实例。</p>        <h2 id="饿汉式单例类">          <a href="#饿汉式单例类" class="heading-link"><i class="fas fa-link"></i></a>饿汉式单例类</h2>      <p>类加载进来就直接实例化对象，无需考虑多线程安全问题，但是浪费资源严重。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// 类加载进入内存就创建单一的 instance 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line"><span class="comment">// 构造函数私有化，禁止外部类直接使用 new 来创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 提供一个全局的静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="懒汉式单例类">          <a href="#懒汉式单例类" class="heading-link"><i class="fas fa-link"></i></a>懒汉式单例类</h2>      <p>在第一次调用 <code>getInstance()</code> 方法时实例化，类加载时不自行实例化，在需要的时候再加载实例。但在多线程下会出现线程安全问题，可能会创建多个 instance 对象，违背了单例模式的初衷。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>为解决多线程问题，可以采用对 <code>getInstance()</code> 方法进行同步，但每次调用<code>getInstance()</code>方法都需要进行线程锁定判断，比较浪费资源，尤其在高并发访问环境下会导致系统性能大大降低。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 锁定 getInstance 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>事实上，无需对整个 <code>getInstance()</code> 方法锁定，只需要锁定代码 “ instance = new LazyInstance() ”。这种方法解决了浪费资源问题，但是在多线程下依然可能出现实例对象不唯一。原因在于：假如某一瞬间线程 A 和线程 B 都在调用<code>getInstance()</code> 方法，此时 instance 对象为 null，均能通过 “ instance == null ” 的判断。线程 A 进入 synchronized 锁定的代码中执行实例创建代码，线程 B 处于排队等待状态。当 A 执行完毕创建了实例后，线程 B 进入 synchronized 代码，此时 B 并不知道实例已经创建，将创建新的实例。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          syncronized(LazySingleton.class) &#123;    </span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();  </span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>因此还得进行改进，在 synchronized 锁定代码中再进行一次 “ instance == null ” 判断，这种方式称为<strong>双重检查锁定</strong> 。需要注意的是在需要在静态成员变量前加 <code>volatile</code> 修饰符。但 <code>volatile</code> 关键字会屏蔽 Java 虚拟机做的一些代码优化，导致系统运行效率降低。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一重判断</span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 锁定代码块</span></span><br><span class="line">          syncronized(LazySingleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二重判断</span></span><br><span class="line">              <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> LazySingleton();    </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="IoDH">          <a href="#IoDH" class="heading-link"><i class="fas fa-link"></i></a>IoDH</h2>      <p>饿汉式不能实现延迟加载，不管用不用，它始终占据内存；懒汉式 线程控制麻烦，而且性能受到影响。一种被称为 <code>Initialization on Demand Holder（IoDH）</code>的方法能够克服这些缺点。</p><p>静态单例对象没有作为 Singleton 的成员变量直接实例化，因此类加载时不会实例化 Singleton，第一次调用 <code>getInstance()</code> 时加载内部类 <code>HolderClass</code>，初始化 <code>instance</code>，由 Java 虚拟机保证其线程安全性，确保其只能初始化一次。</p><p>通过使用 IoDH，既可以实现延迟加载，又可以保证线程安全，不影响系统性能。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="参考资料">          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>      <p><span class="exturl"><a class="exturl__link" href="https://www.amazon.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93-%E5%88%98%E4%BC%9F/dp/B00ATKMX9M/ref=sr_1_4?ie=UTF8&qid=1357551589&sr=8-4">&lt;设计模式的艺术之道&gt;  刘伟</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客配置更新</title>
      <link href="2017/04/19/blog-configuration-update/"/>
      <url>2017/04/19/blog-configuration-update/</url>
      
        <content type="html"><![CDATA[<p>今天，将博客主题由 <span class="exturl"><a class="exturl__link" href="https://github.com/iissnan/hexo-theme-next">next</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 换成了  <span class="exturl"><a class="exturl__link" href="https://github.com/saintwinkle/hexo-theme-scribble">scribble</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，关于博客的安装和 next 主题的配置详见 <a href="http://wuzhangyang.com/2017/03/04/GitHub-Pages-Hexo-build-blog/">GitHub Pages + Hexo 搭建博客</a>。 然后对博客添加了些许功能。</p>        <h2 id="添加网易云跟帖">          <a href="#添加网易云跟帖" class="heading-link"><i class="fas fa-link"></i></a>添加网易云跟帖</h2>      <p>由于多说评论即将停用，所以添加了网易云跟帖作为博客的评论系统。</p><p>首先登录<span class="exturl"><a class="exturl__link" href="https://gentie.163.com/index.html">网易云跟帖</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，然后进入<code>后台管理</code>，填写<code>站点信息</code>，站点网址处需填自己申请的域名，填写 github.io 域名会提示站点名称或URL已经存在。 </p><p><img src="/2017/04/19/blog-configuration-update/zhandianxinxi.png" alt="zhandianxinxi"></p><p>然后点击<code>获取代码</code>，复制通用代码，拷贝至需要放置评论的位置即可。这里要注意本地服务器预览不到效果，部署后，才能看到评论。<br><img src="/2017/04/19/blog-configuration-update/huoqudaima.png" alt="huoqudaima"></p>        <h2 id="绑定独立域名">          <a href="#绑定独立域名" class="heading-link"><i class="fas fa-link"></i></a>绑定独立域名</h2>              <h3 id="购买域名">          <a href="#购买域名" class="heading-link"><i class="fas fa-link"></i></a>购买域名</h3>      <p>首先在<span class="exturl"><a class="exturl__link" href="https://wanwang.aliyun.com/">万网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上购买域名，当然也可以去 <span class="exturl"><a class="exturl__link" href="https://sg.godaddy.com/zh/">GoDaddy</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 购买。</p>        <h3 id="绑定域名与GitHub-Pages">          <a href="#绑定域名与GitHub-Pages" class="heading-link"><i class="fas fa-link"></i></a>绑定域名与GitHub Pages</h3>      <p>首先，修改域名的DNS地址为 <code>f1g1ns1.dnspod.net</code> 和 <code>f1g1ns2.dnspod.net</code> 。</p><p><img src="/2017/04/19/blog-configuration-update/modifyDNS.png" alt="modifyDNS"></p><p>然后在本地站点目录里的 <code>source</code> 目录下添加一个 <code>CNAME</code> 文件，不带后缀,文件名要大写。里面添加域名信息（不加 http）。如：<code>wuzhangyang.com</code> 。执行 <code>hexo d -g</code> 部署到 GitHub 上。</p><p>注册 <span class="exturl"><a class="exturl__link" href="https://www.dnspod.cn/">DNSPod</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>， 添加域名，添加记录。</p><p><img src="/2017/04/19/blog-configuration-update/addnotes.png" alt="addnotes"></p><blockquote><p>在记录中，<code>192.30.252.153</code> 与 <code>192.30.252.153</code> 是 Github Pages 服务器指定的 IP 地址。<br>记录类型为 CNAME，记录值是 <code>zywudev.github.io.</code> 。在记录值中.io后面还有一个小数点。</p></blockquote><p>最后把更改 deploy 到 GitHub 上。</p><p>到此，域名绑定好了，在 GitHub 博客仓库的 Settings 里面可以看见以下提示。</p><p><img src="/2017/04/19/blog-configuration-update/dns_success.png" alt="dns_success"></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017 第一季度</title>
      <link href="2017/04/10/first-quarter-of-2017/"/>
      <url>2017/04/10/first-quarter-of-2017/</url>
      
        <content type="html"><![CDATA[<p>今天是个好日子，与天气无关。</p><p>中午正准备午休，忽然收到吉林大学两位专家对毕业论文的盲审评价。</p><blockquote><p>“论文选题与本学科当前发展与经济建设、社会发展有较为密切的联系，有一定的理论意义。运用的理论知识、研究方法和实验手段符合实际情况，理论论证较严密，实验设计较合理，方法和数据较为正确可靠。反映出作者较好地掌握了基础理论和专业知识，反映出作者具有独立从事科研工作的能力。<br>论文观点正确，条理性好，层次清楚，有逻辑性，文笔较好，文字图表较规范。论文达到了硕士论文水平。同意参加论文答辩。”</p></blockquote><blockquote><p>“选题有一定的理论意义和比较好的应用价值，有一定的创新性。 创新点明确，对学科相关知识有一定的了解和把握，写作比较规范，内在逻辑比较好，可读性较好。是一个比较完整的研究工作”</p></blockquote><p>虽然知道这其中多为客套话，但心里一块石头终于落下，毕业工作能顺顺利利继续下去了。</p><p>今年的第一季度的总结本应前一两个礼拜就写好了，但是受到各种原因（还是拖延症）迟迟未静下心来去写。刚好今天收到了这个好消息，于是，在这绵绵细雨的下午，戴上耳机，把它完成吧。</p><p>回望这三个月，主要还是忙毕业论文的事情，花了一个多月把论文初稿写好，一不小心就被抽到盲审了，等到今天才出结果，中间还是挺担心的，毕竟要是盲审没通过影响就大了，还算幸运，顺顺利利。年初说今年要多看书，买了本 「人类简史」， 硬是拖到前几天才看完，拖延症真是不轻啊。这本书确实很值得一读，作者深厚的知识沉淀、惊人的想象力着实让人钦佩，读后受益不浅。后面抽时间写个总结。</p><p>这三个月来觉得最为有意义的一件事是加入了 stormzhang 的小密圈，花了 99 元大洋，但感觉非常值得。进圈一个月多以来，从中受益很多，也许是收费的原因，每天都会去上面看看，但主要原因还是圈子里的氛围非常好，过滤掉了一些键盘侠（闲杂人等）。</p><p>三个月来回老家一次，也就是前几天的清明节，虽然相隔并不远，但受到交通落后的影响，从上午 8 点多开始，倒腾了好几次车，到下午 3 点多才到家。到家时母亲端出早已准备好了的热腾腾的鸡汤，顿时感觉温暖幸福。其实回家也不只是为了吃好喝好。随着年纪的增长，能明显感觉到父母越来越像自己的朋友，不管大事小事，都愿意跟你分享，他们也希望孩子能跟他们分享。所以现在节假日，我都会选择回家，陪他们聊聊天，其乐融融。</p><p>时间总是在不经意间悄悄流去， 17 年已经过去 1/4 了。现在明显感觉到时间不够用，但似乎又感觉自己没什么进步各方面，有些迷茫。但迷茫也许意味着自己在进步吧。临近毕业，调整心态，提高执行力，继续前行。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Activity 生命周期</title>
      <link href="2017/03/21/activity-life-cycle/"/>
      <url>2017/03/21/activity-life-cycle/</url>
      
        <content type="html"><![CDATA[<p>本文目的在于详细总结 Activity 的生命周期。</p>        <h3 id="返回栈">          <a href="#返回栈" class="heading-link"><i class="fas fa-link"></i></a>返回栈</h3>      <p>Android 的 Activity 是可以层叠的，以返回栈（Back Stack）存放 Activity。默认情况下，当我们启动一个活动，它会在返回栈中入栈，处于栈顶的位置。当我们按下返回键或者调用 <code>finish()</code> 方法销毁一个活动，处于栈顶的活动会出栈，前一个入栈的活动会重新处于栈顶，用户看到的永远是栈顶的活动。</p>        <h3 id="Activity-四种状态">          <a href="#Activity-四种状态" class="heading-link"><i class="fas fa-link"></i></a>Activity 四种状态</h3>      <p><strong>运行</strong>：活动位于返回栈的栈顶，对用户可见。</p><p><strong>停止</strong>：该活动被另一活动完全遮盖，它对用户不可见，不再处于栈顶。在系统需要内存时可能会被终止。</p><p><strong>暂停</strong>：当一个活动不再处于栈顶，但此活动仍然可见。也就是说，另一个活动显示在此活动的上方，此活动部分透明或未覆盖整个屏幕。系统仍然会为这种活动保存相应的状态和成员变量，但并不可靠，在内存极低时，仍有可能被系统回收。</p><p><strong>销毁</strong>：当一个活动从返回栈中被移除。系统最愿意回收这种状态的活动。</p>        <h3 id="Activity-生存期">          <a href="#Activity-生存期" class="heading-link"><i class="fas fa-link"></i></a>Activity 生存期</h3>      <p>Activity 类定义了 7 个回调方法。</p><ul><li>**onCreate()**：首次创建活动时调用，初始化工作，加载布局、绑定事件。后接 <code>onStart()</code>。</li><li>**onStart()**：在活动即将对用户可见之前调用。后接 <code>onResume()</code>。</li><li>**onResume()**：在活动即将开始与用户进行交互之前调用，此时活动位于栈顶。后接 <code>onPause()</code>。</li><li>**onPause()**：当系统即将开始启动或恢复另一个活动时调用。如果活动返回前台，则后接 <code>onResume()</code>，如果活动转入对用户不可见状态，则后接 <code>onStop()</code>。</li><li>**onStop()**：当活动对用户不再可见时调用。如果活动恢复与用户的交互，则后接 <code>onRestart()</code>，如果活动被销毁，则后接 <code>onDestroy()</code>。</li><li>**onDestroy()**：在活动被销毁前调用。</li><li>**onRestart()**：在活动已停止并即将再次启动前调用。后接 <code>onStart()</code>。</li></ul><p><strong>整个生存期</strong>： 发生在 <code>onCreate()</code> 和 <code>onDestroy()</code> 之间。一般情况，活动会在 <code>onCreate()</code> 中做初始化工作，在 <code>onDestroy()</code> 中释放内存。</p><p><strong>可见生存期</strong>： 发生在 <code>onStart()</code> 和 <code>onStop()</code> 之间。活动对于用户始终可见，即便不能与用户交互。</p><p><strong>前台生存期</strong>：发生在 <code>onResume()</code> 和 <code>onPause()</code> 之间。活动始终处于运行状态。</p><p><span class="exturl"><a class="exturl__link" href="https://andr//developer.android.google.cn/guide/components/activities.html?hl=zh-cn">Android 官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>提供的 Activity 生命周期图如下图所示。</p><p><img src="/2017/03/21/activity-life-cycle/activity_lifecycle.png" alt="activity_lifecycle"></p>        <h2 id="Demo-实例">          <a href="#Demo-实例" class="heading-link"><i class="fas fa-link"></i></a>Demo 实例</h2>      <p>1、新建工程 ActivityLifeCycleTest。<br>2、创建两个子活动 NormalActivity 和 DialogActivity，其中 NormalActivity 是普通的 Activity，DialogActivity 是对话框式的 Activity，在 AndroidManifest.xml 中将 DialogActivity 使用对话框的主题。</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.DialogActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@android:style/Theme.Dialog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>3、在主活动的布局中添加两个按钮分别用于跳转到两个 Activity。在 MainActivity.java 中重写生命周期图中的七种方法。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vincent.activitylifecycletest;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button startNormalActivity = (Button) findViewById(R.id.start_normal_activity);</span><br><span class="line">        Button startDialogActivity = (Button) findViewById(R.id.start_dialog_activity);</span><br><span class="line"></span><br><span class="line">        startNormalActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, NormalActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        startDialogActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, DialogActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onResume&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onStop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onDestroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onRestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>运行工程，主窗口如下左图所示，两个按钮分别用于启动 NormalActivity 和 DialogActivity。<br><img src="/2017/03/21/activity-life-cycle/activity_lifecycle_demo.png" alt="activity_lifecycle_demo"></p><ol><li>启动程序首次进入 MainActivity，依次执行了 <code>onCreate() - onStart() - onResume()</code> 方法。</li><li>点击 Start NormalActivity，跳转到 NormalActivity （上图中），依次执行了 <code>onPause() - onStop()</code> 方法。</li><li>按下返回键，依次执行了 <code>onRestart() - onStart() - onResume()</code> 方法。</li><li>点击 Start DialogActivity, 跳出 DialogActivity (上图右），执行了 <code>onPause()</code> 方法。</li><li>按下返回键，执行了 <code>onResume()</code> 方法。</li><li>再按下返回键，依次执行 <code>onPause() - onStop() - onDestroy()</code> 方法。</li></ol><p><img src="/2017/03/21/activity-life-cycle/lifecyclelogcat.png" alt="lifecyclelogcat"></p>        <h2 id="参考">          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>      <ul><li><span class="exturl"><a class="exturl__link" href="https://developer.android.google.cn/guide/components/activities.html?hl=zh-cn">Android官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" href="https://www.amazon.cn/dp/B01MSR5D04">&lt;第一行代码&gt; 郭霖</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 命令备忘</title>
      <link href="2017/03/15/git-common-command/"/>
      <url>2017/03/15/git-common-command/</url>
      
        <content type="html"><![CDATA[<p>对 Git 常用命令归类总结，方便查阅。</p>        <h2 id="Git-配置">          <a href="#Git-配置" class="heading-link"><i class="fas fa-link"></i></a>Git 配置</h2>      <figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;zywudev&quot; # 全局用户名</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;zywu.dev@gmail.com&quot; # 全局邮箱</span><br><span class="line"></span><br><span class="line">git config user.name &quot;zywudev&quot; # 某一个项目使用特地的用户名 </span><br><span class="line"></span><br><span class="line">git config user.email &quot;zywu.dev@gmail.com&quot; # 某一个项目使用特地的邮箱</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout # 别名</span><br><span class="line"></span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%</span></span><br><span class="line">d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot; # 日志</span><br><span class="line"></span><br><span class="line">git config --global color.ui true # git 着色</span><br><span class="line"></span><br><span class="line">git config --global core.quotepath false # 设置显示中文文件名</span><br></pre></td></tr></table></div></figure>        <h2 id="Git-常用命令">          <a href="#Git-常用命令" class="heading-link"><i class="fas fa-link"></i></a>Git 常用命令</h2>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">git # 查看 git 是否安装成功</span><br><span class="line"></span><br><span class="line">git init # 初始化仓库</span><br><span class="line"></span><br><span class="line">git status # 仓库状态</span><br><span class="line"></span><br><span class="line">git add &lt;file&gt; # 将文件添加到暂存区</span><br><span class="line"></span><br><span class="line">git add . # 将所有修改过的文件添加到暂存区</span><br><span class="line"></span><br><span class="line">git rm --cached  # 删除缓存，但不删除文件</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; # 删除文件</span><br><span class="line"></span><br><span class="line">git commit -m “first commit” # 提交</span><br><span class="line"></span><br><span class="line">git log # 可以查看所有产生的 commit 记录</span><br><span class="line"></span><br><span class="line">git tag v1.0 # 给当前代码打标签</span><br><span class="line"></span><br><span class="line">git tag # 查看历史 tag 记录</span><br><span class="line"></span><br><span class="line">git checkout v1.0 # 切换到 v1.0 的代码状态</span><br><span class="line"></span><br><span class="line">git diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异</span><br><span class="line"></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较</span><br><span class="line"></span><br><span class="line">git diff --staged # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git checkout -&lt;file&gt;   # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git checkout . # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git stash # 当前分支暂存</span><br><span class="line"></span><br><span class="line">git stash list # 列所有stash</span><br><span class="line"></span><br><span class="line">git stash apply # 恢复暂存的内容</span><br><span class="line"></span><br><span class="line">git stash drop # 删除暂存区（删除一条）</span><br><span class="line"></span><br><span class="line">git stash clear # 清空暂存区</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h2 id="分支管理">          <a href="#分支管理" class="heading-link"><i class="fas fa-link"></i></a>分支管理</h2>      <figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git branch # 查看分支情况</span><br><span class="line"></span><br><span class="line">git branch a # 新建 a 分支</span><br><span class="line"></span><br><span class="line">git checkout a # 切换到 a 分支</span><br><span class="line"></span><br><span class="line">git checkout -b a # 新建 a 分支 自动切换到 a 分支</span><br><span class="line"></span><br><span class="line">git merge a # 将 a 分支合并到当前分支</span><br><span class="line"></span><br><span class="line">git branch -d a # 删除 a 分支，a 分支已被合并</span><br><span class="line"></span><br><span class="line">git branch -D a # 删除 a 分支，a 分支未被合并</span><br><span class="line"></span><br><span class="line">git branch -r # 查看远程分支列表</span><br><span class="line"></span><br><span class="line">git push origin:&lt;branch&gt; # 删除远程分支</span><br><span class="line"></span><br><span class="line">git checkout a origin/a # 本地没有 a 分支的情况下，将远程 a 分支迁到本地</span><br><span class="line"></span><br><span class="line">git checkout -b a origin/a # 把远程分支迁到本地顺便切换到该分支：</span><br></pre></td></tr></table></div></figure>        <h2 id="远程管理">          <a href="#远程管理" class="heading-link"><i class="fas fa-link"></i></a>远程管理</h2>      <figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git push origin master # 把本地代码推到远程 master 分支</span><br><span class="line"></span><br><span class="line">git pull origin master # 把远程 master 代码更新到本地</span><br><span class="line"></span><br><span class="line">git clone git@github.com:zywudev/weather.git # 远程 test 项目 clone 到本地</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:zywudev/test.git # 本地已用项目与远程test项目关联，提交到远程test项目</span><br><span class="line"></span><br><span class="line">git remote -v # 查看当前项目有哪些远程仓库</span><br><span class="line"></span><br><span class="line">git remote show origin # 查看远程服务器仓库状态</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages + Hexo 搭建博客</title>
      <link href="2017/03/04/GitHub-Pages-Hexo-build-blog/"/>
      <url>2017/03/04/GitHub-Pages-Hexo-build-blog/</url>
      
        <content type="html"><![CDATA[<p>第一篇博客，记录一下博客搭建过程。</p>        <h2 id="安装-node-js">          <a href="#安装-node-js" class="heading-link"><i class="fas fa-link"></i></a>安装 node.js</h2>      <p><span class="exturl"><a class="exturl__link" href="https://nodejs.org/en/">node.js</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="安装-Git">          <a href="#安装-Git" class="heading-link"><i class="fas fa-link"></i></a>安装 Git</h2>      <p><span class="exturl"><a class="exturl__link" href="https://git-scm.com/downloads">Git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="安装-Hexo">          <a href="#安装-Hexo" class="heading-link"><i class="fas fa-link"></i></a>安装 Hexo</h2>      <p>在文件夹中建立名为 <code>hexo</code> 的文件夹，右键打开 Git Bush，使用 npm 安装 Hexo。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></div></figure><p>初始化 blog， Hexo 自动在 blog 文件夹下创建网站所需文件。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></div></figure><p>进入 blog 文件夹，安装依赖包。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></div></figure><p>生成静态页面</p><figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 或 hexo generate </span><br></pre></td></tr></table></div></figure><p>启动本地 web 服务</p><figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s # 或 hexo server</span><br></pre></td></tr></table></div></figure><p>此时在浏览器地址栏中键入 <span class="exturl"><a class="exturl__link" href="http://localhost:4000/">http://localhost:4000/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ， 可以看到内置的页面。</p><p><img src="/2017/03/04/GitHub-Pages-Hexo-build-blog/hexo-init-page.png" alt="hexo-init-page"></p>        <h2 id="GitHub-Pages-设置">          <a href="#GitHub-Pages-设置" class="heading-link"><i class="fas fa-link"></i></a>GitHub Pages 设置</h2>      <p>注册 GitHub 及其使用可以参考 <span class="exturl"><a class="exturl__link" href="http://stormzhang.com/github/2016/06/19/learn-github-from-zero-summary/">从 0 开始学习 GITHUB 系列汇总</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p>在 GitHub 上创建仓库，而且仓库的名字格式为： <code>username.github.io</code>，username 与 GitHub 账号名对应，每个帐号只能有一个仓库来存放个人主页。可以通过 <span class="exturl"><a class="exturl__link" href="http://username.github.io/">http://username.github.io</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 来访问个人主页。</p>        <h2 id="部署-Hexo-到-GitHub-Pages">          <a href="#部署-Hexo-到-GitHub-Pages" class="heading-link"><i class="fas fa-link"></i></a>部署 Hexo 到 GitHub Pages</h2>      <p>其实就是将 Hexo 生成的静态页面提交 (git commit) 到 GitHub 上。</p><p>在 Hexo 根目录下的配置文件 <code>_config.yml</code> 中进行修改:</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git<span class="meta">@github</span>.com:zywudev/zywudev.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></div></figure><p>还得安装一个扩展</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></div></figure><p>然后在命令行部署</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></div></figure>        <h2 id="Hexo-主题基本配置">          <a href="#Hexo-主题基本配置" class="heading-link"><i class="fas fa-link"></i></a>Hexo 主题基本配置</h2>      <p>选择喜欢的主题。Hexo 官网<span class="exturl"><a class="exturl__link" href="https://hexo.io/themes/">主题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。我的博客选用的是 NexT 主题，官方提供了详细的<span class="exturl"><a class="exturl__link" href="http://theme-next.iissnan.com/">使用文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>        <h3 id="下载-NexT-主题">          <a href="#下载-NexT-主题" class="heading-link"><i class="fas fa-link"></i></a>下载 NexT 主题</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></div></figure>        <h3 id="启用-NexT-主题">          <a href="#启用-NexT-主题" class="heading-link"><i class="fas fa-link"></i></a>启用 NexT 主题</h3>      <p>克隆完成后，打开站点配置文件 <code>__config.yml</code>，找到 <code>theme</code> 字段，修改为：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></div></figure><blockquote><p>站点配置文件：博客目录下的 <code>__config.yml</code> 文件。</p></blockquote><blockquote><p>主题配置文件： <code>themes/next</code> 目录下的 <code>__config.yml</code> 文件。</p></blockquote>        <h3 id="启动本地-web-服务验证">          <a href="#启动本地-web-服务验证" class="heading-link"><i class="fas fa-link"></i></a>启动本地 web 服务验证</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></div></figure><p>至此，即完成了基于 GitHub Pages + Hexo 的个人博客框架搭建。</p>        <h2 id="博客推广">          <a href="#博客推广" class="heading-link"><i class="fas fa-link"></i></a>博客推广</h2>      <p>将个人博客推广到 Google 搜索引擎上。</p>        <h3 id="验证网站">          <a href="#验证网站" class="heading-link"><i class="fas fa-link"></i></a>验证网站</h3>      <p>推荐文件验证。</p><p>下载 HTML 验证文件，将该文件放到博客 source 目录下。</p><p>hexo 编译文件时，会给下载的 HTML 文件中添加其他的内容，导致验证失败，所以需要在文件开头添加 layout: false 来取消 hexo 对其进行的转换。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout: <span class="keyword">false</span>   ---</span><br><span class="line">google-site-verification: googleb6fc53a32f5418d9.html</span><br></pre></td></tr></table></div></figure><p>部署到 GitHub，输入<span class="exturl"><a class="exturl__link" href="https://zywudev.github.io/googleb6fc53a32f5418d9.html">https://zywudev.github.io/googleb6fc53a32f5418d9.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ， 能访问即可点击验证按钮进行验证。</p>        <h3 id="站点地图">          <a href="#站点地图" class="heading-link"><i class="fas fa-link"></i></a>站点地图</h3>      <blockquote><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知 Google 和其他搜索引擎。Google 等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p></blockquote><p>使用 hexo-generator-sitemap 插件来生成 Sitemap，执行</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></div></figure><p>执行</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></div></figure><p>博客根目录的public下面生成了 <code>sitemap.xml</code> 。如果没有，在博客目录的 <code>_config.yml</code> 中添加如下代码重新编译</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br></pre></td></tr></table></div></figure><p>要将博客目录 <code>__config.yml</code> 中的 url 字段设置为自己的域名</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: http:<span class="comment">//zywudev.github.io</span></span><br></pre></td></tr></table></div></figure><p>部署到 Github，访问 <span class="exturl"><a class="exturl__link" href="https://zywudev.github.io/sitemap.xml">https://zywudev.github.io/sitemap.xml</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p>提交 sitemap 到 <span class="exturl"><a class="exturl__link" href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google站长工具</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，找到添加站点地图按钮，添加 <code>sitemap.xml</code> 即可，如下图。</p><p><img src="/2017/03/04/GitHub-Pages-Hexo-build-blog/google-sitemap.png" alt="google-sitemap"></p>        <h2 id="博客优化">          <a href="#博客优化" class="heading-link"><i class="fas fa-link"></i></a>博客优化</h2>              <h3 id="添加-about-页面">          <a href="#添加-about-页面" class="heading-link"><i class="fas fa-link"></i></a>添加 about 页面</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;about&quot;</span> </span><br></pre></td></tr></table></div></figure><p>在 <code>\source\about\</code> 目录下会生成一个 <code>index.md</code> 文件,添加个人信息即可。</p>        <h3 id="添加分类、标签页面">          <a href="#添加分类、标签页面" class="heading-link"><i class="fas fa-link"></i></a>添加分类、标签页面</h3>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;categories&quot;</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;tags&quot;</span> </span><br></pre></td></tr></table></div></figure>        <h3 id="博客标题、作者等">          <a href="#博客标题、作者等" class="heading-link"><i class="fas fa-link"></i></a>博客标题、作者等</h3>      <p>打开站点配置文件</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: Wu<span class="string">&#x27;s blog </span></span><br><span class="line"><span class="string">subtitle:</span></span><br><span class="line"><span class="string">description: O ever youthful,O ever weeping</span></span><br><span class="line"><span class="string">author: Wu </span></span><br><span class="line"><span class="string">language: zh-Hans</span></span><br><span class="line"><span class="string">timezone:</span></span><br></pre></td></tr></table></div></figure>        <h3 id="修改文章内文本链接样式">          <a href="#修改文章内文本链接样式" class="heading-link"><i class="fas fa-link"></i></a>修改文章内文本链接样式</h3>      <p>将文本链接设置为蓝色，修改<br><code>themes\next\source\css\_common\components\post\post.styl</code>,<br>添加</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #0477ab;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="修改博客-logo">          <a href="#修改博客-logo" class="heading-link"><i class="fas fa-link"></i></a>修改博客 logo</h3>      <p>通过网站 <span class="exturl"><a class="exturl__link" href="http://tool.lu/favicon/">favicon在线制作</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 网站制作 favicon 图片。</p><p>将图片放在博客 <code>source</code> 目录下即可。</p>        <h3 id="添加-Fork-me-on-GitHub-挂件">          <a href="#添加-Fork-me-on-GitHub-挂件" class="heading-link"><i class="fas fa-link"></i></a>添加 Fork me on GitHub 挂件</h3>      <p>在<span class="exturl"><a class="exturl__link" href="https://github.com/blog/273-github-ribbons">官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>选取样式。</p><p>拷贝代码，修改 href 地址为自己的 GitHub 地址</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://github.com/you&quot;</span>&gt;</span><br><span class="line">改为：</span><br><span class="line">&lt;a href=<span class="string">&quot;https://github.com/zywudev&quot;</span>&gt;</span><br></pre></td></tr></table></div></figure><p>修改文件: <code>themes/next/layout/_layout.swig</code>，将代码拷贝至对应位置。</p><figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% include <span class="string">&#x27;_scripts/third-party/analytics.swig&#x27;</span> %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; &quot;</span>&gt;</span><br><span class="line">    &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--------------add Fork me on GitHub -------------&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;a href=&quot;https://github.com/zywudev&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--------------add Fork me on GitHub -------------&gt;</span><br><span class="line"></span><br><span class="line">    &lt;header id=<span class="string">&quot;header&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;header&quot;</span> itemscope itemtype=<span class="string">&quot;http://schema.org/WPHeader&quot;</span>&gt;</span><br><span class="line">      &lt;div class=&quot;header-inner&quot;&gt; &#123;%- include &#x27;_partials/header.swig&#x27; %&#125; &lt;/div&gt;</span><br><span class="line">    &lt;/header&gt;</span><br></pre></td></tr></table></div></figure>        <h2 id="参考链接">          <a href="#参考链接" class="heading-link"><i class="fas fa-link"></i></a>参考链接</h2>      <p><span class="exturl"><a class="exturl__link" href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/">手把手教你使用Hexo + Github Pages搭建个人独立博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="http://selfboot.cn/2014/12/21/add_blog_to_google/#%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE">博客推广——提交搜索引擎</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> GitHub Pages </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
