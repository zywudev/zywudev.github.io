<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="贾小昆">
<meta property="og:url" content="http://wuzhangyang.com/page/3/index.html">
<meta property="og:site_name" content="贾小昆">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="贾小昆">
<meta name="twitter:card" content="summary"><title>贾小昆</title><link ref="canonical" href="http://wuzhangyang.com/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><script src="https://www.googletagmanager.com/gtag/js?id=UA-127464210-1" async=""></script><script>if (window.location.hostname !== 'localhost') {
  window.dataLayer = window.dataLayer || [];
  function gtag(){ dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-127464210-1');
}</script><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.1.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/11/23/weekly-issue-3/">每周分享第 3 期</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-11-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">782</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">4分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p> 这里记录过去一周，我看到的值得分享的内容。 </p>
<p><img src="/2019/11/23/weekly-issue-3/titu.jpg" alt="titu"></p>
<p>（题图：合肥翡翠湖）</p>

        <h2 id="文章">
          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ylgfdjRzwAzhiRKGp6lFSQ">我以前在阿里巴巴的流量方法论</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>流量为王，可能对你有所启发。</p>
<p>2、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Z_Ut2nOUEFywSD064E0dDg">吕先生的三个贵人</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>中华灵芝宝、双灵固本散、绿谷灵芝宝，你耳熟能详的东西，但可能并不真正了解真相。</p>
<p>3、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://opensource.com/article/19/10/why-switch-mac-linux">为什么我从 Mac 换到了 Linux</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<blockquote>
<p>它激发了我重新潜入的乐趣，我享受这段旅途的乐趣。 </p>
</blockquote>

        <h2 id="资源">
          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://pan.baidu.com/s/1jXvXwQYPtJa5kcektcqJSA">9 大技术领域，1500+道面试题出炉！（资源版）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>阿里技术特别策划。</p>
<p>2、分享一波安卓面试资料</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/u014803701/article/details/81381491">2019 Android 面试题汇总（面试总结全） </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.im/entry/5a1548f7f265da43310d77e2">2018最新安卓面试大全（含BAT，网易，滴滴）—-你面不上BAT的原因：面经宝典，都在这里啦 - Android - 掘金</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.im/post/5c0f39fa6fb9a04a0d56b19f">Android面试整理(附答案) - 掘金</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.im/entry/57bd3a4a2e958a00694b5bcf">还原最真实最完整的一线公司面试题 - 阅读 - 掘金</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.cnblogs.com/aademeng/articles/11079455.html">Android 面试资料集锦 - 天涯海角路 - 博客园</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>

        <h2 id="言论">
          <a href="#言论" class="heading-link"><i class="fas fa-link"></i></a>言论</h2>
      <p>1、</p>
<p>我来到推特以后，才发现不管怎么沟通，一半人总是会讨厌另一半人。 </p>
<p>–  迈克尔·阿灵顿 </p>
<p>2、</p>
<p> 关于钱的几个原则： </p>
<p>1）、不要贪婪，挣自己该挣的钱 </p>
<p>2）、遵守契约，说好了就遵守约定</p>
<p>3）、掌握挣钱的能力比你现在有钱好很多。因为钱随时会没有啊。 </p>
<p>4）、大部分挫折长期来看都是小问题 </p>
<p>– 池建强</p>
<p>3、</p>
<p> “叮铃铃铃……”一阵清脆的铃声惊醒了哥的美梦，关上了 8848 钛金手机闹表，哥从床上缓缓爬了起来，熟练的穿上了脊柱整形明星产品背背佳，下地穿上了内含骨正基鞋垫的足力健老人鞋，嗯，浑身都暖和起来了。哥走了几步，感觉昨天做完火疗之后背痛症状没啥缓解，还不如前天的酸碱平 dds 治疗仪，“算了，可能是疗程不够！”哥心想着，拿出了一瓶本草清液吸了起来，一边打开了 e 人 e 本高端电脑，看了看股市，又咒骂了一番。嗯，这个产品味道还不赖，跟沙棘雪莲果饮料差不太多。哥心满意足的拔出吸管，咂摸着滋味。哎呀，都怪昨天小李，非得让哥多喝几杯鸿茅药酒，整得哥还有些许头晕，差点忘了服用极草 5x 含片。这含片没吃，燕之屋碗燕也喝不下去了，不知道会不会影响胶原蛋白的吸收，搞不好紫草精油还得续一个疗程。正想着，小罐茶茶具里的水沸腾了，哥赶紧拿出大师精心炒制的大红袍，晃了晃，听说好听就好茶。坐在碧玺温灸床垫上，手捧着茶杯，哥不禁感叹人生，所谓成功也不过如此吧！ </p>
<p>——公众号读者「蜗牛的新微信号」留言 </p>
<p>4、</p>
<p> 真正的发现之旅不在于寻找新的土地，而在于用新的眼光来看待。</p>
<p>– <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.age-of-the-sage.org/quotations/proust_having_seeing_with_new_eyes.html">Marcel Proust</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/11/19/android-interview-6-anr/">Android 面试题（6）：谈谈你对 ANR 的了解？</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">883</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="什么是-ANR">
          <a href="#什么是-ANR" class="heading-link"><i class="fas fa-link"></i></a>什么是 ANR</h2>
      <p>ANR(Application Not responding)，即应用程序无响应，简单来说，就是用户界面突然卡住，无法响应用户的操作（比如触摸事件）。</p>
<p>Android 系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成 ANR。一般情况下，ANR 后会弹出一个提示框，告知用户当前应用无响应，用户可选择继续等待或者关闭应用。</p>
<p><img src="/2019/11/19/android-interview-6-anr/anr_dialog.png"></p>

        <h2 id="出现场景">
          <a href="#出现场景" class="heading-link"><i class="fas fa-link"></i></a>出现场景</h2>
      <ul>
<li><p><strong>InputDispatching Timeout</strong>：5 秒内无法响应屏幕触摸事件或键盘输入事件。</p>
</li>
<li><p><strong>BroadcastQueue Timeout</strong> ：在执行前台广播（BroadcastReceiver）的<code>onReceive()</code>函数时  10s 没有处理完成，后台为 60s。</p>
</li>
<li><p><strong>Service Timeout</strong> ：前台服务 20s 内，后台服务在 200s 内没有执行完毕。</p>
</li>
<li><p><strong>ContentProvider Timeout</strong> ：ContentProvider的 publish 在 10s 内没进行完。</p>
</li>
</ul>

        <h2 id="如何避免">
          <a href="#如何避免" class="heading-link"><i class="fas fa-link"></i></a>如何避免</h2>
      <p>基本的思路就是将 IO 操作在工作线程来处理，减少其他耗时操作和错误操作。比如网络请求、Socket 通信、SQL操作、文件读写和或者有可能阻塞 UI 线程的操作放在子线程。</p>

        <h2 id="ANR-分析">
          <a href="#ANR-分析" class="heading-link"><i class="fas fa-link"></i></a>ANR 分析</h2>
      <p>ANR 发生时 Logcat 会打印类似下面的日志：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/com.wuzy.anrtest I/zygote64: Thread[3,tid=6428,WaitingInMainSignalCatcherLoop,Thread*=0x7b3965ca00,peer=0x171c0020,&quot;Signal Catcher&quot;]: reacting to signal 3</span><br><span class="line">/com.wuzy.anrtest I/zygote64: Wrote stack traces to &#x27;/data/anr/traces.txt&#x27;</span><br><span class="line">/com.wuzy.anrtest I/Choreographer: Skipped 6000 frames!  The application may be doing too much work on its main thread.</span><br></pre></td></tr></table></div></figure>

<p>每次产生 ANR 之后，系统都会向<code>/data/anr/traces.txt</code>中写入新的日志数据。</p>
<p>获取日志的命令：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cat /data/anr/traces.txt &gt; /mnt/sdcard/traces.txt</span><br><span class="line">exit</span><br><span class="line">adb pull /sdcard/traces.txt</span><br></pre></td></tr></table></div></figure>

<p>这里我模拟一个 ANR 情况，在按钮点击事件中调用 <code>Thread.sleep</code>，查看 traces 文件内容，可以看到线程名、线程优先级、线程 ID、线程状态和 ANR 的原因。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----- pid 13872 at 2019-11-14 15:18:50 -----</span><br><span class="line">Cmd line: com.wuzy.anrtest</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&quot;main&quot; prio=5 tid=1 Sleeping</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x735f1ad0 self=0x7b396a3a00</span><br><span class="line">  | sysTid=13872 nice=-10 cgrp=default sched=0/0 handle=0x7b3e6f69b0</span><br><span class="line">  | state=S schedstat=( 832049486 21080201 432 ) utm=77 stm=6 core=5 HZ=100</span><br><span class="line">  | stack=0x7fe0065000-0x7fe0067000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Thread.sleep(Native method)</span><br><span class="line">  - sleeping on &lt;0x026e2fdc&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:386)</span><br><span class="line">  - locked &lt;0x026e2fdc&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:327)</span><br><span class="line">  at com.wuzy.anrtest.MainActivity$1.onClick(MainActivity.java:19)</span><br><span class="line">  at android.view.View.performClick(View.java:6291)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:24931)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:808)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:101)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:166)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:7523)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:245)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:921)</span><br></pre></td></tr></table></div></figure>


        <h2 id="ANR-监测机制">
          <a href="#ANR-监测机制" class="heading-link"><i class="fas fa-link"></i></a>ANR 监测机制</h2>
      <p>Android 应用程序是通过消息来驱动的，Android 某种意义上也可以说成是一个以消息驱动的系统，UI、事件、生命周期都和消息处理机制息息相关。Android 的 ANR 监测机制也是一样，大部分就是利用了 Android 的消息机制。 </p>
<p><img src="/2019/11/19/android-interview-6-anr/anr.png"></p>
<p>在 Android 中，实际上是系统服务在控制每个组件的生命周期回调，所以可以在这个逻辑入口开始计时，利用 Handler 机制，发生延时消息，如果超时了，就处理 ANR 事件消息，如果没有超时，就取消队列里的延时消息，也就不会出现 ANR。</p>
<p>具体源码细节，推荐阅读：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://gityuan.com/2019/04/06/android-anr/">彻底理解安卓应用无响应机制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://gityuan.com/2016/12/02/app-not-response/">理解Android ANR的信息收集过程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/11/16/weekly-issue-2/">每周分享第 2 期</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-11-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">8分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>这里记录过去一周，我看到的值得分享的内容。</p>
<p><a href="weekly-issue-2/titu.jpg"><img src="/2019/11/16/weekly-issue-2/titu.jpg" alt="titu"></a></p>
<p>（题图：J. Berengar Sölter ）</p>

        <h2 id="文章">
          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NjIUtuHg_T58ZsZZaPHZCA">我们在淘宝京东拼多多买东西时，有哪些价格歧视？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>作者在京东工作，对平台和商家的一些商业套路比较了解。文章深入介绍了价格歧视的原理，商家使用的价格歧视策略。</p>
<p>2、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7IHIGAIrqtyQN4FjhuNjxQ">淘宝 1 小时交易额破千亿！</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>作者在双 11 前使用天猫历年交易额，做了一个多项式的拟合，预测了今年双 11 的交易额是 2692 亿，最终的结果是 2684 亿 ，不得不说，非常神奇。</p>
<p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/tianmao.jpg"><img src="/2019/11/16/weekly-issue-2/tianmao.jpg" alt="img"></a></p>
<p>3、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/iVqNKb6M1SfMD3FBOoGjDQ">想砍死北野武的女人们</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>文章介绍了北野武戏剧性的一生，值得一看。</p>
<p>“ 我认为，一个人是不是长大成熟，由他对父母的感情方式来判定。当你面对父母，觉得他们很不容易时，就是迈向成熟的第一步。”</p>
<p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/beiyewu.jpg"><img src="/2019/11/16/weekly-issue-2/beiyewu.jpg" alt="img"></a></p>
<p>4、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xh1paOC54FwsPxxXVcc_HA">做人，就做这样的人</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>人的一生，到底要怎么度过，如果你感到迷茫，充满焦虑，没有方向，可以看看这篇文章。</p>

        <h2 id="工具">
          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://aospxref.com/">AOSPXRef</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Android 源码在线阅读网站，支持交叉引用跳转，服务器在国内，访问速度很快。</p>
<p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/aospxref.png"><img src="/2019/11/16/weekly-issue-2/aospxref.png" alt="img"></a></p>
<p>2、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/pd4d10/octohint">octohint</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>一款浏览器插件，在 GitHub 上浏览代码时能够快速定位变量出现或声明的位置。</p>
<p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/octohint.jpg"><img src="/2019/11/16/weekly-issue-2/octohint.jpg" alt="img"></a></p>
<p>3、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/mobile">GitHub Mobile</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>GitHub 发布首款官方手机客户端应用，目前只要 ios 的 App，安卓版本暂未发布。</p>
<p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/github_mobile.png"><img src="/2019/11/16/weekly-issue-2/github_mobile.png" alt="github_mobile"></a></p>

        <h2 id="资源">
          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a>资源</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018626163">服务端高并发分布式架构演进之路</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>文章以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p>
<p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/server.png"><img src="/2019/11/16/weekly-issue-2/server.png" alt="img"></a></p>
<p>2、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/jlevy/the-art-of-command-line">命令行的艺术</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。</p>
<p>3、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/flutterchina/flutter-in-action">Flutter 实战</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>由浅入深的介绍了 Flutter 技术和开发流程。</p>
<p><a href="http://wuzhangyang.com/2019/11/16/weekly-issue-2/flutter.jpg"><img src="/2019/11/16/weekly-issue-2/flutter.jpg" alt="flutter"></a></p>
<p>4、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">正则表达式手册</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>网站包含正则表达式全集和常见正则表达式。</p>
<p>5、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/">GeeksforGeeks</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>这个网站包含了大量计算机相关的问题和解答，许多问题都有形象的图表和源代码。</p>
<p>6、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://howhttps.works/">HOW HTTPS WORKS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>这个网站用图解的方式把 HTTP 相关的问题都说明得一清二楚，生动形象。如果你对 Http 不够熟悉，不妨看一下，肯定会很有收获的。</p>

        <h2 id="摘录">
          <a href="#摘录" class="heading-link"><i class="fas fa-link"></i></a>摘录</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://m.xsshuku.com/files/article/html/17/17145/2517893.html">司汤达在 1806 年致波丽娜的信中</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，给波丽娜的几点建议：</p>
<blockquote>
<p>以下是我着力要培养的习惯。</p>
<p>1.锻炼身体。</p>
<p>2.调侃邪恶之人和无聊之人的才能。</p>
<p>3.选择一个工作，并从中培养习惯。为达到这点，必须悉心寻找自己的主要热情所在。</p>
<p>4.承受得住悲伤。</p>
<p>5.不要过分夸大自己无法体味的幸福。</p>
<p>6.当上前与一个人攀谈时要自问：“他需要什么？”而不是索要什么。</p>
<p>7.简洁的习惯。</p>
<p>研习对人体有益的食物，并养成食用的习惯。反复温习上述几条，仔细思考一下以下三条警句：</p>
<p>1.习惯于伤悲，每个人每天都会经历七八件伤悲的事。</p>
<p>2.不要过分夸大不属于自己的幸福。</p>
<p>3.学会顶住各种艰难的时刻，致力于完善我们的思想以及知晓事理的艺术。</p>
<p>关于以上三条警句的思索几乎囊括了幸福的含义。</p>
</blockquote>
<p>2、北野武一些好玩的言论</p>
<blockquote>
<p>1.他离婚之后接受采访，北野武说：</p>
<p>「今年真是没啥好事，我的钱都没了，没钱后朋友都联络不上了。曝光后情妇也没了。<br>早知道这么难，不如和前妻在一起。」</p>
<p>2.他还有个很出名的渣男语录，逻辑非常奇妙，是这样说的：</p>
<p>「尽管没多大意思，但情人还是越多越好的。</p>
<p>如果只有一个情人，就会形成一种三角关系，而三角关系就是一种有棱角的关系。如果有两个呢，就是四角关系。三个呢，五角关系……</p>
<p>照此类推，情人越多，关系就越接近于圆，棱角也就越少。这样的话，彼此间的摩擦和风波也会减少。」</p>
<p>3.北野武踏入电视圈之后，没想到路异常的顺利。他对此的感想是：</p>
<p>「幸好没才华的人这么多，让这件事没有想象中复杂。」</p>
<p>4.有一次，北野武的后辈又吉直树2015年时得了芥川奖，他很直接地说：</p>
<p>「这可把我气坏了。当时我就想，那样的东西我也能写出来，我一定要让人惊讶原来北野武也能写出这样的东西。」</p>
<p>后来呢，纯粹为了赌气，他竟然真的写了一本纯爱小说！[允悲]</p>
<p>5.在拔除从右脸横穿左脸的器械时，他在书里这样写：</p>
<p>我能感觉到金属棒在鼻子底下一点一点地挪出去，同时还发出嘎吱嘎吱的声音，那声音就像金属棒把我的脑汁也一并带了出来。</p>
<p>我说了句：「我现在完全理解了关东煮的心情。」</p>
<p>结果被医生怒斥：「别说蠢话！」</p>
<p>6.在某个他拍摄的广告发布会上，主持人热场：<br>「今天闪光灯真的多得让人睁不开眼啦。」</p>
<p>北野武：「嗯，特别像艺人外遇被曝光后的道歉记者发布会…….」</p>
<p>7.在欧洲，人们不知道他还是个喜剧演员，以为他是个很出名的黑帮分子。<br>有一次，他受英国电影协会邀请飞去伦敦，协会会长到机场接他，一路上诚惶诚恐。</p>
<p>「为您准备的豪华轿车突然发生故障，所以只好用这种车子来接您了，实在对不起。请您多包涵。」</p>
<p>他说自己几年之后才知道为什么会长是这种态度，他们成了好朋友之后会长告诉他：</p>
<p>「当时我心里真是吓得要死，怕你会为此杀了我。<br>因为我以为你是日本的黑帮头子。」</p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/11/13/android-interview-5-handler/">Android 面试题（5）：谈谈 Handler 机制和原理？</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-11-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">14分</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>这一系列文章致力于为 Android 开发者查漏补缺，准备面试。</p>
<p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p>
<p>由于笔者水平有限，总结的内容难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p>
</blockquote>

        <h2 id="1、说一下-Handler-消息机制中涉及到哪些类，各自的功能是什么？">
          <a href="#1、说一下-Handler-消息机制中涉及到哪些类，各自的功能是什么？" class="heading-link"><i class="fas fa-link"></i></a>1、说一下 Handler 消息机制中涉及到哪些类，各自的功能是什么？</h2>
      <p>Handler 主要用于跨线程通信。涉及MessageQueue/Message/Looper/Handler 这 4 个类。 </p>
<ul>
<li><p>Message：消息，分为硬件产生的消息和软件生成的消息。</p>
</li>
<li><p>MessageQueue：消息队列，主要功能是向消息池投递信息 (<code>MessageQueue.enqueueMessage</code>) 和取走消息池的信息 (<code>MessageQueue.next</code>) 。</p>
</li>
<li><p>Handler：消息处理者，负责向消息池中发送消息 (<code>Handler.enqueueMessage</code>) 和处理消息 (<code>Handler.handleMessage</code>) 。</p>
</li>
<li><p>Looper：消息泵，不断循环执行 (<code>Looper.loop</code>) ，按分发机制将消息分发给目标处理者。</p>
</li>
</ul>
<p>它们之间的类关系：</p>
<p>Looper 有一个 MessageQueue 消息队列；MessageQueue 有一组待处理的 Message；Message 中有一个用于处理消息的 Handler；Handler 中有 Looper 和 MessageQueue。</p>
<p><img src="/2019/11/13/android-interview-5-handler/handler_main.jpg" alt="图片来源 gityuan"></p>

        <h2 id="2、一个线程可以有几个-Looper、几个-MessageQueue-和几个-Handler？">
          <a href="#2、一个线程可以有几个-Looper、几个-MessageQueue-和几个-Handler？" class="heading-link"><i class="fas fa-link"></i></a>2、一个线程可以有几个 Looper、几个 MessageQueue 和几个 Handler？</h2>
      <p>在 Android 中，Looper 类利用了 ThreadLocal 的特性，保证了每个线程只存在一个 Looper 对象。</p>
<p>关于 ThreadLocal 可以看这篇文章：<a href="http://wuzhangyang.com/2019/02/19/threadlocal/">理解 ThreadLocal</a></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Looper 构造函数中创建了 MessageQueue 对象，因此一个线程只有一个 MessageQueue。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以有多个 Handler。</p>
<p>Handler 在创建时与 Looper 和 MessageQueue 关联起来：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Handler 发送消息是将消息传递给 MessageQueue：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>注意 <code>msg.target = this;</code>， 这里将当前的 Handler 赋值给 Message 对象，在后面处理消息时就能依据 msg.target 区分不同的 Handler。</p>

        <h2 id="3、可以在子线程直接创建一个-Handler-吗？会出现什么问题，那该怎么做？">
          <a href="#3、可以在子线程直接创建一个-Handler-吗？会出现什么问题，那该怎么做？" class="heading-link"><i class="fas fa-link"></i></a>3、可以在子线程直接创建一个 Handler 吗？会出现什么问题，那该怎么做？</h2>
      <p>不能在子线程直接 new 一个 Handler。因为 Handler 的工作依赖于 Looper，而 Looper 又是属于某一个线程的，其他线程不能访问，所以在线程中使用 Handler 时必须要保证当前线程中 Looper 对象并且启动循环。不然会抛出异常。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread() + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>正确做法是：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();   <span class="comment">// 为线程创建 Looper 对象</span></span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();   <span class="comment">// 启动消息循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4、既然线程中创建-Handler-时需要-Looper-对象，为什么主线程不用调用-Looper-prepare-创建-Looper-对象？">
          <a href="#4、既然线程中创建-Handler-时需要-Looper-对象，为什么主线程不用调用-Looper-prepare-创建-Looper-对象？" class="heading-link"><i class="fas fa-link"></i></a>4、既然线程中创建 Handler 时需要 Looper 对象，为什么主线程不用调用 Looper.prepare() 创建 Looper 对象？</h2>
      <p>在 App 启动的时候系统默认启动了一个主线程的 Looper（ActivityThread 的 <code>main</code> 方法中），<code>Loop.prepareMainLooper</code> 方法也是调用了 <code>Looper.prepare</code>方法，里面会创建一个不可退出的 Looper, 并 <code>set</code> 到 sThreadLocal 对象当中。 </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="5、-Looper-死循环为什么不会导致应用卡死，会消耗大量资源吗？">
          <a href="#5、-Looper-死循环为什么不会导致应用卡死，会消耗大量资源吗？" class="heading-link"><i class="fas fa-link"></i></a>5、 Looper 死循环为什么不会导致应用卡死，会消耗大量资源吗？</h2>
      <p>引用 Gityuan :</p>
<blockquote>
<p>对于线程即是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder 线程也是采用死循环的方法，通过循环方式不同与 Binder 驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。真正会卡死主线程的操作是在回调方法 onCreate/onStart/onResume 等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。</p>
</blockquote>
<blockquote>
<p>主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到 Linux pipe/epoll 机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 Loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步 I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量 CPU 资源。</p>
</blockquote>
<p>详细解答：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.zhihu.com/question/34652589">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="6、-MessageQueue-是队列吗？它是什么数据结构？">
          <a href="#6、-MessageQueue-是队列吗？它是什么数据结构？" class="heading-link"><i class="fas fa-link"></i></a>6、 MessageQueue 是队列吗？它是什么数据结构？</h2>
      <p>MessageQueue 不是队列，它内部使用一个 Message 链表实现消息的存和取。 链表的排列依据是  <code>Message.when</code>，表示 Message 期望被分发的时间，该值是 <code>SystemClock. uptimeMillis()</code> 与 <code>delayMillis</code> 之和。 </p>
<p>##7、 <code>handler.postDelayed()</code> 函数延时执行计时是否准确？</p>
<p>当上一个消息存在耗时任务的时候，会占用延时任务执行的时机，实际延迟时间可能会超过预设延时时间，这时候就不准确了。</p>
<p>##8、 你对 IdleHandler 有多少了解? </p>
<p>IdleHandler 是一个接口， 这个接口方法是在消息队列全部处理完成后或者是在阻塞的过程中等待更多的消息的时候调用的，返回值 false 表示只回调一次，true 表示可以接收多次回调。 </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<p>##9、 你了解 HandlerThread 吗?</p>
<p>HandlerThread 继承自 Thread，它是一种可以使用 Handler 的 Thread，它的实现也很简单，在 <code>run</code>方法中也是通过 <code>Looper.prepare()</code> 来创建消息队列，并通过<code>Looper.loop()</code>来开启消息循环（与我们手动创建方法基本一致），这样在实际的使用中就允许在 HandlerThread 中创建 Handler 了。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>由于 HandlerThread 的<code>run</code>方法是一个无限循环，因此当不需要使用的时候通过<code>quit</code>或者<code>quitSafely</code>方法来终止线程的执行。</p>
<p>##10、 你对 <code>Message.obtain()</code> 了解吗, 或者你知道怎么维护消息池吗 ？</p>
<p> <code>Message.obtain()</code>  是从消息池取 Message，消息池其实是使用 Message 链表结构实现，消息池默认最大值 50。 <code>Message.obtain()</code>  每次都是把消息池表头的 Message 取走 ，再把表头指向 next。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;  <span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清除in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(); <span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>消息在 loop 中被 handler 分发消费之后会执行回收的操作，将该消息内部数据清空并添加到消息链表的表头。 </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123; <span class="comment">//判断消息是否正在使用</span></span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123; <span class="comment">//Android 5.0以后的版本默认为true,之前的版本默认为false.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将消息标示位置为IN_USE，并清空消息所有的参数。</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++; <span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>最后，关于 Handler 的详细分析推荐阅读 Gityuan 的文章。</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://gityuan.com/2015/12/26/handler-message-framework/">Android消息机制1-Handler(Java层)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://gityuan.com/2015/12/27/handler-message-native/">Android消息机制2-Handler(Native层)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://gityuan.com/2016/01/01/handler-message-usage/">Android消息机制3-Handler(实战)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/11/09/weekly-issue-1/">每周分享第 1 期</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-11-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">8分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>这里记录过去一周，我看到的值得分享的内容。 </p>
<p><img src="/2019/11/09/weekly-issue-1/titu.jpg" alt="titu"></p>
<p>（题图：大学一角，2019.10）</p>
<p>非常喜欢阮一峰老师的<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/ruanyf/weekly" title="科技互联网周刊">科技互联网周刊</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，增长了不少见识，也很佩服阮老师的坚持。信息爆炸的时代，能够阅读到优质内容很不容易。</p>
<p>受阮老师的启发，将每周看到的优质内容分享出来，应该挺有价值的。其实，分享本身就是一件有趣有意义的事。</p>

        <h2 id="文章">
          <a href="#文章" class="heading-link"><i class="fas fa-link"></i></a>文章</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5WzCzb6MHsLVa13tQppUdA">GQ报道 | 幸存者李佳琦：一个人变成算法，又想回到人</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>万字长文，GQ 带你走近当事人李佳琦，也许和你想象的不一样。</p>
<p>“李佳琦”这个符号是这台精密齿轮上最关键的部件，他也无法停止直播：“我不播了，那外面我的同事们怎么办？” 外面的同事怎么办？</p>
<p>2、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/w8qCG-amQe6dm5yoY9jxbA">你适合搞副业么？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>其实搞副业这事，如小马过河，有的适合，有的不适合，因人而异。有的人副业发达，甚至副业转正。有的人捡了副业的芝麻丢了主业的西瓜，明显得不偿失。有的人为了追求副业收益被人狠狠收割。 </p>
<p>3、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NcDfRcK8ZC38mJh3IKmeig">这些年我从互联网收获的三桶金和五点感悟</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>别人的路也许复制不了，但是思维模式可以学习借鉴。</p>
<p>4、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VmKsttIccfhA45TJQzPmxw">为刘润公号读者写了600多篇文章后，说说我的4点感悟</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>写作是每个人都应该学习的技能。</p>
<p>5、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/b_BXZNXR9tS2ct3AdHeaGg">华为的“信任危机”</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>华为应该是今年最受关注的公司，这次华为 HR 胡玲发表在华为心声社区的实名控诉信，也再一次让华为成为舆论的热点。</p>

        <h2 id="寓言">
          <a href="#寓言" class="heading-link"><i class="fas fa-link"></i></a>寓言</h2>
      <p>1、小马过河</p>
<p>马棚里住着一匹老马和一匹小马。</p>
<p>有一天，老马对小马说：“你已经长大了，能帮妈妈做点事吗？”小马连蹦带跳地说：“怎么不能？我很愿意帮您做事。”老马高兴地说：“那好哇，你把这半口袋麦子驮到磨坊去吧。”</p>
<p>小马驮起麦子，飞快地往磨坊跑去。跑着跑着，一条小河挡住了去路，河水哗哗地流着。小马为难了，心想：我能不能过去呢？如果妈妈在身边，问问她该怎么办，那多好哇！</p>
<p>他向四周望望，看见一头老牛在河边吃草。小马嗒嗒嗒跑过去，问道：“牛伯伯，请您告诉我，这条河，我能趟过去吗？”老牛说：“水很浅，刚没小腿，能趟过去。”</p>
<p>小马听了老牛的话，立刻跑到河边，准备趟过去。突然，从树上跳下一只松鼠，拦住他大叫：“小马，别过河，别过河，河水会淹死你的！”小马吃惊地问：“水很深吗？”松鼠认真地说：“深得很呢！昨天，我的一个伙伴就是掉进这条河里淹死的！”</p>
<p>小马连忙收住脚步，不知道怎么办才好。他叹了口气，说：“唉！还是回家问问妈妈吧！”</p>
<p>小马甩甩尾巴，跑回家去。妈妈问：“怎么回来啦？”小马难为情地说：“一条河挡住了，我……我过不去。”妈妈说：“那条河不是很浅吗？”小马说：“是啊！牛伯伯也这么说。可是松鼠说河水很深，还淹死过他的伙伴呢！”妈妈说：“那么河水到底是深还是浅？你仔细想过他们的话吗？”小马低下了头，说：“没……没想过。”妈妈亲切地对小马说：“孩子，光听别人说，自己不动脑筋，不去试试，是不行的。河水是深是浅，你去试一试就会明白了。”</p>
<p>小马跑到河边，刚刚抬起前蹄，松鼠又大叫起来：“怎么，你不要命啦！”小马说：“让我试试吧。”他下了河，小心地趟了过去。原来河水既不像老牛说的那样浅，也不像松鼠说的那样深。 </p>
<p>2、父子骑驴</p>
<p>在一个炎热的下午，一位父亲带着他儿子和一头驴走过满足灰尘的街。</p>
<p>父亲骑在驴上，儿子牵着它走。“可怜的孩子，”一位路人说道，“这个人怎能心安理得地骑在驴背上…”</p>
<p>父亲听到之后，就从驴背上下来让儿子坐上去。但走了没多久，又一位路人的声音传来“多么不孝。可怜的老父亲却在一旁跟着跑。小孩子听了之后连忙让父亲也坐在驴背上。</p>
<p>“你们谁见过这种事”一位妇女说道，“这么残酷地对待动物，可怜的驴子的背在下陷，而这个老家伙和他的儿子却悠然自得。”</p>
<p>父子俩闻言，只好从驴背上爬下来。但是，他们徒步走没多远，又一个陌生人笑着说：“我才不会这么蠢，放着好好的驴不用，却用脚来走。”</p>
<p>最后，人们看到这对父子俩抬着这头驴从街头走过。</p>

        <h2 id="工具">
          <a href="#工具" class="heading-link"><i class="fas fa-link"></i></a>工具</h2>
      <p>1、<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mdnice.com/" title="markdown-nice">markdown-nice</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>支持自定义样式的微信 Markdown 排版工具，可能是目前最好用的。</p>

        <h2 id="言论">
          <a href="#言论" class="heading-link"><i class="fas fa-link"></i></a>言论</h2>
      <p>1、</p>
<p>人呐，往往一辈子要利还要名，就为个光宗耀祖。</p>
<p>– 三表龙门阵《<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/R0UVe6WlFntJLQirKAU3qQ">李佳琦的阶级欲望</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>》</p>
<p>2、</p>
<p>大家 955 的时候，有些聪明人觉得如果自己 996 那么裁掉的就是别人了。结果聪明人太多了。</p>
<p>3、</p>
<p>你妈不知道的，你知道的，叫网红。 </p>
<p>你妈知道的，你也知道的，叫明星。</p>
<p>你妈知道的，你知道的，你姥姥也知道的，叫大明星。</p>
<p>你妈知道的，你不知道的，叫过气明星。</p>
<p>– 三表龙门阵《<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/R0UVe6WlFntJLQirKAU3qQ">李佳琦的阶级欲望</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>》</p>
<p>4、</p>
<p>计算机行业是个很有活力的行业，这个行业创造了很多让人羡慕的职位，比如：1）命令行运维（能够在十个以上的终端窗口来回切换输入命令还不出错）；2）功能程序员（能够一个月做10个以上的功能）；3）周报经理（能够把周报写得左手一条龙右手一个彩虹）；4）PPT架构师（能够在PPT上把架构画成顶尖水平）；5）JS全栈工程师（只掌握JS一门语言，有百年以上足够的耐心等待JS成为所有软件的语言）；6）三句话产品经理（能够下面用三句话就能让开发把产品实现出来，比如：你我们的竞对有！客户就是要！告诉我能不能做？）</p>
<p>– 左耳朵耗子</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/11/06/android-interview-4-launcher-mode/">Android 面试题（4）：谈谈 Activity 的启动模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-11-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">5.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">46分</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p>
<p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p>
<p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p>
</blockquote>
<p>众所周知，Activity 有 4 种启动模式，分别是：standard、singleTop、singleTask 和 singleInstance，它们控制了 Activity 的启动行为，不同的启动模式使用于不同的应用场景。</p>
<p>启动的 Activity 会放在任务栈中，任务栈是一种后进先出的结构，按 Back 键的时候栈顶 Activity 会从任务栈中返回，当任务栈为空时系统就会回收这个任务栈。 </p>
<p>本文将通过具体 Demo，详细分析这几种模式的差异和使用场景。</p>

        <h2 id="standard-标准模式">
          <a href="#standard-标准模式" class="heading-link"><i class="fas fa-link"></i></a>standard 标准模式</h2>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;standard&quot;</span><br></pre></td></tr></table></div></figure>

<p>Activity 默认的启动模式，每次启动都会创建新的实例，不管这个实例是否已经存在于任务栈。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动顺序</span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容（adb shell dumpsys activity activities）</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b4e290f #18017 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;1666db1 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18017&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;17fa3e6 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18017&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;9e18184 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18017&#125;</span><br></pre></td></tr></table></div></figure>

<p>启动两次 StandardActivity 会创建两个 StandardActivity 的实例对象。</p>
<p><strong>使用场景</strong>：</p>
<p>在一系列启动 Activity 的过程中需要保留用户操作的 Activity 的页面。比如： 社交应用中，点击查看用户 A 信息 -&gt; 查看用户 A 粉丝 -&gt; 在粉丝中挑选查看用户 B 信息 -&gt; 查看用户 B 粉丝。</p>

        <h2 id="singleTop-栈顶复用模式">
          <a href="#singleTop-栈顶复用模式" class="heading-link"><i class="fas fa-link"></i></a>singleTop 栈顶复用模式</h2>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;singleTop&quot;</span><br></pre></td></tr></table></div></figure>

<p>singleTop 与 standard 几乎一样，使用 singleTop 的 Activity 也可以创建多个实例。不同点在于，如果启动的 Activity 已经位于任务栈的栈顶，则不需要创建新的实例，直接复用栈顶的 Activity 实例，intent 通过 Activity 的<code>onNewIntent</code> 方法传递到这个 Activity 。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">例 1：</span><br><span class="line">&#x2F;&#x2F; 启动顺序</span><br><span class="line">MainActivity -&gt; SingleTopActivity -&gt; SingleTopActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;9de11c2 #18073 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;f0acc0c u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTopActivity t18073&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b884d57 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18073&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">例 2：</span><br><span class="line">&#x2F;&#x2F; 启动顺序</span><br><span class="line">MainActivity -&gt; SingleTopActivity -&gt; StandardActivity -&gt; SingleTopActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;9de11c2 #18073 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;4&#125;</span><br><span class="line">    Run #3: ActivityRecord&#123;c282b33 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTopActivity t18073&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;76fb23e u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18073&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;b6969a8 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTopActivity t18073&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b884d57 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18073&#125;</span><br></pre></td></tr></table></div></figure>

<p>例 1 中由于栈顶已经是 SingleTopActivity，再启动 SingleTopActivity 时直接复用了栈顶 Activity，无需创建新的实例。</p>
<p>例 2 中第二次启动 SingleTopActivity 时，由于栈顶是 StandardActivity，所以启动 SingleTopActivity 时会创建新的实例。</p>
<p><strong>使用场景</strong>：</p>
<p>假设你在当前的 Activity 中又要启动同类型的 Activity，此时建议将此类型 Activity 的启动模式指定为 singleTop，能够减少 Activity 的创建，节省内存。</p>

        <h2 id="singleTask-栈内复用模式">
          <a href="#singleTask-栈内复用模式" class="heading-link"><i class="fas fa-link"></i></a>singleTask 栈内复用模式</h2>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;singleTask&quot; </span><br></pre></td></tr></table></div></figure>

<p>singleTask 标记的 Activity 是栈内复用模式，如果当前任务栈内没有这个 Activity，那么创建新的 Activity，如果当前任务栈内有这个 Activity，不管它在任务栈的哪个位置，都会直接复用这个 Activity，这个 Activity 上面的其他的 Activity 都被移出栈， intent 通过 <code>onNewIntent</code> 传递到这个 Activity 。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容：</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;ebb2593 #18095 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;49b6bb8 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18095&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;48628d2 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskActivity t18095&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;86fe71f u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18095&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskActivity -&gt; StandardActivity -&gt; SingleTaskActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;ebb2593 #18095 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;48628d2 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskActivity t18095&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;86fe71f u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18095&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到，在第二次启动 SingleTaskActivity 时，由于栈内已经存在了 SingleTaskActivity  实例，栈顶 StandardActivity 被移出任务栈，复用了栈内 SingleTaskActivity 实例。</p>
<p>当以 singleTask 启动一个 Activity 的时候，首先去判断是否要为该 Activity 去创建一个任务栈？如果需要的话，那么就会创建一个任务栈，并且将该 Activity 放入栈中；如果不需要的话，直接将该 Activity 放入当前的任务栈中。 </p>
<p>那么如何判断要不要为 singleTask Activity 创建一个任务栈？</p>
<p>任务栈的创建跟 taskAffinity 的属性相关，每个 Activity 都有 taskAffinity 属性，这个属性指出了它希望进入的任务栈。如果一个 Activity 没有显式的指明该 Activity 的 taskAffinity，那么它的这个属性就等于 Application 指明的 taskAffinity，如果 Application 也没有指明，那么该 taskAffinity 的值就等于包名。</p>
<p>这里我指定一下 Activity 的 taskAffinity ：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SingleTaskWithAffinityActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;SingleTaskWithAffinity Activity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.jaqen&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>看一下测试结果：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 任务栈</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;fa7e695 #18097 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;6267f33 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskWithAffinityActivity t18097&#125;</span><br><span class="line">    TaskRecord&#123;efcc3aa #18096 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;ccdada8 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18096&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskWithAffinityActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;3f4af35 #18097 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;23b4c1a u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18097&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;d234ee0 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskWithAffinityActivity t18097&#125;</span><br><span class="line">    TaskRecord&#123;e27d53b #18096 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;f445d23 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18096&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动顺序</span><br><span class="line">MainActivity -&gt; SingleTaskWithAffinityActivity -&gt; StandardActivity -&gt; SingleTaskWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;3f4af35 #18097 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;d234ee0 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleTaskWithAffinityActivity t18097&#125;</span><br><span class="line">    TaskRecord&#123;e27d53b #18096 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;f445d23 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18096&#125;</span><br></pre></td></tr></table></div></figure>

<p>首次启动 SingleTaskWithAffinityActivity 会创建新的任务栈（<em>大括号内 <code>#</code> 后的数字标识任务栈 id</em>）。</p>
<p>在 SingleTaskWithAffinityActivity 启动 StandardActivity ， 这个 StandardActivity 与 SingleTaskWithAffinityActivity 在同一个栈。</p>
<p>SingleTaskWithAffinityActivity  会出现在多任务界面。</p>
<p>第二次启动 SingleTopActivity 时直接复用了栈内已存 Activity，已存 Activity 上的 Activity 被移出任务栈。</p>
<p><strong>使用场景</strong>：</p>
<p>一般应用主页面可以用 singleTask 方式。比如用户在主页跳转到其他页面，运行多次操作后想返回到主页。</p>

        <h2 id="singleInstance-单实例模式">
          <a href="#singleInstance-单实例模式" class="heading-link"><i class="fas fa-link"></i></a>singleInstance 单实例模式</h2>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=&quot;singleInstance&quot;</span><br></pre></td></tr></table></div></figure>

<p>singleInstance 与 singleTask 类似，在应用都只存在一个实例，不同点在于存放 singleInstance Activity 实例的任务栈只能存放唯一的 singleInstance Activity。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动顺序</span><br><span class="line">MainActivity -&gt; SingleInstanceActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;cd22626 #18116 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;462d9a2 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleInstanceActivity t18116&#125;</span><br><span class="line">    TaskRecord&#123;c2b08bd #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;812c79c u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18115&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动顺序</span><br><span class="line">MainActivity -&gt; SingleInstanceActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;540b885 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18115&#125;</span><br><span class="line">    TaskRecord&#123;5cab9d7 #18116 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;18780a3 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleInstanceActivity t18116&#125;</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;6ceacf3 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18115&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动顺序</span><br><span class="line">MainActivity -&gt; SingleInstanceActivity -&gt; StandardActivity -&gt; SingleInstanceActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;540b885 u0 com.wuzy.androidlaunchmodetest&#x2F;.StandardActivity t18115&#125;</span><br><span class="line">    TaskRecord&#123;5cab9d7 #18116 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;18780a3 u0 com.wuzy.androidlaunchmodetest&#x2F;.SingleInstanceActivity t18116&#125;</span><br><span class="line">    TaskRecord&#123;e46fd18 #18115 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;6ceacf3 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18115&#125;</span><br></pre></td></tr></table></div></figure>

<p>启动 SingleInstanceActivity 会创建新的任务栈，从 SingleInstanceActivity 中启动 StandardActivity，StandardActivity 会被放到上一个任务栈中。</p>
<p>再此启动 SingleInstanceActivity，SingleInstanceActivity 会被复用。</p>
<p><strong>使用场景</strong>：</p>
<p>singleInstance 模式常应用于独立栈操作的应用，如闹钟的提醒页面，当你在A应用中看视频时，闹钟响了，你点击闹钟提醒通知后进入提醒详情页面，然后点击返回就再次回到A的视频页面，这样就不会过多干扰到用户先前的操作了。 </p>

        <h2 id="Intent-Flags">
          <a href="#Intent-Flags" class="heading-link"><i class="fas fa-link"></i></a>Intent Flags</h2>
      <p> 除了在 manifest 文件中设置 launchMode 之外，还可以在 Intent 中设置 Flag 达到同样的效果。</p>
<p>常见几种 Flag：</p>
<p>1、<strong>FLAG_ACTIVITY_NEW_TASK</strong></p>
<p> 在 google 的官方文档中介绍，它与 <code>launchMode=&quot;singleTask&quot;</code> 具有相同的行为。实际上，并不是完全相同！具体看下面的案例分析。 </p>
<p>2、<strong>FLAG_ACTIVITY_SINGLE_TOP</strong></p>
<p> 等同于 <code>launchMode=&quot;singleTop&quot;</code> 。</p>
<p>3、<strong>FLAG_ACTIVITY_CLEAR_TOP</strong></p>
<p> 清除包含目标 Activity 的任务栈中位于该 Activity 实例之上的其他 Activity 实例。 但是是复用已有的目标 Activity，还是先删除后重建，则有以下规则： </p>
<ul>
<li><p>若是使用 FLAG_ACTIVITY_SINGLE_TOP 和 FLAG_ACTIVITY_CLEAR_TOP 标志位组合，那么不管目标 Activity 是什么启动模式，都会被复用。 </p>
</li>
<li><p>若是单独使用 FLAG_ACTIVITY_CLEAR_TOP，那么只有非 standard 启动模式的目标 Activity 才会被复用，否则都先被删除，然后被重新创建并入栈。 </p>
</li>
</ul>
<p>4、<strong>FLAG_ACTIVITY_CLEAR_TASK</strong> </p>
<p>首先清空已经存在的目标 Activity 实例所在的任务栈，这自然也就清除了之前存在的目标 Activity 实例，然后创建新的目标 Activity 实例并入栈。</p>
<p>通过几个案例查看 Flag 的使用效果。</p>
<ul>
<li><p>MainActivity 为 standard 模式，未设置 Flag。</p>
</li>
<li><p>IntentFlagTestActivity 为 standard 模式，未设置 taskAffinity。</p>
</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;.IntentFlagTestActivity&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:label</span>=<span class="string">&quot;IntentFlagTestActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>IntentFlagTestWithAffinityActivity 为 standard 模式，设置与 MainActivity 不同的 taskAffinity。 </li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.IntentFlagTestWithAffinityActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.jaqen&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;IntentFlagTestWithAffinityActivity&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></div></figure>


        <h3 id="1、单独使用-FLAG-ACTIVITY-NEW-TASK">
          <a href="#1、单独使用-FLAG-ACTIVITY-NEW-TASK" class="heading-link"><i class="fas fa-link"></i></a>1、单独使用 FLAG_ACTIVITY_NEW_TASK</h3>
      <ul>
<li>taskAffinity 相同时：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure>

<p>测试结果：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">TaskRecord&#123;89317d5 #18128 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;4&#125;</span><br><span class="line">Run #3: ActivityRecord&#123;2f1ac92 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18128&#125;</span><br><span class="line">Run #2: ActivityRecord&#123;a0104eb u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18128&#125;</span><br><span class="line">Run #1: ActivityRecord&#123;9b84b56 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18128&#125;</span><br><span class="line">Run #0: ActivityRecord&#123;f9a57f4 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18128&#125;</span><br></pre></td></tr></table></div></figure>

<p>从任务栈可以看出，在  taskAffinity 相同的情况下，单独使用 FLAG_ACTIVITY_NEW_TASK 不会产生任何效果！</p>
<ul>
<li>taskAffinity 不同时：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestWithAffinityActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestWithAffinityActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure>

<p>测试结果：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;d07e70 #18135 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;997119c u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18135&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;8a7f641 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18135&#125;</span><br><span class="line">    TaskRecord&#123;84f526e #18134 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5aca49d u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18134&#125;</span><br></pre></td></tr></table></div></figure>

<p>在 taskAffinity 不同的情况下， 添加 FLAG_ACTIVITY_NEW_TASK 确实产生了一些效果，第一次启动 IntentFlagTestWithAffinityActivity 创建了新的任务栈，但是第二次从 MainActivity 中启动 IntentFlagTestWithAffinityActivity  时，没有任何反应。</p>
<p><strong>结论：</strong></p>
<p><strong>单独使用 FLAG_ACTIVITY_NEW_TASK 并不会产生与 singleTask 相同的效果</strong>。</p>

        <h3 id="2、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TOP">
          <a href="#2、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TOP" class="heading-link"><i class="fas fa-link"></i></a>2、FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TOP</h3>
      <ul>
<li>taskAffinity 相同时：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure>

<p>测试结果：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity -&gt; MainActivity</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7bb1982 #18139 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;535c0d0 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18139&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c5253ff u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18139&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;1b04db1 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18139&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7bb1982 #18139 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;705bf3 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18139&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;1b04db1 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18139&#125;</span><br></pre></td></tr></table></div></figure>

<p>在 taskAffinity 相同情况下，FLAG_ACTIVITY_NEW_TASK  + FLAG_ACTIVITY_CLEAR_TOP 不会创建新的任务栈。</p>
<p>貌似和 singleTask 启动模式效果相同，但是细看会发现区别：前后两次 IntentFlagTestActivity 并不是同一个实例，也就是并没有复用栈内的 IntentFlagTestActivity，而是清除了 IntentFlagTestActivity 本身及其之上的所有 Activity，然后新建 IntentFlagTestActivity 实例添加到当前任务栈。</p>
<ul>
<li>taskAffinity 不同时：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestWithAffinityActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestWithAffinityActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure>

<p>测试结果：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 任务栈</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;a1b1a38 #18152 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;ae8c352 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18152&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;5647f4a u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18152&#125;</span><br><span class="line">    TaskRecord&#123;e2f8776 #18151 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;864a2f5 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18151&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line">    </span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;a1b1a38 #18152 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;cf5fce6 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18152&#125;</span><br><span class="line">    TaskRecord&#123;e2f8776 #18151 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;864a2f5 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18151&#125;</span><br></pre></td></tr></table></div></figure>

<p>可见，与 taskAffinity 相同类似（除了创建新的任务栈），在第二次启动 IntentFlagTestWithAffinityActivity 时也是直接清除了 IntentFlagTestWithAffinityActivity 自身及其之上所有的 Activity，然后创建新的 IntentFlagTestWithAffinityActivity 实例添加到任务栈中。</p>
<p><strong>结论：</strong></p>
<p><strong><code>FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TOP</code> 标志位组合产生的效果总体上和 singleTask 模式相同，但不会复用 Activity。</strong></p>

        <h3 id="3、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TASK">
          <a href="#3、FLAG-ACTIVITY-NEW-TASK-FLAG-ACTIVITY-CLEAR-TASK" class="heading-link"><i class="fas fa-link"></i></a>3、FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TASK</h3>
      <ul>
<li>taskAffnity 相同时：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure>

<p>测试结果:</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;572ae8d #18253 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;e0aa3a u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18253&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;572ae8d #18253 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;65fb5c2 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18253&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;e0aa3a u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18253&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;572ae8d #18253 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;9eccfa3 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18253&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></div></figure>

<p>可见， 当通过<code>FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TASK </code> 标志位组合启动 IntentFlagTestActivity 时，首先会清空 IntentFlagTestActivity 所在的任务栈，然后再创建新的 IntentFlagTestActivity 实例并入栈。 </p>
<ul>
<li>taskAffnity 不同时：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动 IntentFlagTestWithAffinityActivity 的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, IntentFlagTestWithAffinityActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></div></figure>

<p>测试结果:</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;c081b17 #18257 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;8f8a3c5 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18257&#125;</span><br><span class="line">    TaskRecord&#123;60908ed #18256 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5924b86 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18256&#125;</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;c081b17 #18257 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;7e1a8a0 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18257&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;8f8a3c5 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18257&#125;</span><br><span class="line">    TaskRecord&#123;60908ed #18256 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5924b86 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18256&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestWithAffinityActivity -&gt; MainActivity -&gt; IntentFlagTestWithAffinityActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;c081b17 #18257 A&#x3D;com.jaqen U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;e52a3c0 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestWithAffinityActivity t18257&#125;</span><br><span class="line">    TaskRecord&#123;60908ed #18256 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;1&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;5924b86 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18256&#125;</span><br></pre></td></tr></table></div></figure>

<p>结果与 taskAffnity 相同情况下类似， 首先会清空 IntentFlagTestWithAffinityActivity 所在的任务栈，然后再创建新的 IntentFlagTestWithAffinityActivity 实例并入栈，这和 taskAffinity 属性相同是一致的效果，只不过这里第一次为 IntentFlagTestWithAffinityActivity 创建了新的任务栈。 </p>
<p><strong>结论：</strong></p>
<p><strong><code>FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TASK </code> 标志位组会先清空任务栈，再创建新的 Activity 实例入栈。</strong></p>

        <h3 id="4、单独使用-FLAG-ACTIVITY-CLEAR-TOP">
          <a href="#4、单独使用-FLAG-ACTIVITY-CLEAR-TOP" class="heading-link"><i class="fas fa-link"></i></a>4、单独使用 FLAG_ACTIVITY_CLEAR_TOP</h3>
      <ul>
<li>IntentFlagTestActivity 启动模式：standard</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b6045f3 #18282 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;44dcf5f u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18282&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;c713f21 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b6045f3 #18282 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;13c806b u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;44dcf5f u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18282&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;c713f21 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;b6045f3 #18282 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;fa6320c u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18282&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;c713f21 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18282&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>IntentFlagTestActivity 启动模式：singleTask</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7c9d493 #18280 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;daafb1e u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18280&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b547fca u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7c9d493 #18280 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;511762c u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;daafb1e u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18280&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b547fca u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;7c9d493 #18280 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;daafb1e u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18280&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;b547fca u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18280&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上面两个例子看出，单独使用 FLAG_ACTIVITY_CLEAR_TOP 时，</p>
<p>standard 启动模式下，目标 Activity 自身及其上的 Activity 都会被销毁，目标 Activity 自身会重新创建放入栈中；singleTask 启动模式下，先销毁目标 Activity 之上的所有 Activity，然后复用已有的 Activity。</p>
<p>此外，singleTop、singleInstance 与 singleTask 一样，都会复用已有 Activity。这里不在赘述。</p>
<p><strong>结论：</strong></p>
<p><strong>单独使用 FLAG_ACTIVITY_CLEAR_TOP，那么只有非 standard 启动模式的目标 Activity 才会被复用，否则都先被删除，然后被重新创建并入栈。</strong></p>

        <h3 id="5、FLAG-ACTIVITY-CLEAR-TOP-FLAG-ACTIVITY-SINGLE-TOP">
          <a href="#5、FLAG-ACTIVITY-CLEAR-TOP-FLAG-ACTIVITY-SINGLE-TOP" class="heading-link"><i class="fas fa-link"></i></a>5、FLAG_ACTIVITY_CLEAR_TOP  + FLAG_ACTIVITY_SINGLE_TOP</h3>
      <ul>
<li>IntentFlagTestActivity 启动模式 standard</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;bf65b55 #18326 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c62eb86 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18326&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;eb38b03 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;bf65b55 #18326 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;be92d5b u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c62eb86 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18326&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;eb38b03 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、启动流程</span><br><span class="line">MainActivity -&gt; IntentFlagTestActivity  -&gt; MainActivity -&gt; IntentFlagTestActivity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈内容</span><br><span class="line">Running activities (most recent first):</span><br><span class="line">    TaskRecord&#123;bf65b55 #18326 A&#x3D;com.wuzy.androidlaunchmodetest U&#x3D;0 StackId&#x3D;1 sz&#x3D;2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;c62eb86 u0 com.wuzy.androidlaunchmodetest&#x2F;.IntentFlagTestActivity t18326&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;eb38b03 u0 com.wuzy.androidlaunchmodetest&#x2F;.MainActivity t18326&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>FLAG_ACTIVITY_CLEAR_TOP  + FLAG_ACTIVITY_SINGLE_TOP</code> 标志位组合情况， standard 模式下的 IntentFlagTestActivity 被复用了， 那么其他启动模式的 Activity 也必然会被复用。（单独使用 FLAG_ACTIVITY_CLEAR_TOP 都会被复用，何况又添加了 FLAG_ACTIVITY_SINGLE_TOP 标志位，通过 Demo 验证也确实如此，就不再给出具体案例了）。 </p>
<p><strong>结论：</strong></p>
<p><strong>使用 FLAG_ACTIVITY_SINGLE_TOP 和 FLAG_ACTIVITY_CLEAR_TOP 标志位组合，那么不管目标 Activity 是什么启动模式，都会被复用。</strong> </p>
<p>OK，Activity 启动模式相关的内容就介绍这些，希望感兴趣的朋友有帮助。</p>
<p>Demo 我已经放在了 GitHub 上，有兴趣可以下载下来，运行看看结果。</p>
<p> <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/zywudev/AndroidLaunchModeTest">https://github.com/zywudev/AndroidLaunchModeTest</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/10/30/android-interview-3-java-reference/">Android 面试题（3）：回答一下什么是强、软、弱、虚引用以及它们之间的区别？</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-10-30</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p>
<p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p>
<p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p>
</blockquote>
<p>从 JDK1.2 版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>

        <h4 id="1、强引用（Strong-Reference）">
          <a href="#1、强引用（Strong-Reference）" class="heading-link"><i class="fas fa-link"></i></a>1、强引用（Strong Reference）</h4>
      <p>强引用就是我们经常使用的引用，其写法如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></div></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>只要还有强引用指向一个对象，垃圾收集器就不会回收这个对象。</li>
<li>显式地设置 o 为 null，或者超出对象的生命周期，此时就可以回收这个对象。具体回收时机还是要看垃圾收集策略。</li>
<li>在不用对象的时将引用赋值为 null，能够帮助垃圾回收器回收对象。比如  ArrayList 的 clear() 方法实现：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、软引用（Soft-Reference）">
          <a href="#2、软引用（Soft-Reference）" class="heading-link"><i class="fas fa-link"></i></a>2、软引用（Soft Reference）</h4>
      <p>如果一个对象只具有软引用，在内存足够时，垃圾回收器不会回收它；如果内存不足，就会回收这个对象的内存。</p>
<p>使用场景：</p>
<ul>
<li>图片缓存。图片缓存框架中，“内存缓存”中的图片是以这种引用保存，使得  JVM 在发生 OOM 之前，可以回收这部分缓存。</li>
<li>网页缓存。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Browser prev = <span class="keyword">new</span> Browser();               <span class="comment">// 获取页面进行浏览</span></span><br><span class="line">SoftReference sr = <span class="keyword">new</span> SoftReference(prev); <span class="comment">// 浏览完毕后置为软引用		</span></span><br><span class="line"><span class="keyword">if</span>(sr.get()!=<span class="keyword">null</span>) &#123; </span><br><span class="line">	rev = (Browser) sr.get();           <span class="comment">// 还没有被回收器回收，直接获取</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	prev = <span class="keyword">new</span> Browser();               <span class="comment">// 由于内存吃紧，所以对软引用的对象回收了</span></span><br><span class="line">	sr = <span class="keyword">new</span> SoftReference(prev);       <span class="comment">// 重新构建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="3、弱引用（Weak-Reference）">
          <a href="#3、弱引用（Weak-Reference）" class="heading-link"><i class="fas fa-link"></i></a>3、弱引用（Weak Reference）</h4>
      <p>简单来说，就是将对象留在内存的能力不是那么强的引用。当垃圾回收器扫描到只具有弱引用的对象，不管当前内存空间是否足够，都会回收内存。</p>
<p><strong>使用场景</strong>：</p>
<p>在下面的代码中，如果类 B 不是虚引用类 A 的话，执行 main 方法会出现内存泄漏的问题， 因为类 B 依然依赖于 A。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(b.getA());  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WeakReference&lt;A&gt; weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weakReference.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在静态内部类中，经常会使用虚引用。例如：一个类发送网络请求，承担 callback 的静态内部类，则常以虚引用的方式来保存外部类的引用，当外部类需要被 JVM 回收时，不会因为网络请求没有及时回应，引起内存泄漏。</p>

        <h4 id="4、虚引用（Phantom-Reference）">
          <a href="#4、虚引用（Phantom-Reference）" class="heading-link"><i class="fas fa-link"></i></a>4、虚引用（Phantom Reference）</h4>
      <p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<p>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue refQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj,refQueue);</span><br></pre></td></tr></table></div></figure>

<p><strong>使用场景</strong>：</p>
<p>可以用来跟踪对象呗垃圾回收的活动。一般可以通过虚引用达到回收一些非java内的一些资源比如堆外内存的行为。例如：在 DirectByteBuffer 中，会创建一个 PhantomReference 的子类 Cleaner 的虚引用实例用来引用该 DirectByteBuffer 实例，Cleaner 创建时会添加一个 Runnable 实例，当被引用的 DirectByteBuffer 对象不可达被垃圾回收时，将会执行 Cleaner 实例内部的 Runnable 实例的 run 方法，用来回收堆外资源。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/10/24/android-interview-2-memory-leak-case/">Android 面试题（2）：一般什么情况下会导致内存泄漏问题？</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-10-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p>
<p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p>
<p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p>
</blockquote>
<p>内存泄漏也是面试常见问题，主要可以考察面试者是否了解内存泄漏，工作中是如何排查解决内存泄漏问题，还可以延伸考察 Java 内存回收机制，Java 中对象的引用方式等等。</p>
<p>这篇文章先来介绍下 Android 开发中常见的内存泄漏案例以及相应的解决方案。</p>

        <h2 id="单例造成的内存泄漏">
          <a href="#单例造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>单例造成的内存泄漏</h2>
      <p>单例模式在 Android 开发中使用率非常高，但使用不恰当的话也会造成内存泄漏。比如下面的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> Singleton(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>单例类对象的生命周期与应用的周期一样长，如果传入的是 Activity 的 Context，在 Activity 退出时，因单例对象持有 Activity 的引用，导致 Activity 的内存不能被回收，即内存泄漏。</p>
<p><strong>解决方案</strong>：</p>
<p>1）使用 Application 的 Context，生命周期一致；</p>
<p>2）将短生命周期的属性的引用方式改为弱引用。</p>

        <h2 id="非静态内部类造成的内存泄漏">
          <a href="#非静态内部类造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>非静态内部类造成的内存泄漏</h2>
      <p>非静态内部类持有外部类的引用，如果外部类的实例已经结束生命周期，但内部类仍然在执行，就会导致外部类不能被回收。比如上一期讲解的自定义 Handler 的使用造成的内存泄漏，主要原因 Activity 退出时，Handler 仍然持有 Activity 的引用，导致 Activity 不能被回收。</p>
<p><strong>解决方案</strong>：</p>
<p>1） 创建一个静态内部类，然后外部类的对象引用使用弱引用；</p>
<p>2）及时关闭耗时或者延时任务，在 Activity 被销毁时及时清除消息，从而及时回收 Activity，避免内存泄漏问题。 </p>

        <h2 id="系统服务注册未取消造成的内存泄漏">
          <a href="#系统服务注册未取消造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>系统服务注册未取消造成的内存泄漏</h2>
      <p>系统服务可以通过 <code>Context.getSystemService</code> 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 Context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有 Activity 的引用，如果在 Activity 的 <code>onDestory()</code> 函数中没有释放掉引用就会内存泄漏。 </p>
<p><strong>解决方案</strong>：</p>
<p>1）使用 Application 的 Context 代替 Activity 的 Context；</p>
<p>2）在 Activity 的 <code>onDestory()</code> 方法，调用反注册释放。</p>

        <h2 id="全局集合类造成的内存泄漏">
          <a href="#全局集合类造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>全局集合类造成的内存泄漏</h2>
      <p>一般情况下集合类不会造成内存泄漏，但如果是全局性的集合，如果在使用完毕后未进行 remove 清理操作，就很有可能造成内存泄漏，所以在集合不需要的时候要及时清理集合元素。</p>

        <h2 id="资源未关闭的内存泄漏">
          <a href="#资源未关闭的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>资源未关闭的内存泄漏</h2>
      <p> 对于使用了 BroadcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap 等资源，应该在 Activity 销毁时及时关闭或者注销。</p>

        <h2 id="WebView-造成的内存泄漏">
          <a href="#WebView-造成的内存泄漏" class="heading-link"><i class="fas fa-link"></i></a>WebView 造成的内存泄漏</h2>
      <p> WebView 存在内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。</p>
<p><strong>解决方案</strong>：</p>
<p>为 WebView 开启一个独立的进程，使用 AIDL 与应用的主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。 </p>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p>总的来说就是生命周期长的对象持有了生命周期短的对象，导致生命周期短的对象在回收时无法被释放，就会导致内存泄漏。</p>
<p>了解常见内存泄漏及解决方案，能够帮助我们在开发中尽量少的出现内存泄漏问题。但有些内存泄漏的定位排查比较困难，需要借助一些工具，比如 LeakCanary、MAT 等。内存泄漏的排查定位方法会在后续文章中介绍，欢迎持续关注。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/10/23/android-interview-1-how-handler-avoid-memory-leaks/">Android 面试题（1）：使用 Handler 时如何有效地避免内存泄漏问题？</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">994</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>这一系列文章致力于为 Android 开发者查漏补缺，面试准备。</p>
<p>所有文章首发于公众号「JaqenAndroid」，长期持续更新。</p>
<p>由于笔者水平有限，总结的答案难免会出现错误，欢迎留言指出，大家一起学习、交流、进步。</p>
</blockquote>

        <h2 id="什么是内存泄漏？">
          <a href="#什么是内存泄漏？" class="heading-link"><i class="fas fa-link"></i></a>什么是内存泄漏？</h2>
      <p>Java 中采用可达性分析算法判断一个对象是否可被回收。</p>
<p>基本思路是这样的：</p>
<p>通过一系列称为 “GC Roots” 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。</p>
<p>可作为 GC Roots 的对象有：</p>
<ul>
<li><p>虚拟机栈中的引用的对象</p>
</li>
<li><p>方法区的静态变量和常量引用的对象</p>
</li>
<li><p>本地方法栈中 JNI 引用的对象</p>
</li>
</ul>
<p><strong>当一个对象不需要在再使用了，本该被回收时， 而另外一个正在使用的对象持有它的引用从而导致它不能被回收，这就导致本该被回收的对象不能被回收而停留在堆内存中，内存泄漏就产生了。</strong> </p>

        <h2 id="Handler-是如何造成内存泄漏的？">
          <a href="#Handler-是如何造成内存泄漏的？" class="heading-link"><i class="fas fa-link"></i></a>Handler 是如何造成内存泄漏的？</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 耗时任务</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> 上面是一段简单的 Handler 的使用。 这种方式有可能造成内存泄漏吗？答案是有可能的。我们来分析下造成内存泄漏的原因？</p>
<p>我们知道 Java中非静态内部类会隐式持有外部类的引用，所以这里创建的 Handler 隐式持有外部类 MainActivity 的引用。</p>
<p>而 Handler 一般用来处理后台线程任务的执行结果，如果在线程任务之慈宁宫过程中，用户关闭了 Activity，此时线程尚未执行完，而该线程持有 Handler 的引用，Handler 又持有 Activity 的引用，就导致了 Activity 无法被回收（即内存泄漏）。</p>
<p>还有一种情况，如果你调用 Handler 的 <code>postDelay()</code> 方法执行了延时任务， 该方法会将你的Handler 装入一个 Message，并把这条 Message 推到 MessageQueue 中，那么在你设定的 delay 到达之前，会有一条 MessageQueue -&gt; Message -&gt; Handler -&gt; Activity 的链，导致你的 Activity 被持有引用而无法被回收。 </p>

        <h2 id="如果解决-Handler-导致的内存泄漏问题？">
          <a href="#如果解决-Handler-导致的内存泄漏问题？" class="heading-link"><i class="fas fa-link"></i></a>如果解决 Handler 导致的内存泄漏问题？</h2>
      <p><strong>方法 1、静态内部类 + 弱引用</strong></p>
<p>既然非静态内部类持有外部类的引用，那么可以将 Handler 声明为静态内部类，Handler 也就不再持有 Activity 的引用，所以 Activity 可以随便被回收。代码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>此时 Handler 不再持有 Activity 的引用，导致 Handler 无法操作 Activity 中对象，所以可以在 Handler 中添加一个对 Activity 的弱引用（ WeakReference ）：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    WeakReference&lt;Activity &gt; mActivityReference;</span><br><span class="line"></span><br><span class="line">    MyHandler(Activity activity) &#123;</span><br><span class="line">        mActivityReference= <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Activity activity = mActivityReference.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>弱引用的特点是： 在垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 所以用户在关闭 Activity 之后，就算后台线程还没结束，但由于仅有一条来自 Handler 的弱引用指向 Activity，Activity 也会被回收掉。这样，内存泄露的问题就不会出现了。 </p>
<p><strong>方法2： 通过程序逻辑来进行保护</strong></p>
<p> 在 Activity 被销毁时及时清除消息，从而及时回收 Activity，避免内存泄漏问题。 </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>)  &#123;</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>







</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/10/14/compile-ijkplayer/">ijkplayer 编译实践</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-10-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">790</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>记录 ijkplayer 的编译过程，以及遇到的问题，有需要的朋友可以参考。</p>

        <h2 id="编译环境">
          <a href="#编译环境" class="heading-link"><i class="fas fa-link"></i></a>编译环境</h2>
      
        <h3 id="Linux-环境">
          <a href="#Linux-环境" class="heading-link"><i class="fas fa-link"></i></a>Linux 环境</h3>
      <p>由于主机是 Windows 系统，所以使用 VMware 安装了 Ubuntu 18.0.4 系统。</p>
<p>VMware 安装 Ubuntu 系统的安装步骤网上非常多，这篇文章比较详细，没有经验的可以参考。</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38797088">https://zhuanlan.zhihu.com/p/38797088</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Android-SDK">
          <a href="#Android-SDK" class="heading-link"><i class="fas fa-link"></i></a>Android SDK</h3>
      <p>下载地址：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://developer.android.com/studio#downloads">https://developer.android.com/studio#downloads</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Android-NDK">
          <a href="#Android-NDK" class="heading-link"><i class="fas fa-link"></i></a>Android NDK</h3>
      <p>下载地址：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://developer.android.google.cn/ndk/downloads/older_releases.html">https://developer.android.google.cn/ndk/downloads/older_releases.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>注意 NDK 的最小版本支持是 10e，目前不支持 NDK 15！我这边下载的是 <code>android-ndk-r14b</code>。</p>
<p>Android SDK 和 Android NDK 下载解压后，需要配置环境变量，可以参考我写的这篇文章。</p>
<p><a href="http://wuzhangyang.com/2019/10/14/ubuntu-android-studio/">http://wuzhangyang.com/2019/10/14/ubuntu-android-studio/</a></p>

        <h3 id="安装-git-和-yasm">
          <a href="#安装-git-和-yasm" class="heading-link"><i class="fas fa-link"></i></a>安装 git 和 yasm</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt install yasm</span><br></pre></td></tr></table></div></figure>

<p>注意，如果安装报错，先要执行 <code>sudo apt update</code> 进行更新。</p>

        <h2 id="开始编译">
          <a href="#开始编译" class="heading-link"><i class="fas fa-link"></i></a>开始编译</h2>
      
        <h3 id="拉取-ijkplayer-源码">
          <a href="#拉取-ijkplayer-源码" class="heading-link"><i class="fas fa-link"></i></a>拉取 ijkplayer 源码</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br><span class="line">cd ijkplayer-android</span><br><span class="line">git checkout -B latest k0.8.8</span><br></pre></td></tr></table></div></figure>


        <h3 id="初始化-android">
          <a href="#初始化-android" class="heading-link"><i class="fas fa-link"></i></a>初始化 android</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android.sh</span><br></pre></td></tr></table></div></figure>


        <h3 id="初始化-openssl-支持-https">
          <a href="#初始化-openssl-支持-https" class="heading-link"><i class="fas fa-link"></i></a>初始化 openssl 支持 https</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android-openssl.sh</span><br></pre></td></tr></table></div></figure>


        <h3 id="配置编解码器格式支持">
          <a href="#配置编解码器格式支持" class="heading-link"><i class="fas fa-link"></i></a>配置编解码器格式支持</h3>
      <p>默认为最少支持，如果足够你使用，可以跳过这一步，否则可以改为以下配置:</p>
<ul>
<li><p><code>module-default.sh</code> 更多的编解码器/格式</p>
</li>
<li><p><code>module-lite-hevc.sh</code> 较少的编解码器/格式(包括 hevc)</p>
</li>
<li><p><code>module-lite.sh</code> 较少的编解码器/格式(默认情况)</p>
</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 config 目录</span></span><br><span class="line">cd config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前的 module.sh 文件</span></span><br><span class="line">rm module.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建软链接 module.sh 指向 module-default.sh</span></span><br><span class="line">ln -s module-default.sh module.sh</span><br></pre></td></tr></table></div></figure>


        <h3 id="编译-openssl">
          <a href="#编译-openssl" class="heading-link"><i class="fas fa-link"></i></a>编译 openssl</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 android/contrib 目录</span></span><br><span class="line">cd android/contrib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除 openssl 的编译文件</span></span><br><span class="line">./compile-openssl.sh clean</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 openssl</span></span><br><span class="line">./compile-openssl.sh all</span><br></pre></td></tr></table></div></figure>

<p><code>./compile-openssl.sh</code> 后跟 <code>all</code> 表示编译所有 CPU 架构的 so 库， 如果只编译指定 CPU 架构的 so 库，后面就跟 CPU 架构，比如：<code>./compile-ffmpeg.sh armv7a</code>。</p>
<p>这里，在执行 <code>./compile-openssl.sh all</code> 时出现了编译错误：<strong>ERROR: Failed to create toolchain.</strong></p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">jaqen@jaqen-virtual-machine:~/Android/Projects/ijkplayer-android/android/contrib$ ./compile-openssl.sh all</span><br><span class="line">====================</span><br><span class="line">[*] check archs</span><br><span class="line">====================</span><br><span class="line">FF_ALL_ARCHS = armv5 armv7a arm64 x86 x86_64</span><br><span class="line">FF_ACT_ARCHS = armv5 armv7a arm64 x86 x86_64</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">[*] make NDK standalone toolchain</span><br><span class="line">--------------------</span><br><span class="line">build on Linux x86_64</span><br><span class="line">ANDROID_NDK=/home/jaqen/Android/Sdk/android-ndk-r14b</span><br><span class="line">IJK_NDK_REL=14.1.3816874</span><br><span class="line">NDKr14.1.3816874 detected</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">[*] make NDK standalone toolchain</span><br><span class="line">--------------------</span><br><span class="line">build on Linux x86_64</span><br><span class="line">ANDROID_NDK=/home/jaqen/Android/Sdk/android-ndk-r14b</span><br><span class="line">IJK_NDK_REL=14.1.3816874</span><br><span class="line">NDKr14.1.3816874 detected</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_EXE=</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_TAG=linux-x86_64</span><br><span class="line">HOST_NUM_CPUS=4</span><br><span class="line">BUILD_NUM_CPUS=8</span><br><span class="line">Auto-config: --arch=arm</span><br><span class="line">ERROR: Failed to create toolchain.</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>解决办法是安装 python 后再执行编译。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python</span><br></pre></td></tr></table></div></figure>


        <h3 id="编译-ffmpeg">
          <a href="#编译-ffmpeg" class="heading-link"><i class="fas fa-link"></i></a>编译 ffmpeg</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清除 ffmpeg 的编译文件</span></span><br><span class="line">./compile-ffmpeg.sh clean</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 ffmpeg</span></span><br><span class="line">./compile-ffmpeg.sh all</span><br></pre></td></tr></table></div></figure>

<p>执行 <code>./compile-ffmpeg.sh all</code> 时出现编译错误：<strong>linux/perf_event.h: No such file or directory</strong>。</p>
<p>解决办法是在 <code>config</code> 文件夹下的 <code>module.sh</code> 文件中加入下面两句：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-bzlib&quot;</span><br></pre></td></tr></table></div></figure>

<p>再重新执行编译。</p>

        <h3 id="编译-ijkplayer">
          <a href="#编译-ijkplayer" class="heading-link"><i class="fas fa-link"></i></a>编译 ijkplayer</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 android 目录</span></span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 ijkplayer</span></span><br><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></div></figure>

<p> 编译完成之后，在 <code>android/ijkpleyer</code> 文件夹的对应架构文件下，在<code>/src/main/libs/架构名/</code>下生成<code>libijkplayer.so</code>、<code>libijkffmpeg.so</code>、<code>libijksdl.so</code> 三个文件。 </p>
<p><img src="/2019/10/14/compile-ijkplayer/ijkplayer_so.png" alt="ijkplayer_so"></p>
<p>至此，ijkplayer 的编译工作就全部完成了。</p>
<p>编译过程中遇到问题的朋友欢迎留言交流。</p>
<p>不想编译的朋友，可以在公众号 「贾小昆」后台回复 <code>ijk</code> 获取 so 包。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">万物之中，希望至美</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/zywudev/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/zywu-43/" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a><a class="sidebar-ov-social-item" href="https://weixin.sogou.com/weixin?query=%E8%B4%BE%E5%B0%8F%E6%98%86/" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">100</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>贾小昆</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.1.1</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script><script type="application/json" src="/search.xml"></script></body></html>