<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="贾小昆">
<meta property="og:url" content="http://wuzhangyang.com/page/5/index.html">
<meta property="og:site_name" content="贾小昆">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="贾小昆">
<meta name="twitter:card" content="summary"><title>贾小昆</title><link ref="canonical" href="http://wuzhangyang.com/page/5/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><script src="https://www.googletagmanager.com/gtag/js?id=UA-127464210-1" async=""></script><script>if (window.location.hostname !== 'localhost') {
  window.dataLayer = window.dataLayer || [];
  function gtag(){ dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-127464210-1');
}</script><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.1.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/03/11/ok-analysis-2/">OkHttp 源码分析（二）：缓存机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-03-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">20分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><a href="http://wuzhangyang.com/2019/03/11/okhttp-source-code-analysis-1/">上一篇文章</a>我们主要介绍了 OkHttp 的请求流程，这篇文章讲解一下 OkHttp 的缓存机制。</p>
<p>建议将 OkHttp 的源码下载下来，使用 IDEA 编辑器可以直接打开阅读。我这边也将最新版的源码下载下来，进行了注释说明，有需要的可以直接从 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/zywudev/android-open-framework-analysis">Android open framework analysis</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 查看。</p>
<p>在网络请求的过程中，一般都会使用到缓存，缓存的意义在于，对于客户端来说，使用缓存数据能够缩短页面展示数据的时间，优化用户体验，同时降低请求网络数据的频率，避免流量浪费。对于服务端来说，使用缓存能够分解一部分服务端的压力。</p>
<p>在讲解 OkHttp 的缓存机制之前，先了解下 Http  的缓存理论知识，这是实现 OkHttp 缓存的基础。</p>

        <h2 id="Http-缓存">
          <a href="#Http-缓存" class="heading-link"><i class="fas fa-link"></i></a>Http 缓存</h2>
      <p>Http 的缓存机制如下图：</p>
<p><img src="/2019/03/11/ok-analysis-2/cache.png" alt="http-cache"></p>
<p>Http 的缓存分为两种：强制缓存和对比缓存。强制缓存优先于对比缓存。</p>

        <h3 id="强制缓存">
          <a href="#强制缓存" class="heading-link"><i class="fas fa-link"></i></a>强制缓存</h3>
      <p>客户端第一次请求数据时，服务端返回缓存的过期时间（通过字段 Expires 与 Cache-Control 标识），后续如果缓存没有过期就直接使用缓存，无需请求服务端；否则向服务端请求数据。</p>
<p><strong>Expires</strong></p>
<p>服务端返回的到期时间。下一次请求时，请求时间小于 Expires 的值，直接使用缓存数据。</p>
<p>由于到期时间是服务端生成，客户端和服务端的时间可能存在误差，导致缓存命中的误差。</p>
<p><strong>Cache-Control</strong></p>
<p>Http1.1 中采用了 Cache-Control 代替了 Expires，常见 Cache-Control 的取值有：</p>
<ul>
<li>private: 客户端可以缓存 </li>
<li>public:  客户端和代理服务器都可缓存</li>
<li>max-age=xxx:  缓存的内容将在 xxx 秒后失效</li>
<li>no-cache:  需要使用对比缓存来验证缓存数据，并不是字面意思</li>
<li>no-store:  所有内容都不会缓存，强制缓存，对比缓存都不会触发</li>
</ul>

        <h3 id="对比缓存">
          <a href="#对比缓存" class="heading-link"><i class="fas fa-link"></i></a>对比缓存</h3>
      <p>对比缓存每次请求都需要与服务器交互，由服务端判断是否可以使用缓存。</p>
<p>客户端第一次请求数据时,服务器会将缓存标识（Last-Modified/If-Modified-Since 与 Etag/If-None-Match）与数据一起返回给客户端，客户端将两者备份到缓存数据库中。</p>
<p>当再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，返回 304 状态码，通知客户端可以使用缓存数据，服务端不需要将报文主体返回给客户端。</p>
<p><strong>Last-Modified/If-Modified-Since</strong></p>
<p>Last-Modified 表示资源上次修改的时间，在第一次请求时服务端返回给客户端。</p>
<p>客户端再次请求时，会在 header 里携带 If-Modified-Since ，将资源修改时间传给服务端。</p>
<p>服务端发现有  If-Modified-Since 字段，则与被请求资源的最后修改时间对比，如果资源的最后修改时间大于  If-Modified-Since，说明资源被改动了，则响应所有资源内容，返回状态码 200；否则说明资源无更新修改，则响应状态码 304，告知客户端继续使用所保存的缓存。</p>
<p>**Etag/If-None-Match **</p>
<p>优先于 Last-Modified/If-Modified-Since。</p>
<p>Etag 是当前资源在服务器的唯一标识，生成规则由服务器决定。当客户端第一次请求时，服务端会返回该标识。</p>
<p>当客户端再次请求数据时，在 header 中添加 If-None-Match 标识。</p>
<p>服务端发现有 If-None-Match 标识，则会与被请求资源对比，如果不同，说明资源被修改，返回 200；如果相同，说明资源无更新，响应 304，告知客户端继续使用缓存。</p>

        <h2 id="OkHttp-缓存">
          <a href="#OkHttp-缓存" class="heading-link"><i class="fas fa-link"></i></a>OkHttp 缓存</h2>
      <p>为了节省流量和提高响应速度，OkHttp 有自己的一套缓存机制，CacheInterceptor 就是用来负责读取缓存以及更新缓存的。</p>
<p>我们来看 CacheInterceptor 的关键代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、如果此次网络请求有缓存数据，取出缓存数据作为候选</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、根据cache获取缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    <span class="comment">// 通过缓存策略计算的网络请求</span></span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    <span class="comment">// 通过缓存策略处理得到的缓存响应数据</span></span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存数据不能使用，清理此缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、不进行网络请求，而且没有缓存数据，则返回网络请求错误的结果</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(<span class="number">504</span>)</span><br><span class="line">            .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、如果不进行网络请求，缓存数据可用，则直接返回缓存数据.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、缓存无效，则继续执行网络请求。</span></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6、通过服务端校验后，缓存数据可以使用（返回304），则直接返回缓存数据，并且更新缓存</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">            <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、读取网络结果，构造response</span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>整个方法的流程如下：</p>
<ul>
<li><p>1、读取候选缓存。</p>
</li>
<li><p>2、根据候选缓存创建缓存策略。</p>
</li>
<li><p>3、根据缓存策略，如果不进行网络请求，而且没有缓存数据时，报错返回错误码 504。</p>
</li>
<li><p>4、根据缓存策略，如果不进行网络请求，缓存数据可用，则直接返回缓存数据。</p>
</li>
<li><p>5、缓存无效，则继续执行网络请求。</p>
</li>
<li><p>6、通过服务端校验后，缓存数据可以使用（返回 304），则直接返回缓存数据，并且更新缓存。</p>
</li>
<li><p>7、读取网络结果，构造 response，对数据进行缓存。</p>
</li>
</ul>
<p>OkHttp 通过 CacheStrategy 获取缓存策略，CacheStrategy 根据之前缓存结果与当前将要发生的 request 的Header 计算缓存策略。规则如下：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>CacheStrategy</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>null</td>
<td>only-if-cached(表明不进行网络请求，且缓存不存在或者过期，一定会返回 503 错误)</td>
</tr>
<tr>
<td>null</td>
<td>non-null</td>
<td>不进行网络请求，而且缓存可以使用，直接返回缓存，不用请求网络</td>
</tr>
<tr>
<td>non-null</td>
<td>null</td>
<td>需要进行网络请求，而且缓存不存在或者过期，直接访问网络。</td>
</tr>
<tr>
<td>non-null</td>
<td>not-null</td>
<td>Header 中含有 ETag/Last-Modified 标识，需要在条件请求下使用，还是需要访问网络。</td>
</tr>
</tbody></table></div>
<p>CacheStrategy 通过工厂模式构造，CacheStrategy.Factory 对象构建以后，调用它的 <code>get</code> 方法即可获得具体的CacheStrategy，CacheStrategy.Factory 的 <code>get</code>方法内部调用的是 CacheStrategy.Factory 的 <code>getCandidate</code> 方法，它是核心的实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、没有缓存，直接返回包含网络请求的策略结果</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、如果握手信息丢失，则返返回包含网络请求的策略结果</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、如果根据CacheControl参数有no-store，则不适用缓存，直接返回包含网络请求的策略结果</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、如果缓存数据的CacheControl有no-cache指令或者需要向服务器端校验后决定是否使用缓存，则返回只包含网络请求的策略结果</span></span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 如果缓存在过期时间内则可以直接使用，则直接返回上次缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 如果缓存过期，且有ETag等信息，则发送If-None-Match、If-Modified-Since等条件请求</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>整个函数的逻辑就是按照上面的 Http 缓存策略流程图来实现的，这里不再赘述。</p>
<p>我们再简单看下 OkHttp 是如何缓存数据的。</p>
<p>OkHttp 具体的缓存数据是利用 DiskLruCache 实现，用磁盘上的有限大小空间进行缓存，按照 LRU 算法进行缓存淘汰。</p>
<p> Cache 类封装了缓存的实现，缓存操作封装在  InternalCache 接口中。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InternalCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪一个满足缓存条件的GET请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪满足缓存策略CacheStrategy的响应</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Cache 类在其内部实现了 InternalCache 的匿名内部类，内部类的方法调用 Cache 对应的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">final</span> InternalCache internalCache = <span class="keyword">new</span> InternalCache() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Cache.<span class="keyword">this</span>.get(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Cache.<span class="keyword">this</span>.put(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.remove(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span> </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.update(cached, network);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.trackConditionalCacheHit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span> </span>&#123;</span><br><span class="line">      Cache.<span class="keyword">this</span>.trackResponse(cacheStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <ul>
<li>OkHttp 的缓存机制是按照 Http 的缓存机制实现。</li>
<li>OkHttp 具体的数据缓存逻辑封装在 Cache 类中，它利用 DiskLruCache 实现。</li>
<li>默认情况下，OkHttp 不进行缓存数据。</li>
<li>可以在构造 OkHttpClient 时设置 Cache 对象，在其构造函数中指定缓存目录和缓存大小。</li>
</ul>
<ul>
<li>如果对 OkHttp 内置的 Cache  类不满意，可以自行实现  InternalCache 接口，在构造 OkHttpClient  时进行设置，这样就可以使用自定义的缓存策略了。</li>
</ul>

        <h2 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>
      <ul>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.cnblogs.com/chenqf/p/6386163.html">https://www.cnblogs.com/chenqf/p/6386163.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.im/post/5a704ed05188255a8817f4c9">https://juejin.im/post/5a704ed05188255a8817f4c9</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/03/11/ok-analysis-1/">OkHttp 源码分析（一）：请求流程</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-03-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">22分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>这篇文章主要梳理一下 OkHttp 的请求流程，对 OkHttp 的实现原理有个整体的把握，再深入细节的实现会更加容易。</p>
<p>建议将 OkHttp 的源码下载下来，使用 IDEA 编辑器可以直接打开阅读。我这边也将最新版的源码下载下来，进行了注释说明，有需要的可以直接从 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/zywudev/android-open-framework-analysis">Android open framework analysis</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 查看。</p>

        <h2 id="基本使用">
          <a href="#基本使用" class="heading-link"><i class="fas fa-link"></i></a>基本使用</h2>
      <p>我们先看一下 OkHttp 的基本使用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建 Request</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .get()</span><br><span class="line">    .url(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .build(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 OKHttpClient</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、创建 Call</span></span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 4、同步请求</span></span><br><span class="line">    Response response = call.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、异步请求</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<p>上面的代码中，首先构建一个请求 Request 和一个客户端 OkHttpClient，然后 OkHttpClient 对象根据 request 调用 <code>newCall</code> 方法创建 Call 对象，再调用  <code>execute</code> 或者 <code>enqueue</code> 方法进行同步或者异步请求。</p>
<p>接下来我们看一看关键类和关键流程的具体实现。</p>

        <h2 id="Request">
          <a href="#Request" class="heading-link"><i class="fas fa-link"></i></a>Request</h2>
      <p>Request 类封装了一次请求需要传递给服务端的参数：请求 method 如 GET/POST 等、一些 header、RequestBody 等等。</p>
<p>Request 类未对外提供 public 的构造函数，所以构建一个 Request 实例需要使用构造者模式构建。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Request(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">    <span class="keyword">this</span>.method = builder.method;</span><br><span class="line">    <span class="keyword">this</span>.headers = builder.headers.build();</span><br><span class="line">    <span class="keyword">this</span>.body = builder.body;</span><br><span class="line">    <span class="keyword">this</span>.tags = Util.immutableMap(builder.tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="OkHttpClient">
          <a href="#OkHttpClient" class="heading-link"><i class="fas fa-link"></i></a>OkHttpClient</h2>
      <p>OkHttpClient 支持两种构造方式。</p>
<p>一种是默认的构造方式：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br></pre></td></tr></table></div></figure>

<p>看一下构造函数：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>这里 OkHttpClient 内部默认配置了一些参数。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;...&#125;</span><br></pre></td></tr></table></div></figure>

<p>另一种是通过 Builder 配置参数，最后通过 <code>build</code> 方法构建一个 OkHttpClient 对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>); <span class="comment">// 这里的 this 是 Builder 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们看一下 OkHttpClient 可配置哪些参数：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Dispatcher dispatcher;    <span class="comment">// 调度器</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">Proxy proxy; <span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Protocol&gt; protocols;  <span class="comment">// 协议</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ConnectionSpec&gt; connectionSpecs;  <span class="comment">// 传输层版本和连接协议</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;  <span class="comment">// 拦截器</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors;  <span class="comment">// 网络拦截器</span></span><br><span class="line"><span class="keyword">final</span> EventListener.Factory eventListenerFactory;</span><br><span class="line"><span class="keyword">final</span> ProxySelector proxySelector; <span class="comment">// 代理选择器</span></span><br><span class="line"><span class="keyword">final</span> CookieJar cookieJar;  <span class="comment">// cookie</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">Cache cache;  <span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">InternalCache internalCache;  <span class="comment">// 内部缓存</span></span><br><span class="line"><span class="keyword">final</span> SocketFactory socketFactory;  <span class="comment">// socket 工厂</span></span><br><span class="line"><span class="keyword">final</span> SSLSocketFactory sslSocketFactory;  <span class="comment">// 安全套接层 socket 工厂，用于 https</span></span><br><span class="line"><span class="keyword">final</span> CertificateChainCleaner certificateChainCleaner; <span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名</span></span><br><span class="line"><span class="keyword">final</span> HostnameVerifier hostnameVerifier; <span class="comment">// 主机名字验证</span></span><br><span class="line"><span class="keyword">final</span> CertificatePinner certificatePinner; <span class="comment">// 证书链</span></span><br><span class="line"><span class="keyword">final</span> Authenticator proxyAuthenticator; <span class="comment">// 代理身份验证</span></span><br><span class="line"><span class="keyword">final</span> Authenticator authenticator; <span class="comment">// 本地身份验证</span></span><br><span class="line"><span class="keyword">final</span> ConnectionPool connectionPool;  <span class="comment">// 连接池</span></span><br><span class="line"><span class="keyword">final</span> Dns dns;  <span class="comment">// 域名</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> followSslRedirects;  <span class="comment">// 安全套接层重定向</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> followRedirects;  <span class="comment">// 本地重定向</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> retryOnConnectionFailure;  <span class="comment">// 重试连接失败</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> callTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> readTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> writeTimeout;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pingInterval;</span><br></pre></td></tr></table></div></figure>


        <h2 id="Call">
          <a href="#Call" class="heading-link"><i class="fas fa-link"></i></a>Call</h2>
      <p>Call 是一个接口，是请求的抽象描述，具体实现类是 RealCall，通过Call.Factory 创建。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回当前请求</span></span><br><span class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步请求方法</span></span><br><span class="line">  <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消请求</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求是否在执行（当execute()或者enqueue(Callback responseCallback)执行后该方法返回true）</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求是否被取消</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的一模一样的请求</span></span><br><span class="line">  <span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>OkHttpClient 实现了 Call.Factory，负责根据 Request 创建新的 Call：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call call = client.newCall(request);</span><br></pre></td></tr></table></div></figure>

<p>看一下 <code>newCall</code> 方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里我们发现实际上调用了 RealCall 的静态方法 <code>newRealCall</code>， 不难猜测 这个方法就是创建 Call 对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="同步请求">
          <a href="#同步请求" class="heading-link"><i class="fas fa-link"></i></a>同步请求</h2>
      <p>从上面的分析我们知道，同步请求调用的实际是 RealCall 的 <code>execute</code> 方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 每个 call 只能执行一次</span></span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    timeout.enter();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 请求开始, 将自己加入到runningSyncCalls队列中</span></span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// 通过一系列拦截器请求处理和响应处理得到最终的返回结果</span></span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e = timeoutExit(e);</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 请求完成, 将其从runningSyncCalls队列中移除</span></span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>

<p>这里主要做了这几件事：</p>
<ul>
<li>检测这个 call 是否已经执行了，保证每个 call 只能执行一次。</li>
<li>通知 dispatcher 已经进入执行状态，将 call 加入到 runningSyncCalls 队列中。</li>
<li>调用 <code>getResponseWithInterceptorChain()</code> 函数获取 HTTP 返回结果。</li>
<li>最后还要通知 <code>dispatcher</code> 自己已经执行完毕，将 call 从 runningSyncCalls 队列中移除。</li>
</ul>
<p>这里涉及到了 Dispatcher 这个类，我们在异步请求这一节中再介绍。</p>
<p>真正发出网络请求以及解析返回结果的是在 <code>getResponseWithInterceptorChain</code> 方法中进行的。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br></pre></td></tr></table></div></figure>

<p> <code>getResponseWithInterceptorChain</code> 方法的代码量并不多，但是却完成了所有的请求处理过程。</p>
<p>这里先是创建了一个 Interceptor 的集合，然后将各类 interceptor 全部加入到集合中，包含以下 interceptor：</p>
<ul>
<li><p>interceptors：配置 OkHttpClient 时设置的 inteceptors</p>
</li>
<li><p>RetryAndFollowUpInterceptor：负责失败重试以及重定向</p>
</li>
<li><p>BridgeInterceptor：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</p>
</li>
<li><p>CacheInterceptor：负责读取缓存直接返回、更新缓存</p>
</li>
<li><p>ConnectInterceptor：负责和服务器建立连接</p>
</li>
<li><p>networkInterceptors：配置 OkHttpClient 时设置的 networkInterceptors</p>
</li>
<li><p>CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应数据</p>
</li>
</ul>
<p>添加完拦截器后，创建了一个 RealInterceptorChain 对象，将集合 interceptors 和 index（<strong>数值0</strong>）传入。接着调用其 <code>proceed</code> 方法进行请求的处理，我们来看 <code>proceed</code>方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建下一个RealInterceptorChain，将index+1（下一个拦截器索引）传入</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    <span class="comment">// 获取当前的拦截器</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">// 通过Interceptor的intercept方法进行处理</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>

<p>我们来看一些关键代码：</p>
<p>RealInterceptorChain 的 <code>proceed</code> 方法先创建 RealInterceptorChain 的对象，将集合 interceptors 和 index + 1 传入。从前面的分析知道，初始 index 为 0。</p>
<p>然后获取当前 index 位置上的 Interceptor，将创建的 RealInterceptorChain 对象 next 传入到当前拦截器的 <code>intercept</code> 方法中，<code>intercept</code> 方法内部会调用 next 的 proceed 方法，一直递归下去，最终完成一次网络请求。</p>
<p>所以每个 Interceptor 主要做两件事情：</p>
<ul>
<li>拦截上一层拦截器封装好的 Request，然后自身对这个 Request 进行处理，处理后向下传递。</li>
<li>接收下一层拦截器传递回来的 Response，然后自身对 Response 进行处理，返回给上一层。</li>
</ul>

        <h2 id="异步请求">
          <a href="#异步请求" class="heading-link"><i class="fas fa-link"></i></a>异步请求</h2>
      <p>异步请求调用的是 RealCall 的 <code>enqueue</code> 方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.executed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.captureCallStackTrace();</span><br><span class="line">    <span class="keyword">this</span>.eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.client.dispatcher().enqueue(<span class="keyword">new</span> RealCall.AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>与同步请求一样，异步请求也涉及了一个重要的参与者  Dispatcher，它的作用是：控制每一个 Call 的执行顺序和生命周期。它内部维护了三个队列：</p>
<ul>
<li>readyAsyncCalls：等待的异步请求队列</li>
<li>runningAsyncCalls：正在运行的异步请求队列</li>
<li>runningSyncCalls：正在运行的同步请求队列</li>
</ul>
<p>对于同步请求，由于它是即时运行的， Dispatcher 只需要运行前请求前存储到 runningSyncCalls，请求结束后从 runningSyncCalls 中移除即可。</p>
<p>对于异步请求，Dispatcher 是通过启动 ExcuteService 执行，线程池的最大并发量 64，异步请求先放置在 readyAsyncCalls，可以执行时放到 runningAsyncCalls 中，执行结束从runningAsyncCalls 中移除。</p>
<p>我们看一下具体实现细节，下面是 Dispatcher 的 <code>enqueue</code> 方法，先将 AsyncCall 添加到 readyAsyncCalls。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(AsyncCall call) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将AsyncCall加入到准备异步调用的队列中</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>再看 <code>promoteAndExecute</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">            <span class="keyword">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">            i.remove();</span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">        asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里主要的工作有：</p>
<ul>
<li>从准备异步请求的队列中取出可以执行的请求（正在运行的异步请求不得超过64，同一个host下的异步请求不得超过5个），加入到 <code>executableCalls</code> 列表中。</li>
<li>循环 <code>executableCalls</code> 取出请求 AsyncCall 对象，调用其 <code>executeOn</code> 方法。 </li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        eventListener.callFailed(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到 <code>executeOn</code> 方法的参数传递的是 ExecutorService 线程池对象，方法中调用了线程池的 <code>execute</code>方法，所以 AsyncCall 应该是实现了 Runnable 接口，我们看看它的 <code>run</code> 方法是怎样的。</p>
<p>AsyncCall 继承自 NamedRunnable 抽象类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以当线程池执行 <code>execute</code> 方法会走到 NamedRunnable 的 <code>run</code> 方法，<code>run</code> 方法中又调用了 抽象方法 <code>execute</code>，我们直接看 AsyncCall 的 <code>execute</code> 方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    timeout.enter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 请求网络获取结果</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 回调结果</span></span><br><span class="line">            responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e = timeoutExit(e);</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.get().log(INFO, <span class="string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 调度完成，移出队列</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里我们又看到了熟悉的 <code>getResponseWithInterceptorChain</code> 方法。</p>
<p>这样看来，同步请求和异步请求的原理是一样的，都是在 <code>getResponseWithInterceptorChain()</code> 函数中通过 Interceptor 链条来实现的网络请求逻辑。</p>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p>以上便是 OkHttp 整个请求的具体流程，流程图如下。</p>
<p><img src="/2019/03/11/ok-analysis-1/ok.jpg" alt="okhttp"></p>
<p>简述 OkHttp 的请求流程：</p>
<ul>
<li><p>OkhttpClient 实现了 Call.Fctory，负责为 Request 创建 Call。</p>
</li>
<li><p>RealCall 是 Call 的具体实现，它的异步请求是通过 Dispatcher 调度器利用 ExcutorService 实现，而最终进行网络请求时和同步请求一样，都是通过 <code>getResponseWithInterceptorChain</code> 方法实现。</p>
</li>
<li><p><code>getResponseWithInterceptorChain</code>  方法中采用了责任链模式，每一个拦截器各司其职，主要做两件事。</p>
<ul>
<li>拦截上一层拦截器封装好的 Request，然后自身对这个 Request 进行处理，处理后向下传递。</li>
<li>接收下一层拦截器传递回来的 Response，然后自身对 Response 进行处理，返回给上一层。</li>
</ul>
</li>
</ul>

        <h2 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>
      <ul>
<li><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html">https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.im/post/5a704ed05188255a8817f4c9">https://juejin.im/post/5a704ed05188255a8817f4c9</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.jianshu.com/p/37e26f4ea57b">https://www.jianshu.com/p/37e26f4ea57b</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/02/27/java-innerclass/">Java 内部类总结</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-02-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">16分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Java 中，可以将一个类定义在另一个类或者一个方法里面，这样的类称为内部类。</p>
<p>一般包含四种内部类：成员内部类、匿名内部类、局部内部类和静态内部类。</p>

        <h2 id="成员内部类">
          <a href="#成员内部类" class="heading-link"><i class="fas fa-link"></i></a>成员内部类</h2>
      <p>成员内部类的定义位于另一个类的内部，形式如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            name = <span class="string">&quot;wuzy&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.displayName();  <span class="comment">// wuzy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。具体是如何实现的呢？通过反编译字节码看个究竟。</p>
<p>先对 Outer 类进行编译 <code>javac Outer.java</code>  ，编译器在编译的时候，会将成员内部类 Inner 单独编译成一个字节码文件 <code>Outer$Inner.class</code> 。</p>
<p>反编译 <code>Outer$Inner.class</code>  文件得到下面的信息：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$Inner.class</span><br><span class="line">Compiled from <span class="string">&quot;Outer.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">innerclassexample</span>.<span class="title">Outer</span>$<span class="title">Inner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  innerclassexample.Outer$Inner(innerclassexample.Outer);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #2                  // Field this$0:Linnerclassexample/Outer;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       6: invokespecial #3                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">9</span>: aload_1</span><br><span class="line">      10: ldc           #4                  // String wuzy</span><br><span class="line">      12: invokestatic  #5                  // Method innerclassexample/Outer.access$002:(Linnerclassexample/Outer;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">      <span class="number">15</span>: pop</span><br><span class="line">      <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> access$<span class="number">100</span>(innerclassexample.Outer$Inner);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method displayName:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到这两行关键信息</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">innerclassexample.Outer$Inner(innerclassexample.Outer);</span><br></pre></td></tr></table></div></figure>

<p>这就很明显了，编译器会默认为成员内部类添加了一个指向外部类对象的引用，这个引用的赋值默认是在构造函数中进行。因此可以在成员内部类中任意的访问外部类的成员。</p>
<p>此外也说明了成员内部类是依赖于外部类的，如果没有创建外部类，则无法对 <code>Outer this$0</code> 引用赋值，也就无法创建内部类的对象了。</p>

        <h2 id="匿名内部类">
          <a href="#匿名内部类" class="heading-link"><i class="fas fa-link"></i></a>匿名内部类</h2>
      <p>匿名内部类也就是没有名字的内部类，通常用来简化代码。</p>
<p>使用匿名内部类的前提条件：必须继承一个父类或者实现一个接口。形式如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                System.out.println(a);  </span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.test(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在 jdk 1.8 之前，匿名内部类访问方法局部变量或方法形参时，局部变量和形参必须以 <code>final</code> 修饰。</p>
<p>为什么？</p>
<p>以下是分析过程。</p>
<p>当 外部类的 <code>test</code> 方法执行完毕，局部变量 a 和 形参 b 的都会出栈，生命周期也就结束了，但此时 Thread 对象的生命周未必就结束了，那么 <code>run</code> 方法中访问 a 或者 b 就不可能了，但是又要实现这种效果，Java 采取了 <strong>复制</strong> 的手段解决了这个问题。</p>
<p>对以上代码进行编译，编译器会将匿名内部类编译成 <code>Outer$1.class</code> 文件，再对这个字节码文件进行反编译。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$<span class="number">1.</span>class</span><br><span class="line">Compiled from <span class="string">&quot;Outer.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">innerclassexample</span>.<span class="title">Outer</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Linnerclassexample/Outer;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       <span class="number">6</span>: iload_2</span><br><span class="line">       7: putfield      #2                  // Field val$b:I</span><br><span class="line">      <span class="number">10</span>: aload_0</span><br><span class="line">      11: invokespecial #3                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #4                  // Method java/lang/Thread.run:()V</span><br><span class="line">       4: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">7</span>: iconst_1</span><br><span class="line">       8: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      11: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">14</span>: aload_0</span><br><span class="line">      15: getfield      #2                  // Field val$b:I</span><br><span class="line">      18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">21</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在 <code>run</code> 方法中有一条指令：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br></pre></td></tr></table></div></figure>

<p>这条指令表示将操作数 1 压入栈中（当 int 取值-1~5 时，JVM 采用 <code>iconst</code> 指令将常量压入栈中），表示使用的是一个本地局部变量。</p>
<p>还有这三行信息：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>);</span><br></pre></td></tr></table></div></figure>

<p><code>this$0</code> 是指向外部类的引用，<code>val$b</code> 是形参 b 的拷贝，都是由编译器在构造函数中赋值初始化的。</p>
<p>从上面可以看出，如果局部变量的值在编译期间就可以确定，则直接在匿名类内部里面创建一个拷贝，如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p>
<p><strong>这就导致了一个新的问题，数据不一致</strong>。<code>run</code> 方法访问的 a 压根不是 <code>test</code> 方法的局部变量 a，当在 <code>run</code> 方法改变变量 a 时候，<code>test</code> 方法的局部变量 a 并没有改变。</p>
<p>为了解决这个问题，Java 采取了粗暴的方式，限定必须将变量 a 限制为 final 变量，不允许对变量 a 进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>
<p>这也就解释了为什么匿名内部类只能访问局部 final 变量了。</p>
<p>在 JDK 1.8 以后，匿名内部类可以访问到非 final 变量了。以下这种写法完全没问题。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.test(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>对其反编译下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$<span class="number">1.</span>class</span><br><span class="line">Compiled from <span class="string">&quot;Outer.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">innerclassexample</span>.<span class="title">Outer</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Linnerclassexample/Outer;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       <span class="number">6</span>: iload_2</span><br><span class="line">       7: putfield      #2                  // Field val$a:I</span><br><span class="line">      <span class="number">10</span>: aload_0</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      12: putfield      #3                  // Field val$b:I</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      16: invokespecial #4                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #5                  // Method java/lang/Thread.run:()V</span><br><span class="line">       4: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">7</span>: aload_0</span><br><span class="line">       8: getfield      #2                  // Field val$a:I</span><br><span class="line">      11: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      14: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">17</span>: aload_0</span><br><span class="line">      18: getfield      #3                  // Field val$b:I</span><br><span class="line">      21: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到这四行</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> val$a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> innerclassexample.Outer <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">innerclassexample.Outer$<span class="number">1</span>(innerclassexample.Outer, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></div></figure>

<p>JVM 编译器会在匿名内部类的构造函数中对局部变量 a 和 形参 b 进行拷贝赋值。而且， <code>run</code> 方法是无法修改变量 a 和 形参 b 的值的。</p>

        <h2 id="局部内部类">
          <a href="#局部内部类" class="heading-link"><i class="fas fa-link"></i></a>局部内部类</h2>
      <p>定义在方法体或者代码块里的类称为局部内部类。形式如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(num1);</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>

        <h2 id="静态内部类">
          <a href="#静态内部类" class="heading-link"><i class="fas fa-link"></i></a>静态内部类</h2>
      <p>静态内部类与成员内部类的定义方式类似，也是定义在另一个类的内部，只不过在类的前面多了一个 <code>static</code> 关键字。形式如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>静态内部类与类的静态属性类似，不依赖于对象，无法访问外部类的非静态成员，因为外部类的非静态成员依附于具体的对象。从下面的反编译结果也能看出，静态内部类是不持有外部类对象的引用的。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\project\JavaExample\src\innerclassexample&gt;javap -c Outer$Inner.class</span><br><span class="line">Compiled from &quot;Outer.java&quot;</span><br><span class="line">class innerclassexample.Outer$Inner &#123;</span><br><span class="line">  innerclassexample.Outer$Inner();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="内部类的使用场景和好处">
          <a href="#内部类的使用场景和好处" class="heading-link"><i class="fas fa-link"></i></a>内部类的使用场景和好处</h2>
      <p>1、内部类使得多继承的解决方案变得完整。内部类(除去用 static 修饰的 )可以直接使用其外部类的成员变量以及成员函数，达到一个继承的效果，再加上自身继承基类来达到一个多重继承的效果。</p>
<p>2、方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</p>
<p>3、方便编写事件驱动程序。比如 Android 里面的事件监听。</p>

        <h2 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>
      <p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3811445.html">https://www.cnblogs.com/dolphin0520/p/3811445.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/02/25/java-classloader/">Java 类加载器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-02-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">15分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="类的生命周期">
          <a href="#类的生命周期" class="heading-link"><i class="fas fa-link"></i></a>类的生命周期</h2>
      <p><img src="/2019/02/25/java-classloader/classloader_lifecycle.png" alt="classloader_lifecycle"><br>包含七个阶段：</p>
<p>加载、验证、准备、解析、初始化、使用、卸载。</p>
<ul>
<li><p>验证、准备、解析三个阶段统称为连接。</p>
</li>
<li><p>加载、验证、准备、初始化和卸载的顺序是确定的，解析和初始化的前后顺序不一定，主要是为了实现动态绑定。</p>
</li>
</ul>

        <h2 id="类加载过程">
          <a href="#类加载过程" class="heading-link"><i class="fas fa-link"></i></a>类加载过程</h2>
      <p>类加载过程主要包含加载、验证、准备、解析和初始化这 5 个阶段。</p>

        <h3 id="加载">
          <a href="#加载" class="heading-link"><i class="fas fa-link"></i></a>加载</h3>
      <p>加载是类加载的第一个阶段，注意不要混淆。</p>
<p>加载过程要完成的三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式获取：</p>
<ul>
<li>从 ZIP 包读取，称为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络获取，最典型的应用是 Applet。</li>
<li>运行时计算，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的 Class 类。</li>
</ul>

        <h3 id="验证">
          <a href="#验证" class="heading-link"><i class="fas fa-link"></i></a>验证</h3>
      <p>验证的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段主要完成四个阶段的校验动作：</p>
<ul>
<li>文件格式验证。验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</li>
<li>元数据验证。对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li>
<li>字节码验证。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证。主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。确保解析动作能正常执行。</li>
</ul>

        <h3 id="准备">
          <a href="#准备" class="heading-link"><i class="fas fa-link"></i></a>准备</h3>
      <p>为类变量分配内存并设置类变量初始值的阶段。类变量是指被 <code>static</code> 修饰的变量。</p>
<p> 这里的初始值一般是数据类型的零值。比如：</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></div></figure>
<p>变量 value 在准备阶段的初始值是 0 而不是 123。</p>
<p>如果类变量是常量，初始值是所定义的值而不是零值。例如下面的常量 value 被初始化为 123 而不是 0。</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="解析">
          <a href="#解析" class="heading-link"><i class="fas fa-link"></i></a>解析</h3>
      <p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<ul>
<li>符号引用：符号引用就是字符串，这个字符串包含足量的信息，以供实际使用时可以找到相应的位置。</li>
<li>直接引用：直接引用就是偏移量，通过便宜量虚拟机可以直接在该类的内存区域中找到方法字节码的起始位置。</li>
</ul>

        <h3 id="初始化">
          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a>初始化</h3>
      <p>初始化是类加载过程中的最后一步，这个阶段才真正开始执行类中定义的 Java 程序代码。</p>
<p>初始化阶段是虚拟机执行类构造器 <code>&lt;clinit&gt;() </code>方法的过程。</p>
<p>在准备阶段，已经为类变量分配了系统所需的初始值，并且在初始化阶段，根据程序员通过程序进行的主观计划来初始化类变量和其他资源。<code>&lt;clinit&gt;()</code> 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>

        <h2 id="类加载器">
          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a>类加载器</h2>
      <p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 <code>equals()</code> 方法、<code>isAssignableFrom()</code> 方法、<code>isInstance()</code> 方法的返回结果为 true，也包括使用 <code>instanceof</code> 关键字做对象所属关系判定结果为 true。</p>

        <h3 id="类加载器分类">
          <a href="#类加载器分类" class="heading-link"><i class="fas fa-link"></i></a>类加载器分类</h3>
      <p>从 Java 虚拟角度，只存在两种不同的类加载器：</p>
<ul>
<li>启动型类加载器（Bootstrap ClassLoader），C++ 语言实现，是虚拟机自身的一部分。</li>
<li>其他的类加载器：Java 语言实现，独立于虚拟机外部，全部继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>从 Java 开发人员的角度，类加载器大致分为以下三类：</p>
<ul>
<li><p>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在 JDK\jre\lib 下，或被 -Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。</p>
</li>
<li><p>扩展类加载器：Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.* 开头的类），开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>

        <h3 id="双亲委托模型">
          <a href="#双亲委托模型" class="heading-link"><i class="fas fa-link"></i></a>双亲委托模型</h3>
      <p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。类加载器之间的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。<br><img src="/2019/02/25/java-classloader/parents_delegation.png" alt="parents_delegation"></p>

        <h4 id="工作过程">
          <a href="#工作过程" class="heading-link"><i class="fas fa-link"></i></a>工作过程</h4>
      <p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>

        <h4 id="好处">
          <a href="#好处" class="heading-link"><i class="fas fa-link"></i></a>好处</h4>
      <p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>

        <h4 id="实现方式">
          <a href="#实现方式" class="heading-link"><i class="fas fa-link"></i></a>实现方式</h4>
      <p>实现双亲委派的代码都集中在java.lang.ClassLoader的 <code>loadClass()</code> 方法之中。</p>
<p>先检查是否已经被加载过，若没有加载则调用父加载器的 <code>loadClass()</code> 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的 <code>findClass()</code> 方法进行加载。</p>

        <h3 id="自定义-ClassLoader">
          <a href="#自定义-ClassLoader" class="heading-link"><i class="fas fa-link"></i></a>自定义 ClassLoader</h3>
      <p>继承 java.lang.ClassLoader 类，重写 <code>findClass</code> 方法。比如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>
      <ul>
<li><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0">Java 虚拟机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/02/19/threadlocal/">理解 ThreadLocal</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-02-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">15分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="ThreadLocal-是什么">
          <a href="#ThreadLocal-是什么" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 是什么</h2>
      <p>ThreadLocal 提供了线程局部变量。它和普通变量的区别在于，普通变量可以被任何一个线程访问并修改，而使用 ThreadLocal 创建的变量只能被当前线程访问，也就是线程私有，其他线程无法访问和修改。</p>

        <h2 id="ThreadLocal-用法">
          <a href="#ThreadLocal-用法" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 用法</h2>
      <p>创建：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Boolean&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></div></figure>

<p>set 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="keyword">false</span>);</span><br></pre></td></tr></table></div></figure>

<p>get 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.get()</span><br></pre></td></tr></table></div></figure>

<p>我们来看一个完整的示例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 ThreadLocal 对象</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别在主线程、子线程1和子线程2中设置和访问它的值</span></span><br><span class="line">threadLocal.set(<span class="keyword">true</span>);</span><br><span class="line">Log.e(TAG, <span class="string">&quot;[Thread#main]threadLocal=&quot;</span> + threadLocal.get() );</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">&quot;Thread#1&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="keyword">false</span>);</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[Thread#1]threadLocal=&quot;</span> + threadLocal.get() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">&quot;Thread#2&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[Thread#2]threadLocal=&quot;</span> + threadLocal.get() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></div></figure>

<p>在上面的代码中，在主线程中设置 threadLocal 的值为 true，子线程1中设置 threadLocal 的值为 false，子线程2中未设置 threadLocal 的值。</p>
<p>输出结果如下，可以看到，虽然在不同线程中访问的是同一个 ThreadLocal 对象，但是它们通过 ThreadLocal 获取的值却是不一样的。</p>
<figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Thread#main]threadLocal=true</span><br><span class="line">[Thread#1]threadLocal=false</span><br><span class="line">[Thread#2]threadLocal=null</span><br></pre></td></tr></table></div></figure>


        <h2 id="Android-中应用">
          <a href="#Android-中应用" class="heading-link"><i class="fas fa-link"></i></a>Android 中应用</h2>
      <p>在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证了每个线程只存在一个 Looper 对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="ThreadLocal-原理">
          <a href="#ThreadLocal-原理" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 原理</h2>
      <p>ThreadLocal 内部是如何实现的，我们从源码中一探究竟。</p>
<p>从 <code>set</code> 方法开始，主要工作是</p>
<ul>
<li>获取当前线程</li>
<li>获取或当前线程的 ThreadLocalMap 对象</li>
<li>如果 ThreadLocalMap 不为空，设置值；否则创建 ThreadLocalMap 对象并设置值</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>getMap</code> 方法中获取 ThreadLocalMap 的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法获取得实际是 Thread 对象的 threadLocals 变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></div></figure>

<p>如果是初次调用 <code>set</code> 方法，则 ThreadLocalMap 对象为空，会去创建 ThreadLocalMap，并设置初始值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以可以总结下 ThreadLocal 的设计思路：</p>
<p>每个 Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 TreadLocal 实例本身，value 是真正存储的值，ThreadLocalMap 只被持有它的线程访问，其他线程也就无法访问和修改。</p>
<p>我们具体看一下 ThreadLocalMap。</p>
<p>构造 ThreadLocalMap 的主要过程：</p>
<ul>
<li>初始化存放 Entry 对象的数组</li>
<li>通过 key（ThreadLocal 类型）的 hashcode 计算存储的索引位置</li>
<li>在指定索引位置存放 Entry 对象</li>
<li>记录数组中 Entry 对象的个数</li>
<li>设定数组扩展阈值</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY]; </span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue); </span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>下面来看一下 Entry 的结构：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Entry 是 ThreadLocalMap 的静态内部类，继承自 <code>WeakReference&lt;ThreadLocal&gt;</code>，从<code>super(k)</code> 可以看出 Entry 是一个对 ThreadLocal 的弱引用。另外，Entry 包含了对 value 的强引用。</p>

        <h2 id="ThreadLocal-内存泄漏的问题">
          <a href="#ThreadLocal-内存泄漏的问题" class="heading-link"><i class="fas fa-link"></i></a>ThreadLocal 内存泄漏的问题</h2>
      <p>首先绘制了 ThreadLocal 相关的对象引用内存图（实线代表强引用，虚线代表弱引用）：</p>
<p><img src="/2019/02/19/threadlocal/threadlocal.png" alt="threadlocal"></p>
<p>图中我们看到 Entry 中的  value 一直有一条从 ThreadRef 连接过来的强引用，只有当前 Thread 结束时，ThreadRef 不在栈中，强引用断开， Thread、ThreadLocalMap、value 都会被 GC 回收。</p>
<p>但是，如果使用的是线程池，那么之前的线程实例处理完之后出于复用的目的依然存活，这就发生了真正意义上的内存泄漏了。</p>
<p>为了最小化减少内存泄露的可能性和影响，ThreadLocal 的设计中加入了一些防护措施。</p>
<p><code>getEntry</code> 方法：</p>
<p>首先从索引位置获取 Entry，如果 Entry 不为空且 key 相同则返回 Entry，否则调用 <code>getEntryAfterMiss</code> 方法向下一个位置查询。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>getEntryAfterMiss</code> 方法：</p>
<p>整个过程中，如果遇到 key 为空的情况，会调用 <code>expungeStaleEntry</code> 方法进行擦除 Entry（Entry 中的 value 对象没有了强引用，自然会被回收）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果key值为null，则擦除该位置的Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>expungeStaleEntry</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置value为null</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 设置entry为null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    </span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>set</code> 方法：</p>
<p>set 方法也有同样的操作，通过 <code>replaceStaleEntry</code> 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 <code>rehash</code> 方法中通过 <code>expungeStaleEntry</code> 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。通过这种方式，ThreadLocal 可防止内存泄漏。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>replaceStaleEntry</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = prevIndex(i, len))</span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>但是，以上的设计思路依赖一个前提条件：<strong>必须调用 ThreadLocalMap  的 <code>getEntry</code> 或者 <code>set</code> 方法。</strong></p>
<p>如果这个前提条件不成立，还是会发生内存泄漏。所以，很多情况下需要手动去调用 ThreadLocal 的 <code>remove</code> 方法，手动删除不再需要的 ThreadLocal，进而释放 Entry，避免内存泄漏。此外，JDK 推荐 ThreadLocal 变量定义为 <code>private static</code> ，这样 ThreadLocal 的生命周期会更长，ThreadLocal 在线程运行中不会被回收，也就能保证任何时候都能够通过 ThreadLocal 的弱引用访问到 Entry 的 value 值，然后执行 remove 操作，防止内存泄漏。</p>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p>1、ThreadLocal 通过隐式在不同的线程中创建实例副本，避免了实例线程安全的问题。</p>
<p>2、ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收问题。</p>
<p>3、如果使用的是线程池，那么之前的线程实例处理完之后出于复用的目的依然存活，这时可能会出现内存泄漏。</p>
<p>4、ThreadLocal 为避免上述的内存泄漏，在 get 和 set 方法中都做了防护措施，但前提是这两个方法得到了执行。因此很多情况下还需要手动调用 ThreadLocal 的 <code>remove</code> 方法，避免内存泄漏。</p>
<p>5、当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/01/29/java-memory-allocation-and-collect-strategy/">Java 内存分配和回收策略</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-01-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Java 的内存分配主要是在程序运行时给对象在堆上分配内存。通常将堆内存结构按新生代和老年代进行划分，堆内存结构图如下：</p>
<p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_heap_allocation.png" alt="jvm_heap_allocation"></p>

        <h2 id="新生代">
          <a href="#新生代" class="heading-link"><i class="fas fa-link"></i></a>新生代</h2>
      <p>大部分对象创建和销毁的区域。</p>
<p>内部包含 Eden 区域，作为对象初始分配的区域；两个 Survivor，也叫 from、to 区域，用来放置从 Minor GC 中生存下来的对象。</p>
<p><strong>TLAB</strong></p>
<p>对 Eden 区域再进行划分， Hotspot JVM 还有一个概念叫着 Thread Local Allocation（TLAB），这是 JVM 为每个线程分配的一个私有缓存区域。多线程同时分配内存时，为了避免操作同一地址，可能需要使用加锁机制，进而影响分配速度。TLAB 能够解决这个问题。</p>
<p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_tlab.png" alt="jvm_tlab"></p>
<p>start、end 就是每个 TLAB 的起始结束指针，top 则表示已经分配到哪里。所以在分配新对象时，移动 top，当 top 与 end 相遇，表示该缓存已经满了， JVM 会试图再从 Eden 里分配一块。</p>

        <h2 id="老年代">
          <a href="#老年代" class="heading-link"><i class="fas fa-link"></i></a>老年代</h2>
      <p><strong>大对象直接进入老年代</strong></p>
<p>对象先在 TLAB 上分配内存，如果 TLAB 空间不足，会在 Eden 区域给对象分配空间，但是如果对象太大，无法在新生代找到足够长的连续空闲空间， JVM 会直接将对象分配到老年代。</p>
<p>这里的大对象比如是较大的字符串或者数组，因此在写程序时避免分配“朝生夕死”的大对象。</p>
<p><strong>长期存活的对象直接进入老年代</strong></p>
<p>在经历了多次 Minor GC 后仍然存活的对象，如果对象的年龄达到老年代阈值，会直接进入老年代。下文会阐述。</p>
<p><strong>动态对象年龄判定</strong></p>
<p>为了适应不同程序的内存情况，虚拟机不是永远只在对象的年龄达到老年代阈值时才将对象晋升到老年代。</p>
<p>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</p>

        <h2 id="永久代">
          <a href="#永久代" class="heading-link"><i class="fas fa-link"></i></a>永久代</h2>
      <p>早期 JVM 的方法区实现，储存 Java 常量池、类元数据等，在 JDK 8 之后取消了永久代。</p>

        <h2 id="堆内存参数">
          <a href="#堆内存参数" class="heading-link"><i class="fas fa-link"></i></a>堆内存参数</h2>
      <p>最大堆体积</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx:value</span><br></pre></td></tr></table></div></figure>

<p>最小堆体积</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms:value</span><br></pre></td></tr></table></div></figure>

<p> 老年代和新生代的比例。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：NewRatio=value</span><br></pre></td></tr></table></div></figure>

<p>默认情况，老年代是新生代的 2 倍。即 新生代是堆大小的 1/3。也可以直接调整新生代的大小。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=value</span><br></pre></td></tr></table></div></figure>

<p>Eden 和 Survivor 的大小比例。YoungGen = Eden + 2 * Survivor。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：SurvivorRatio=value</span><br></pre></td></tr></table></div></figure>

<p>堆内存结构中每一代中都存在Reserved 区域，当 Xms 小于 Xmx 时，堆的大小不会直接扩展到上限。当内存需求不断增长， JVM 会逐渐扩展区域大小，所以 Reserved 区域表示保留区域，暂时不可用的空间。</p>

        <h2 id="Minor-GC">
          <a href="#Minor-GC" class="heading-link"><i class="fas fa-link"></i></a>Minor GC</h2>
      <p>新生代 GC。</p>
<p>Java 应用不断创建对象，优先分配在 Eden 区域，当空间占用达到一定阈值时，触发 Minor GC。没有被引用的对象被回收，仍然存活的对象被复制到 JVM 选择的 Survivor 区域。如下图，数字 1 表示对象的存活年龄计数。</p>
<p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_minor_gc_1.png" alt="jvm_minor_gc_1"></p>
<p>在下一次 Minor GC 时，另外一个 Survivor 区域会成为 to 区域， Eden 区域存活的对象和 from 区域对象都会被复制到 to 区域，存活的年龄计会被加 1。</p>
<p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_minor_gc_2.png" alt="jvm_minor_gc_2"></p>
<p>上述过程会发生很多次，直到有对象年龄计数达到阈值，这些对象会被晋升到老年代。</p>
<p><img src="/2019/01/29/java-memory-allocation-and-collect-strategy/jvm_minor_gc_3.png" alt="jvm_minor_gc_3"></p>

        <h2 id="Full-GC">
          <a href="#Full-GC" class="heading-link"><i class="fas fa-link"></i></a>Full GC</h2>
      <p>新生代、老年代和永久代都进行 GC 操作。</p>
<p><strong>调用System.gc()</strong></p>
<p>代码中 <code>System.gc()</code> 方法的调用是建议 JVM 进行 Full GC，多数情况下会触发 Full GC。</p>
<p><strong>老年代空间不足</strong></p>
<p>老年代的对象主要是大对象、长期存活的对象。如果老年代空间不足时，会触发 Full GC。</p>
<p><strong>空间分配担保失败</strong></p>
<p>当准备要触发一次 Minor GC 时，如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。</p>
<p><strong>JDK 1.7 及以前永久代空间不足</strong></p>
<p>在JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。</p>
<p>在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。</p>
<p><strong>Concurrent Mode Failure</strong></p>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报 <code>Concurrent Mode Failure</code> 错误，并触发 Full GC。</p>

        <h2 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>
      <p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java 核心技术 36 讲（极客时间）</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/01/18/understand-safe-point/">JVM 安全点介绍</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-01-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">843</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">4分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="什么是安全点？">
          <a href="#什么是安全点？" class="heading-link"><i class="fas fa-link"></i></a>什么是安全点？</h2>
      <p>在 <a href="http://wuzhangyang.com/2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/">JVM 中如何判断对象可以被回收</a> 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。</p>
<p>那么，首先要找到哪些是 GC Roots。</p>
<p>有两种查找 GC Roots 的方法：</p>
<p>一种是遍历方法区和栈区查找（保守式 GC）。</p>
<p>一种是通过 OopMap 数据结构来记录 GC Roots 的位置（准确式 GC）。</p>
<p>很明显，保守式 GC 的成本太高。准确式 GC 的优点就是能够让虚拟机快速定位到 GC Roots。</p>
<p>对应 OopMap 的位置即可作为一个安全点（Safe Point）。</p>
<p>在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的”Stop-The-World”。</p>
<p>为什么呢？</p>
<p>因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。</p>
<p>安全点意味着在这个点时，所有工作线程的状态是确定的，JVM 就可以安全地执行 GC 。</p>

        <h2 id="如何选定安全点？">
          <a href="#如何选定安全点？" class="heading-link"><i class="fas fa-link"></i></a>如何选定安全点？</h2>
      <p>安全点太多，GC 过于频繁，增大运行时负荷；安全点太少，GC 等待时间太长。</p>
<p>一般会在如下几个位置选择安全点：</p>
<p>1、循环的末尾</p>
<p>2、方法临返回前</p>
<p>3、调用方法之后</p>
<p>4、抛异常的位置</p>
<p>为什么选定这些位置作为安全点：</p>
<p>主要的目的就是避免程序长时间无法进入 Safe Point。比如 JVM 在做 GC 之前要等所有的应用线程进入安全点，如果有一个线程一直没有进入安全点，就会导致 GC 时 JVM 停顿时间延长。比如<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/38232">这里</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，超大的循环导致执行 GC 等待时间过长。</p>

        <h2 id="如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？">
          <a href="#如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？" class="heading-link"><i class="fas fa-link"></i></a>如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？</h2>
      <p>主要有两种方式：</p>
<p><strong>抢断式中断</strong>：在 GC 发生时，首先中断所有线程，如果发现线程未执行到 Safe Point，就恢复线程让其运行到 Safe Point 上。</p>
<p><strong>主动式中断</strong>：在 GC 发生时，不直接操作线程中断，而是简单地设置一个标志，让各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起。</p>
<p>JVM 采取的就是主动式中断。轮询标志的地方和安全点是重合的。</p>

        <h2 id="安全区域又是什么？">
          <a href="#安全区域又是什么？" class="heading-link"><i class="fas fa-link"></i></a>安全区域又是什么？</h2>
      <p>Safe Point 是对正在执行的线程设定的。</p>
<p>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p>
<p>因此 JVM 引入了 Safe Region。</p>
<p>Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p>
<p>线程在进入 Safe Region 的时候先标记自己已进入了 Safe Region，等到被唤醒时准备离开 Safe Region 时，先检查能否离开，如果 GC 完成了，那么线程可以离开，否则它必须等待直到收到安全离开的信号为止。</p>

        <h2 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>
      <p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/01/17/java-garbage-collector/">JVM 七种垃圾收集器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-01-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Java 垃圾收集器是 <a href="http://wuzhangyang.com/2019/01/15/garbage-collection-algorithm/">垃圾收集算法</a> 的具体实现。</p>
<p>下图展示的是 7 种作用于不同分代的收集器，如果两种收集器之前有连接，表示它们可以配合使用。收集器所在的位置表示它是属于新生代收集器还是老年代收集器。</p>
<p><img src="/2019/01/17/java-garbage-collector/seven_garbage_collector.png" alt="seven_garbage_collector"></p>

        <h2 id="Serial-收集器">
          <a href="#Serial-收集器" class="heading-link"><i class="fas fa-link"></i></a>Serial 收集器</h2>
      <p><strong>单线程</strong>、<strong>串行</strong>收集器。即在垃圾清理时，必须暂停其他所有工作线程。</p>
<p>它是采用<strong>复制算法</strong>的<strong>新生代收集器</strong>。</p>
<p>下图是 Serial 收集器的运行过程。</p>
<p><img src="/2019/01/17/java-garbage-collector/serial_collector.png" alt="serial_collector"></p>

        <h2 id="ParNew-收集器">
          <a href="#ParNew-收集器" class="heading-link"><i class="fas fa-link"></i></a>ParNew 收集器</h2>
      <p>ParNew 收集器是 Serial 收集器的<strong>多线程</strong>版本。除了使用多线程收集，其他与 Serial 收集相比并无太多创新之处。</p>
<p>默认开启的线程数量与 CPU 数量相同。</p>
<p>在单 CPU 的环境，ParNew 收集器不会比 Serial 收集器更优秀。</p>
<p><img src="/2019/01/17/java-garbage-collector/parnew_collector.png" alt="parnew_collector"></p>

        <h2 id="Parallel-Scavenge-收集器">
          <a href="#Parallel-Scavenge-收集器" class="heading-link"><i class="fas fa-link"></i></a>Parallel Scavenge 收集器</h2>
      <p>Parallel Scavenge 收集器也是一个 <strong>并行的多线程</strong>新生代收集器，使用的是<strong>复制算法</strong>。</p>
<p>特点在于它的目标是达到一个可控制的吞吐量（Throughput）。</p>
<p>吞吐量就是 CPU 用于运行用户代码得时间与 CPU 消耗时间的比值。</p>
<p><strong>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</strong></p>
<p>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序地运行任务，适合在后台运行不需要太多交互的任务。</p>
<p>-XX:GCTimeRatio : 设置吞吐量大小。</p>
<p>-XX:MaxGCPauseMillis : 设置最大垃圾收集停顿时间。</p>

        <h2 id="Serial-Old-收集器">
          <a href="#Serial-Old-收集器" class="heading-link"><i class="fas fa-link"></i></a>Serial Old 收集器</h2>
      <p>Serial 收集器的老年代产品。同样是<strong>单线程</strong>，使用标<strong>记整理算法</strong>。</p>
<p><img src="/2019/01/17/java-garbage-collector/serial_collector.png" alt="serial_collector"></p>

        <h2 id="Parallel-Old-收集器">
          <a href="#Parallel-Old-收集器" class="heading-link"><i class="fas fa-link"></i></a>Parallel Old 收集器</h2>
      <p>Parallel Old 是 Parallel Scanvenge 的老年代版本，使用<strong>多线程</strong>和<strong>标记整理算法</strong>。</p>
<p><img src="/2019/01/17/java-garbage-collector/parallel_old_collector.png" alt="parallel_old_collector"></p>

        <h2 id="CMS-收集器">
          <a href="#CMS-收集器" class="heading-link"><i class="fas fa-link"></i></a>CMS 收集器</h2>
      <p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p>从名称是上看出 CMS 采用的是标记清除算法。整个过程有四个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）：仅仅标记一下 GC Roots 能关联到的对象，速度很快。</li>
<li>并发标记（CMS concurrent mark）：GC Roots Tracing 过程。</li>
<li>重新标记（CMS remark）：修正并发标记期间引用变化那一部分对象</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中，初始标记、重新标记需要“Stop The World”。并发标记和并发清除时收集器线程可以与用户线程一起工作。</p>
<p><img src="/2019/01/17/java-garbage-collector/cms_collector.png" alt="cms_collector"></p>
<p><strong>优势</strong>：</p>
<p>并发收集、低停顿。</p>
<p><strong>缺陷</strong>：</p>
<ul>
<li>对 CPU 资源敏感。多线程导致占用一部分 CPU 资源而导致应用程序变慢。</li>
<li>无法处理<strong>浮动垃圾</strong>。并发清理过程中用户线程还在运行，会产生新的垃圾，CMS 无法在当次收集中处理它们，只好等待下一次 GC 时再清理掉。这一部分垃圾称为浮动垃圾。</li>
<li>CMS 采取的标记清除算法会产生大量空间碎片。往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>

        <h2 id="G1收集器">
          <a href="#G1收集器" class="heading-link"><i class="fas fa-link"></i></a>G1收集器</h2>
      <p><strong>Region</strong></p>
<p>上述的 GC 收集器将连续的内存空间划分为新生代、老生代和永久代（JDK 8 去除了永久代，引入了元空间 Metaspace），这种划分的特点是各代的存储地址（逻辑地址）是连续的。</p>
<p>G1 (Garbage First) 的各代存储地址是不连续的，每一代都使用了 n 个不连续的大小相同的 region， 每个 region 占有一块连续的虚拟内存地址。</p>
<p><img src="/2019/01/17/java-garbage-collector/g1_region.png" alt="g1_region"></p>
<p>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p><strong>避免全堆扫描</strong></p>
<p>多个 Region 之前的对象可能会有引用关系，在做可达性分析时需要扫描整个堆才能保证准确性，这显然降低了 GC 效率。</p>
<p>为避免全堆扫描，虚拟机为 G1 中每个 Region 维护了一个与之对应的 Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable <strong>把相关引用信息记录到被引用对象所属的Region的 Remembered Set 之中</strong>。当进行内存回收时，在GC根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p>
<p><strong>G1 的运作步骤</strong>：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<p><img src="/2019/01/17/java-garbage-collector/g1_collector.png" alt="g1_collector"></p>
<p><strong>特点：</strong></p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table></div>

        <h2 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>
      <p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://crowhawk.github.io/2017/08/15/jvm_3/">深入理解JVM(3)——7种垃圾收集器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/01/15/garbage-collection-algorithm/">Java 垃圾收集算法有哪些？</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-01-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">662</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">3分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>本文主要介绍几种 Java 垃圾收集算法的原理及其优缺点。</p>

        <h2 id="标记清除（Mark-Sweep）算法">
          <a href="#标记清除（Mark-Sweep）算法" class="heading-link"><i class="fas fa-link"></i></a>标记清除（Mark-Sweep）算法</h2>
      <p>首先进行标记工作，标识出所有要回收的对象，然后进行统一回收被标记的对象。</p>
<p>对象标记的过程在 <a href="http://wuzhangyang.com/2019/01/14/java-object-self-redemption/">Java 对象的自我救赎</a> 一文中有介绍。执行过程如下图：</p>
<p><img src="/2019/01/15/garbage-collection-algorithm/mark_sweep.png" alt="mark_sweep"></p>
<p><strong>它的不足之处在于</strong>：</p>
<p>1、标记、清除的效率都不高。</p>
<p>2、清除后产生大量的内存碎片，空间碎片太多会导致在分配大对象时无法找到足够大的连续内存，从而不得不触发另一次垃圾回收动作。</p>

        <h2 id="复制（Copying）算法">
          <a href="#复制（Copying）算法" class="heading-link"><i class="fas fa-link"></i></a>复制（Copying）算法</h2>
      <p>将可用内存按容量分成大小相等的两块，每次只使用其中的一块。</p>
<p>当这一块内存用完了，就将还存活的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉。</p>
<p><strong>商用虚拟机都采用这种算法回收新生代的对象</strong>。因为新生代的对象每次回收都基本上只有 10% 左右的对象存活，需要复制的对象少，效率高。执行过程如下图：</p>
<p><img src="/2019/01/15/garbage-collection-algorithm/copying.png" alt="copying"></p>
<p><strong>优点：</strong></p>
<p>因为是对整个半区进行内存回收，内存分配时不用考虑内存碎片等情况。实现简单，效率较高。</p>
<p><strong>不足之处：</strong></p>
<p>既然要复制，需要提前预留内存空间，有一定的浪费。</p>
<p>在对象存活率较高时，需要复制的对象较多，效率将会变低。</p>

        <h2 id="标记整理（Mark-Compact）算法">
          <a href="#标记整理（Mark-Compact）算法" class="heading-link"><i class="fas fa-link"></i></a>标记整理（Mark-Compact）算法</h2>
      <p>与标记清除算法类似，但不是在标记完成后对可回收对象进行清理，而是将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。执行过程如下图：</p>
<p><img src="/2019/01/15/garbage-collection-algorithm/mark_compact.png" alt="mark_compact"></p>
<p><strong>优点：</strong></p>
<p>消除了标记清除导致的内存分散问题，也消除了复制算法中内存减半的高额代价。</p>
<p><strong>不足之处：</strong></p>
<p>效率低下，需要标记所有存活对象，还要标记所有存活对象的引用地址。效率上低于复制算法。</p>

        <h2 id="分代收集（Generational-Collection）算法">
          <a href="#分代收集（Generational-Collection）算法" class="heading-link"><i class="fas fa-link"></i></a>分代收集（Generational Collection）算法</h2>
      <p>根据对象存活周期的不同将内存划分为几块。对不同周期的对象采取不同的收集算法。</p>
<p>新生代：每次垃圾收集会有大批对象回收，所以采取复制算法。</p>
<p>老年代：对象存活率高，采取标记清理或者标记整理算法。</p>

        <h2 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h2>
      <p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/01/14/java-object-self-redemption/">Java 对象的自我救赎</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-01-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">459</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">3分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>JVM 通过<a href="http://wuzhangyang.com/2019/01/12/how-do-jvm-kown-if-an-object-can-be-recycled/">可达性分析算法判断一个对象是否可以被回收</a> ，但并不是一个对象不可达时，就宣告“死刑”的，此时只是暂时处于”缓刑“阶段。要宣告一个对象“死刑”，至少还要经历两次标记过程。</p>
<p><img src="/2019/01/14/java-object-self-redemption/java_object_self_redemption.png" alt="java_object_self_redemption"></p>
<p>没有必要执行 <code>finalize()</code> 方法的筛选条件取决于：</p>
<p>1、 <code>finalize()</code> 方法已经被执行过（finalize()`只会执行一次）。</p>
<p>2、对象没有重写 <code>finalize()</code>方法。 </p>
<p>如果一个对象有必要执行  <code>finalize()</code> 方法，会进入 F-Queue 队列，等待 Finalizer 线程执行。</p>
<p><strong>因此如果想要完成对象自救， <code>finalize()</code>是逃脱死亡的最后一次机会，重新与引用链上的任何一个对象关联起来就可以，在第二次标记时，对象会被移出回收队列，完成自救。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我挂了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我还活着&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 finalize 方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 把当前对象( this )赋值给某个类变量, 重新与引用链建立引用</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>扩展：</p>
<p> <code>finalize()</code> 方法的执行线程 Finalizer 优先级级别低，无法保证  <code>finalize()</code> 方法什么时候执行，执行是否符合预期，使用不当会影响性能。</p>
<p>Java 9 中已经将  <code>finalize()</code> 方法标记为废弃了，如果没有特别的原因，不要重写  <code>finalize()</code> 方法，也别指望它能回收资源。相反，尽量使用 <code>try-finally</code> 、 <code>try-with-resources</code> 等机制是非常好的资源回收方法。</p>

        <h2 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>
      <p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/4/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">万物之中，希望至美</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/zywudev/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/zywu-43/" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a><a class="sidebar-ov-social-item" href="https://weixin.sogou.com/weixin?query=%E8%B4%BE%E5%B0%8F%E6%98%86/" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">100</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">41</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>贾小昆</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.1.1</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script><script type="application/json" src="/search.xml"></script></body></html>